# 系统设计与优化&amp;DDIA :see_no_evil:
## 目录

<a name="3060-1621846615933"></a><a name="3kvn-1704771587695"></a>[一.数据库设计](#jeyl-1677787446995)

<a name="p5fw-1704771587697"></a>[1. 关系型数据库](#5hya-1677787446996)

<a name="y9dd-1704771587699"></a>[.E-R图，由台湾工程师提出的设计概念](#ohc5-1621692571287)

<a name="ekou-1704771587701"></a>[.流程图-业务逻辑相关，系统用户动作。抽象出E-R图](#5ocb-1645598528868)

<a name="iwsv-1704771587703"></a>[1.1 E-R图 ](#gzqe-1677787446997)

<a name="ygoy-1704771587705"></a>[1.根据名词抽象出实体](#r1ac-1621692724628)

<a name="laql-1704771587707"></a>[2.名词找属性](#d2fl-1621692745600)

<a name="1tmw-1704771587710"></a>[3.实体间联系](#dwkp-1621692752824)

<a name="jhju-1704771587712"></a>[1.2 转化成数据库设计（公式）](#c2cy-1677787446998)

<a name="vgur-1704771587714"></a>[.1 对1 关系 往记录少的乙方加主键](#xmox-1621692858500)

<a name="o8am-1704771587716"></a>[.1对n 关系 ，往 n 实体加关联主键 ](#mdr8-1621692924289)

<a name="auhn-1704771587718"></a>[. n对 m 关系，需要一个关联表作映射关联](#hd3i-1621692960576)

<a name="cquf-1704771587720"></a>[二.系统优化](#cdso-1677787447000)

<a name="bfpm-1704771587722"></a>[应用整体的优化](#3qep-1642647362896)

<a name="6jig-1704771587724"></a>[-cpu -> 纳秒级别](#knge-1642647371136)

<a name="voem-1704771587726"></a>[1.多线程和并发编程](#ovup-1704437622969)

<a name="0l9z-1704771587728"></a>[2.JNI ](#ufpl-1704437634986)

<a name="w9qo-1704771587730"></a>[3.JIT/AOT编译](#ixb5-1704437634987)

<a name="bn3p-1704771587732"></a>[4.算法优化](#kr1f-1704437634988)

<a name="ethv-1704771587734"></a>[-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)](#1xur-1642647384168)

<a name="x2dm-1704771587736"></a>[1.JVM内存管理](#7hi9-1704437851514)

<a name="utk7-1704771587738"></a>[2.缓存](#te7c-1704437851799)

<a name="bg3w-1704771587740"></a>[3.消息中间件](#bqty-1704437851800)

<a name="dfo5-1704771587742"></a>[-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)](#ziti-1642647439005)

<a name="vtia-1704771587744"></a>[1.减少磁盘io](#zups-1704437900079)

<a name="dtgz-1704771587746"></a>[2.数据压缩   ](#u3ok-1704438035018)

<a name="tyh7-1704771587748"></a>[-网络传输/系统交互 -> 秒级 (减少io，连接池化) ](#irbp-1642647458856)

<a name="0e3k-1704771587750"></a>[1.减少网络请求   ](#6qil-1704438276193)

<a name="m7ja-1704771587752"></a>[2.使用CDN](#p5dt-1704438283633)

<a name="newn-1704771587754"></a>[3.Sockets异步通信                                      ](#zhp8-1704438283634)

<a name="drb1-1704771587756"></a>[项目架构层面的优化](#3l0l-1704424353262)

<a name="g3m4-1704771587758"></a>[-多级缓存](#8o8s-1704424396933)

<a name="gwh0-1704771587760"></a>[-应用层](#trcg-1704438366333)

<a name="exjc-1704771587762"></a>[代码优化](#68oa-1704438530062)

<a name="spf0-1704771587764"></a>[数据库优化](#clmf-1704438530257)

<a name="usqj-1704771587766"></a>[日志优化](#md03-1704438530259)

<a name="jysr-1704771587768"></a>[-监控与调优](#ocux-1704438477879)

<a name="jmqa-1704771587770"></a>[性能监控：](#vdq2-1704438556836)

<a name="6eu0-1704771587772"></a>[分析和调优](#t29d-1704438557094)

<a name="wkdr-1704771587774"></a>[-分布式系统架构](#ukjf-1704424419442)

<a name="vwa6-1704771587776"></a>[  .负载均衡](#a0bx-1704438677201)

<a name="03z2-1704771587778"></a>[分布式缓存](#xn9x-1704438687994)

<a name="kvsh-1704771587780"></a>[服务降级和容错](#zcdp-1704438687996)

<a name="y0h5-1704771587782"></a>[读写层面](#six7-1642647372926)

<a name="ctdt-1704771587784"></a>[.读优化](#g4uv-1704732583614)

<a name="lxlz-1704771587786"></a>[1.缓存](#uuzh-1704732602620)

<a name="vglj-1704771587788"></a>[2.索引](#qobc-1704732605892)

<a name="swrl-1704771587790"></a>[3.减少io/批量读](#zlg9-1704732609048)

<a name="830l-1704771587793"></a>[4.减少多余数据加载/列式存储读](#fpjd-1704732631316)

<a name="hau7-1704771587795"></a>[.写优化](#oyob-1704732598377)

<a name="9f6c-1704771587797"></a>[1.异步写](#6jmb-1704732509150)

<a name="ys7a-1704771587799"></a>[2.并发写](#tkwp-1704732723564)

<a name="gnlq-1704771587801"></a>[3.批量写](#hewz-1704732862030)

<a name="xcad-1704771587803"></a>[4.优化算法和数据结构](#ccd8-1704732727854)

<a name="hzqh-1704771587805"></a>[5.缓存写](#eqd9-1704732736281)

<a name="pwgt-1704771587807"></a>[6.非阻塞io](#hyq8-1704732768916)

<a name="sgtl-1704771587809"></a>[1.分控系统优化复盘](#tncv-1677787447001)

<a name="gd4s-1704771587811"></a>[1.1 数据库系统](#ydq7-1677787447002)

<a name="mwcl-1704771587813"></a>[1.2 sql慢](#wxdd-1677787447003)

<a name="gz8n-1704771587815"></a>[1.3 接口慢](#olpb-1677787447004)

<a name="bz44-1704771587817"></a>[高并发系统设计](#wrwk-1642647280506)

<a name="lsvi-1704771587819"></a>[1.满足大规模用户同时访问，提供良好响应时间和性能](#8ien-1704757782146)

<a name="ojv7-1704771587821"></a>[2.设计之初就要考虑伸缩性和容错性是非常重要的](#xy0g-1704757785190)

<a name="4xpw-1704771587823"></a>[1.分布式架构](#fvzi-1704756770858)

<a name="gxib-1704771587825"></a>[.微服务架构](#ywzr-1704756872033)

<a name="ncy7-1704771587827"></a>[.分布式计算](#xgna-1704756877646)

<a name="unzy-1704771587829"></a>[2.负载均衡](#wnfy-1704756775272)

<a name="ky2z-1704771587831"></a>[.负载均衡](#h6nf-1704756891918)

<a name="oxxu-1704771587833"></a>[.水平扩展](#c8zr-1704756894402)

<a name="hc4m-1704771587835"></a>[3.数据库设计](#wxjk-1704756782840)

<a name="9v9k-1704771587837"></a>[.读写分离](#lxca-1704756910837)

<a name="yzke-1704771587839"></a>[.数据库分片](#p7d2-1704756922362)

<a name="x7q2-1704771587841"></a>[.缓存](#hxjt-1704756963988)

<a name="ntij-1704771587843"></a>[4.缓存优化](#iivs-1704756788012)

<a name="rlzp-1704771587845"></a>[.分布式缓存](#cvui-1704756971791)

<a name="k8e2-1704771587847"></a>[.本地缓存](#ysly-1704756979122)

<a name="dlj2-1704771587849"></a>[.缓存预热](#rqwj-1704756986363)

<a name="q3l3-1704771587851"></a>[5.消息队列](#so9h-1704756800253)

<a name="bwri-1704771587853"></a>[.异步处理](#sxlo-1704756996000)

<a name="7x8b-1704771587855"></a>[.削峰填谷](#llm2-1704757002994)

<a name="9bqu-1704771587857"></a>[6.分布式事务](#n39o-1704756805232)

<a name="6hls-1704771587859"></a>[.两阶段提交](#5bhj-1704757017700)

<a name="qwul-1704771587861"></a>[.补偿事务](#becc-1704757028036)

<a name="9avd-1704771587863"></a>[7.高可用和容错](#wgkk-1704756813448)

<a name="xypw-1704771587865"></a>[.多地域部署](#akwz-1704757035393)

<a name="jfur-1704771587867"></a>[.设计容错](#3nxv-1704757055271)

<a name="dzaj-1704771587869"></a>[1. 熔断限流](#g3xx-1704757371028)

<a name="lu75-1704771587871"></a>[2. 多节点服务](#jafy-1704757374368)

<a name="qznm-1704771587873"></a>[8.监控和性能调优](#ilyo-1704756820772)

<a name="hmdc-1704771587875"></a>[.实时监控](#kpwq-1704757064566)

<a name="03xt-1704771587877"></a>[.性能测试](#shf4-1704757066453)

<a name="jwa4-1704771587879"></a>[9.安全性设计](#2pry-1704756830245)

<a name="n1fa-1704771587882"></a>[.防御性编程](#pkiw-1704757078583)

<a name="0oy3-1704771587884"></a>[.访问控制](#g4l1-1704757084924)

<a name="91bv-1704771587886"></a>[10.水平扩展](#1tsd-1704756838192)

<a name="rlvq-1704771587888"></a>[.自动化部署](#r1dd-1704757092061)

<a name="tyab-1704771587890"></a>[.云服务](#7mhk-1704757104117)

<a name="tnmh-1704771587892"></a>[高并发性能指标](#rpxb-1677787447005)

<a name="aqlg-1704771587894"></a>[QPS(每秒请求)](#klnv-1704761369323)

<a name="l9dq-1704771587896"></a>[TPS(每秒事务)](#zvlz-1704761369324)

<a name="m9dx-1704771587898"></a>[RT(响应时间)](#gvrn-1704761369325)

<a name="gcha-1704771587900"></a>[===数据密集型应用===](#ozkt-1704761368259)

<a name="lvyu-1704771587902"></a>[设计数据密集型应用](#unbe-1677787447006)

<a name="jrig-1704771587904"></a>[1.可靠性、可拓展性、可维护性能](#kwfx-1677787447007)

<a name="oiex-1704771587906"></a>[-功能性需求：CRUD](#lykw-1644227240038)

<a name="ytnp-1704771587908"></a>[-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性](#b2tu-1644227249556)

<a name="8vfp-1704771587910"></a>[.可靠性：](#qqm5-1644227303238)

<a name="6qza-1704771587912"></a>[.可扩展性： ](#7xms-1644228225080)

<a name="w3ok-1704771587914"></a>[.可维护性：   ](#elzq-1644228563046)

<a name="qwvx-1704771587916"></a>[2.数据模型与查询语言](#jufm-1677787447008)

<a name="mwxz-1704771587918"></a>[-关系模型](#pgu6-1699844351041)

<a name="n7mv-1704771587920"></a>[-NoSql (es,redis)](#kfpd-1644410618294)

<a name="mmjt-1704771587922"></a>[1.文档数据库：](#0p23-1644410807294)

<a name="mv9k-1704771587924"></a>[  2.图形数据库 ：](#09bl-1644410666587)

<a name="7lzm-1704771587926"></a>[-其它模型(基因序列)](#6fxw-1644410924417)

<a name="bama-1704771587928"></a>[3.存储与检索](#sm0u-1677787447009)

<a name="a1m4-1704771587930"></a>[-优化事务处理（OLTP）transaction ](#bhcv-1644935436804)

<a name="o83d-1704771587932"></a>[1.OLTP系统通常面向用户，大量的请求。](#tbhw-1699844517372)

<a name="bwuv-1704771587934"></a>[2.磁盘寻道时间往往是这里的瓶颈。](#fnev-1644935714127)

<a name="yqay-1704771587936"></a>[3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。](#cjwp-1644935609899)

<a name="lwxw-1704771587938"></a>[-优化分析（OLAP）analys](#jg7s-1699844443567)

<a name="00zt-1704771587940"></a>[1.列式储存(投影操作，压缩技术，聚合过滤)](#pjd1-1703887811615)

<a name="sq4y-1704771587942"></a>[-OLTP两大主流学派的存储引擎：](#8sgm-1644935924013)

<a name="k6yk-1704771587944"></a>[1.日志结构学派](#i55y-1644935943748)

<a name="fuxg-1704771587946"></a>[2.就地更新学派](#h3il-1644935977285)

<a name="espo-1704771587948"></a>[4.编码（序列化）与演化(XML,JSON,CSV)](#lbs1-1677787447010)

<a name="g05c-1704771587950"></a>[分布式系统](#d4ge-1677787447011)

<a name="llyc-1704771587952"></a>[4.分布式数据](#4p9n-1677787447012)

<a name="a8tv-1704771587954"></a>[1.高可用性](#o4ag-1646310813851)

<a name="jspe-1704771587956"></a>[2.断开连接的操作](#snwm-1646310894841)

<a name="dlej-1704771587958"></a>[3.减少延迟(节点近)](#evly-1646310918322)

<a name="essz-1704771587960"></a>[4.可拓展性](#itsh-1646310968967)

<a name="slal-1704771587963"></a>[-复制的三种主要方法：](#gbgq-1646311175182)

<a name="nano-1704771587965"></a>[1.单主复制](#wg6v-1646311185918)

<a name="q543-1704771587967"></a>[2.多主复制](#ftqb-1646311200843)

<a name="rpjb-1704771587969"></a>[3.无主复制](#4xbf-1646311410600)

<a name="gszi-1704771587971"></a>[-一致性模型：](#nlnz-1699845075606)

<a name="kuck-1704771587973"></a>[1.写后读](#anqq-1646312272172)

<a name="kjaq-1704771587975"></a>[2.单调读](#hedn-1646312288296)

<a name="4idn-1704771587977"></a>[3.一致前缀读](#fizh-1646312291911)



<a name="jeyl-1677787446995"></a>**一.数据库设计**

<a name="5hya-1677787446996"></a>**1. 关系型数据库**

<a name="ohc5-1621692571287"></a>**.E-R图，由台湾工程师提出的设计概念**

<a name="4z7m-1645598900270"></a>权益系统数据库设计复盘：雄爷并行看需求文档一两天设计DB。

<a name="5ocb-1645598528868"></a>**.流程图-业务逻辑相关，系统用户动作。抽象出E-R图**

<a name="gzqe-1677787446997"></a>**1.1 E-R图** 

<a name="r1ac-1621692724628"></a>**1.根据名词抽象出实体**

<a name="d2fl-1621692745600"></a>**2.名词找属性**

<a name="dwkp-1621692752824"></a>**3.实体间联系**

<a name="cyqi-1699843717785"></a>（单条记录对应关系 A表一条记录对应B表多条记录，B表一条记录对应A表多条记录即 m对）

<a name="53bo-1621692829033"></a><a name="c2cy-1677787446998"></a>**1.2 转化成数据库设计（公式）**

<a name="xmox-1621692858500"></a>**.1 对1 关系 往记录少的乙方加主键**

<a name="mdr8-1621692924289"></a>**.1对n 关系 ，往 n 实体加关联主键** 

<a name="hd3i-1621692960576"></a>**. n对 m 关系，需要一个关联表作映射关联**

<a name="p0tb-1655431896857"></a><a name="i6pd-1655431897042"></a>最好不要自己设计自己的表，关乎字段名统一（属性思想上的统一），以及字段冗余，字段依赖问题。

<a name="cdso-1677787447000"></a>**二.系统优化**

<a name="3qep-1642647362896"></a>**应用整体的优化**

<a name="knge-1642647371136"></a>**-cpu -> 纳秒级别**

<a name="ovup-1704437622969"></a>**1.多线程和并发编程**

<a name="ufpl-1704437634986"></a>**2.JNI** 

<a name="ixb5-1704437634987"></a>**3.JIT/AOT编译**

<a name="kr1f-1704437634988"></a>**4.算法优化**

1\.多线程和并发编程：多线程和并发重复利用多核CPU,利用线程池管理复用线程，避免创建和销毁线程昂贵开销。

2\.JNI: C本地代码调度CPU

3\.JIT/AOT编译：JVM 和 JIT 足够时间来优化热点代码 / 云原生native Graavm ahead of time(AOT)静态编译

<a name="pojo-1704436320217"></a>4.算法优化：优化关键算法和数据结构，确保CPU执行效率

<a name="1xur-1642647384168"></a>**-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)**

<a name="7hi9-1704437851514"></a>**1.JVM内存管理**

<a name="te7c-1704437851799"></a>**2.缓存**

<a name="bqty-1704437851800"></a>**3.消息中间件**

(空间换时间)

1\.JVM内存管理：设置合理的堆大小及垃圾回收策略。

2\.缓存：redis缓存，spring缓存，ORM缓存

<a name="pxxu-1704436648342"></a>3.消息中间件：异步写，提高并发写能力。-吞吐量

<a name="ziti-1642647439005"></a>**-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)**

<a name="zups-1704437900079"></a>**1.减少磁盘io**

<a name="u3ok-1704438035018"></a>**2.数据压缩**   

1\.减少io(磁盘读写): 异步io,sql索引,局部性原理加载相邻页数据 ,DB数据磁盘预读----数据存储一般在DB系统中

<a name="ayss-1704436737847"></a>2.数据压缩：对需要存储或传输的数据进行压缩，减少磁盘占用

<a name="irbp-1642647458856"></a>**-网络传输/系统交互 -> 秒级 (减少io，连接池化)** 

<a name="6qil-1704438276193"></a>**1.减少网络请求**   

<a name="p5dt-1704438283633"></a>**2.使用CDN**

<a name="zhp8-1704438283634"></a>**3.Sockets异步通信**                                      

1\.减少网络请求：减少io(系统交互/连接池连接数)：去除for循环sql 

`    `--池化思想，创建和销毁消耗大的资源创建一个资源池，维护一定数量的资源数，统一管理资源创建和销毁

2\.使用CDN: 对于静态资源，使用内容分发网络（CDN）来加速资源的加载。

<a name="85si-1704436765735"></a>3.Sockets异步通信：对于需要等待的网络通信，可以考虑使用异步方式。

<a name="3l0l-1704424353262"></a>**项目架构层面的优化**

<a name="8o8s-1704424396933"></a>**-多级缓存**

亿级流量-多级缓存

<a name="lm7b-1704438499917"></a>浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

<a name="trcg-1704438366333"></a>**-应用层**

<a name="68oa-1704438530062"></a>**代码优化**

<a name="clmf-1704438530257"></a>**数据库优化**

<a name="md03-1704438530259"></a>**日志优化**

·代码优化:通过代码审查和性能分析工具来识别和优化慢速或低效的代码。

·数据库优化:对于数据库访问，使用索引、合理的查询语句，以及数据库连接池等来提高性能。

<a name="8o0m-1704438517387"></a>·日志优化:避免过度记录日志，尽量异步记录，或者使用日志级别进行动态调整。

<a name="ocux-1704438477879"></a>**-监控与调优**

<a name="vdq2-1704438556836"></a>**性能监控：**

<a name="t29d-1704438557094"></a>**分析和调优**

·性能监控:使用性能监控工具，例如Java Mission Control、VisualVM等，来实时监测应用程序的性能。

<a name="l3kg-1704437252457"></a>·分析和调优:根据监控结果，进行分析并进行调优，优化性能瓶颈。

<a name="ukjf-1704424419442"></a>**-分布式系统架构**

<a name="a0bx-1704438677201"></a>  **.负载均衡**

<a name="xn9x-1704438687994"></a>**分布式缓存**

<a name="zcdp-1704438687996"></a>**服务降级和容错**

浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

`                `CDN                  SLB负载均衡        分布式缓存          异步通信、MQ异步写/并发写、容错降级

·负载均衡:对于分布式系统，使用负载均衡来分配请求，以确保各个节点的负载均匀。

·分布式缓存:使用分布式缓存来减轻数据库负担，提高数据读取速度。

<a name="xpee-1704438657125"></a>·服务降级和容错:实现服务降级和容错机制，以应对网络或服务不稳定的情况。

<a name="six7-1642647372926"></a>**读写层面**

<a name="g4uv-1704732583614"></a>**.读优化**

<a name="uuzh-1704732602620"></a>**1.缓存**

<a name="qobc-1704732605892"></a>**2.索引**

<a name="zlg9-1704732609048"></a>**3.减少io/批量读**

<a name="fpjd-1704732631316"></a>**4.减少多余数据加载/列式存储读**

<a name="oyob-1704732598377"></a>**.写优化**

<a name="6jmb-1704732509150"></a>**1.异步写**

<a name="tkwp-1704732723564"></a>**2.并发写**

<a name="hewz-1704732862030"></a>**3.批量写**

<a name="ccd8-1704732727854"></a>**4.优化算法和数据结构**

<a name="eqd9-1704732736281"></a>**5.缓存写**

<a name="hyq8-1704732768916"></a>**6.非阻塞io**

1\.批量操作:将多个写操作合并为批量操作，减少与数据库或其他外部存储的交互次数。例如，使用批量插入、批量更新或批量删除等操作，以减少单个写操作的开销。2.异步写入:使用异步写入的方式，将写操作放入队列或缓冲区中，由专门的线程异步处理。这样可以将写操作与主程序解耦，提高响应速度，并将写入操作批量化。

3\.数据库优化:对于关系型数据库，可以考虑优化数据库的配置和索引，以提高写入性

能。使用合适的数据库引擎和事务隔离级别，并优化查询和写入语句的性能。

4\.使用缓存:对于频繁的写入操作，可以使用缓存来减少对数据库的直接访问。将数据写入缓存，并通过批量或定期更新将数据同步到持久化存储。

5\.数据结构优化:选择合适的数据结构来存储数据，以提高写入性能。例如，使用哈希表、跳表等高效的数据结构来支持快速插入和更新操作。

6\.并发处理:使用多线程或分布式处理来并行处理写入操作，以提高写入性能。使用线程池或任务调度器来管理并发写入任务，并确保线程安全和数据─致性。

7\.使用非阻塞IO:对于高并发的写入操作，可以使用非阻塞IO技术，如NIO (New lO)或Netty等，以提高写入性能和吞吐量。

8\.数据分片:如果数据量较大，可以考虑将数据分片存储，将数据分散到多个存储节点上。这样可以将写入操作分散到多个节点上并行处理，以提高写入性能和扩展性。9.写缓冲:使用写缓冲区来缓存写入的数据，减少对物理存储设备的实时写入。通过批

<a name="z4ya-1704738513279"></a>量或异步的方式将缓冲区的数据定期写入存储设备，以提高写入性能。

<a name="tncv-1677787447001"></a>**1.分控系统优化复盘**

<a name="ydq7-1677787447002"></a>**1.1 数据库系统**

<a name="xsbg-1642647218571"></a>数据库的性能过低

<a name="eg0t-1642647223498"></a>提升硬件配置

<a name="wxdd-1677787447003"></a>**1.2 sql慢**

<a name="javd-1642647045138"></a>数据量大一千6百多万条数据

<a name="no1c-1642647140123"></a>删除冗余数据，每天采集13次，需求7天外数据只保留最新一批数据，修正删除的sql, 剩余数据，200w~600w左右。

<a name="ykot-1642649009232"></a>添加索引

<a name="olpb-1677787447004"></a>**1.3 接口慢**

<a name="blpq-1642649142995"></a>for循环遍历sql

<a name="s2zh-1642649153917"></a>去除for循环sql

<a name="yryq-1642649204976"></a> 频繁的采集种erverywhere log.info

<a name="afeg-1642649254648"></a>减少日志文件io，非必要信息改为debug。

<a name="fjt3-1643394063817"></a><a name="efqc-1643394063942"></a>优先考虑优化代价比较少的代码优化及sql优化，完成此类优化再考虑系统设计层面的优化，如：分库分表等（系统复杂度提升）。

<a name="navz-1652597408993"></a>一期历史数据重大bug修复方案设计问题（参看文档）： 注意像算法那样考虑极端情况（bug）处理，梳理方案的优缺点，对比不同方案实现优缺点接受度。

<a name="w6cm-1652597504660"></a>1.保证数据为最新的一批：

<a name="o4ka-1652597649729"></a>原方案. 每天13批次数据，不做事务回滚，取maxid ，>24小时数据删除---<24小时当天取消航班会在其中

<a name="ihuw-1652599412442"></a>配置难点：采集时段不同，每个账号采集不同天数; 采集的时间频率不同：

<a name="uarz-1652598784895"></a>熊爷方案：不改动原有逻辑，增加字段增加判段历史数据逻辑。

<a name="yxwj-1652599128439"></a>优点：基本不用改动一期代码和逻辑，改动sql增加判断历史条件。

<a name="rjdk-1652599326567"></a>缺点：新增判断的逻辑需要批次保证事务性，且配置难度很大，跨小时频率或者地区重叠，不可保证批次完整性，对比无效且配置和代码都得写死。

<a name="cehv-1652599093885"></a>我的方案：保证批次完整性，失败的批次直接整批删除，取最新一批。也是仅改动sql，获取最新一批批次代替 max(id)。

<a name="fm9n-1652599202701"></a>优点：只需要天数不重叠即可，配置相对灵活。

<a name="0ckh-1652599307805"></a>缺点：需要改sql逻辑，业务逻辑影响风险较大，需仔细验证。

<a name="nwww-1652597653246"></a> 

<a name="yjau-1644231171609"></a>分控系统重构设计

<a name="q9y5-1644231078993"></a>可靠性：写操作频繁，250k/h ~70次请求/s，将采集和后台分开两个应用。目前问题，采集两周左右系统资源耗尽会挂，可有多台服务器，实际上只用了两台。（集成应用监控，实现预警）

<a name="1ozg-1644231149674"></a>可拓展性：暂无,用户负载暂无数据

<a name="nbg9-1644231153386"></a>可维护性：代码质量，可读性。

<a name="wrwk-1642647280506"></a>**高并发系统设计**

<a name="8ien-1704757782146"></a>**1.满足大规模用户同时访问，提供良好响应时间和性能**

<a name="xy0g-1704757785190"></a>**2.设计之初就要考虑伸缩性和容错性是非常重要的**

<a name="wr12-1704947861599"></a>**.垂直伸缩** 

<a name="bizh-1704947959744"></a>**.水平伸缩**

·随着互联网的普及，用户访问量可能会在短时间内急剧增加。高并发系统设计可以确保系统在面对大规模用户同时访问时能够提供良好的响应时间和性能。

.高并发系统的设计是一个复杂而动态的过程，需要根据业务需求和系统特点不断优化。在设计之初就考虑到系统的可伸缩性和容错性是非常重要的。

` `垂直伸缩

`  `+配置32核CPU +124GB内存 +500G硬盘

优点；方案简单，易理解操作

缺点：容易达到机器物理上限，不具备高可用能力，单点故障高。

水平伸缩

<a name="4kjn-1704757525367"></a>多实例高可用，无需高性能服务器也可进行伸缩。

<a name="fvzi-1704756770858"></a>**1.分布式架构**

<a name="ywzr-1704756872033"></a>**.微服务架构**

<a name="xgna-1704756877646"></a>**.分布式计算**

·微服务架构:使用微服务拆分系统，将系统拆分成多个小而独立的服务，每个服务专注于特定的业务功能。

<a name="6khx-1704757167738"></a>·分布式计算:将任务分布到多个节点上，以充分利用计算资源。

<a name="wnfy-1704756775272"></a>**2.负载均衡**

<a name="h6nf-1704756891918"></a>**.负载均衡**

<a name="c8zr-1704756894402"></a>**.水平扩展**

·负载均衡器:使用负载均衡器分配请求到多个服务器，确保各个服务器的负载均衡。

<a name="o1d2-1704757209512"></a>·水平扩展:可以通过增加服务器数量来水平扩展系统，以支持更多的并发请求。

<a name="wxjk-1704756782840"></a>**3.数据库设计**

<a name="lxca-1704756910837"></a>**.读写分离**

<a name="p7d2-1704756922362"></a>**.数据库分片**

<a name="hxjt-1704756963988"></a>**.缓存**

·读写分离:使用读写分离来分担数据库的读写负载，提高数据库性能。

·数据库分片:将数据库分片，使数据分布在多个节点上，降低单—数据库的压力

<a name="yymm-1704757244191"></a>·缓存:使用缓存来减轻数据库负担，提高数据读取速度。

<a name="iivs-1704756788012"></a>**4.缓存优化**

<a name="cvui-1704756971791"></a>**.分布式缓存**

<a name="ysly-1704756979122"></a>**.本地缓存**

<a name="rqwj-1704756986363"></a>**.缓存预热**

·分布式缓存:使用分布式缓存，如Redis或Memcached，以提高数据的读取速度。

·本地缓存:在服务端使用本地缓存，减少对数据库或远程服务的请求次数。

<a name="vkcq-1704757254304"></a>·缓存预热:在系统启动时，预先加载一部分热门数据到缓存中，提高缓存命中率。

<a name="so9h-1704756800253"></a>**5.消息队列**

<a name="sxlo-1704756996000"></a>**.异步处理**

<a name="llm2-1704757002994"></a>**.削峰填谷**

·异步处理:使用消息队列进行异步处理，将一些非实时关键路径的任务放入队列中处理，减轻服务器负担。

<a name="99fz-1704757286906"></a>·削峰填谷:缓解系统压力，通过消息队列实现请求的削峰填谷，防止瞬时大量请求导致系统崩溃。

<a name="n39o-1704756805232"></a>**6.分布式事务**

<a name="5bhj-1704757017700"></a>**.两阶段提交**

<a name="becc-1704757028036"></a>**.补偿事务**

两阶段提交（2PC):在分布式环境中，确保事务的一致性，可以使用两阶段提交协议。

<a name="qset-1704757299753"></a>·补偿事务:使用补偿事务机制，处理在分布式环境中的异常情况。

<a name="wgkk-1704756813448"></a>**7.高可用和容错**

<a name="akwz-1704757035393"></a>**.多地域部署**

<a name="3nxv-1704757055271"></a>**.设计容错**

<a name="g3xx-1704757371028"></a>**1. 熔断限流**

<a name="jafy-1704757374368"></a>**2. 多节点服务**

·多地域部署:在不同地理位置部署系统，提高系统的可用性。

<a name="h6bn-1704757326243"></a>·容错设计:使用容错设计，确保系统在部分节点或服务失效时能够继续提供服务。

<a name="ilyo-1704756820772"></a>**8.监控和性能调优**

<a name="kpwq-1704757064566"></a>**.实时监控**

<a name="shf4-1704757066453"></a>**.性能测试**

·实时监控:使用监控系统实时监测系统性能，对系统进行及时调整。

<a name="lkos-1704757433031"></a>性能测试:定期进行性能测试，模拟高并发情况，找出系统的瓶颈并进行优化。

<a name="2pry-1704756830245"></a>**9.安全性设计**

<a name="pkiw-1704757078583"></a>**.防御性编程**

<a name="g4l1-1704757084924"></a>**.访问控制**

·防御性编程:编写安全的代码，防范SQL注入、XSS攻击等。

<a name="g9ef-1704757459182"></a>·访问控制:对系统的访问进行严格控制，避免未经授权的访问。

<a name="1tsd-1704756838192"></a>**10.水平扩展**

<a name="r1dd-1704757092061"></a>**.自动化部署**

<a name="7mhk-1704757104117"></a>**.云服务**

·自动化扩展:设计自动化扩展机制，根据系统负载自动增减节点。

<a name="g3qv-1704757477668"></a>·云服务:使用云服务提供商的弹性计算能力，根据需求调整计算资源。

<a name="rpxb-1677787447005"></a>**高并发性能指标**

<a name="klnv-1704761369323"></a>**QPS(每秒请求)**

<a name="zvlz-1704761369324"></a>**TPS(每秒事务)**

<a name="gvrn-1704761369325"></a>**RT(响应时间)**

我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。

公式：( 总PV数 \* 80% ) / ( 每天秒数 \* 20% ) = 峰值时间每秒请求数(QPS)

机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器

1、每天300w PV(网页浏览量) 的在单台机器上，这台机器需要多少QPS？ 

( 3000000 \* 0.8 ) / (86400 \* 0.2 ) = 139 (QPS)

2、如果一台机器的QPS是58，需要几台机器（cpu瓶颈）来支持？ ---得分析性能瓶颈，例如是CPU还是数据库。

<a name="02ut-1704761377369"></a>139 / 58 = 3 

<a name="ozkt-1704761368259"></a>**===系统架构设计师===**

<a name="mpwu-1704949756608"></a>**系统工程与信息系统基础**

<a name="2gzz-1704980837071"></a>**.系统工程方法**

|<a name="ufly-1704951943937"></a>系统工程方法|<a name="nxus-1704951943940"></a>关键点|
| :- | :- |
|<p><a name="1laj-1704951943944"></a>霍尔三维结构</p><p><a name="sxj8-1704951943946"></a>“硬科学”方法论</p>|<p><a name="lfis-1704951943949"></a>逻辑维:逻辑维即解决问题的逻辑过程。</p><p><a name="mbik-1704951943951"></a>时间维:时间维即是工作进程。</p><p><a name="6eif-1704951943953"></a>知识维:知识维即是专业科学知识。</p><p><a name="ujck-1704951943955"></a>应用场景:组织和管理大型工程建设项目</p>|
|<p><a name="jrym-1704951943959"></a>切克兰德方法</p><p><a name="q8lv-1704951943961"></a>“软科学”方法论</p>|<p><a name="iypv-1704951943964"></a>核心不是“最优化”，而是“比较”和“探寻”</p><p><a name="ovv5-1704951943966"></a>7步骤:认识问题、根底定义、建立概念模型、比较及探寻、选择、设计与实│</p><p><a name="nbrk-1704951943968"></a>施、评估与反馈</p>|
|<a name="klwq-1704951943972"></a>并行工程方法|<p><a name="lys5-1704951943975"></a>“制造过程”与“支持过程”并行</p><p><a name="fst8-1704951943977"></a>强调三个方面:产品设计开发期间，最快速度按质完成;各项工作问题协调解决;适当的信息系统工具。</p>|
|<a name="prt1-1704951943981"></a>综合集成法|<p><a name="khme-1704951943984"></a>钱学森命名【简单系统】和【巨系统】</p><p><a name="t5z1-1704951943986"></a>四原则:整体论原则、相互联系原则、有序性原则、动态原则</p>|
|<a name="6lvr-1704951943990"></a>wSR系统方法|<a name="1mrj-1704951943993"></a>实践准则:【懂物理】–【明事理】–【通人理】|

<a name="yvug-1704980841473"></a>时间维

1、规划阶段 调研，谋求活动的规划与战略    2、拟定方案    提出具体的计划方案    3、研制阶段 完成研制方案及生产计划      

4、生产阶段生    产零部件及提出安装计划    5、安装阶段 安装完毕，完成系统的运行计划    6、运行阶段    系统按照预期的用途开展服务

7、更新阶段    改进原有系统、或消亡原有系统

逻辑维    

1、明确问题    2、确定目标    建立价值体系或评价体系    3、系统综合    4、系统分析    

<a name="bf7c-1704980841472"></a>5、优化    系统方案的优化选择    6、系统决策    7、实施计划

<a name="mk93-1704952875199"></a>**.系统工程生命周期阶段**

系统工程生命周期阶段

<a name="lrmz-1704980944545"></a>探索性研究>概念阶段>开发阶段>生产阶段>使用阶段（5年）>保障阶段>退役阶段

<a name="ny2c-1704952893636"></a>**.系统工程生命周期方法**

系统工程生命周期方法

计划驱动方法:需求->设计->构建->测试->部署  ---瀑布模型

渐进迭代式开发:提供连续交付以达到期望的系统

精益开发:起源于丰田，是一个动态的、知识驱动的，以客户为中心的过程

<a name="0u7n-1704980953163"></a>敏捷开发:更好的灵活性

<a name="shmt-1704952904062"></a>**.信息系统建设原则**

信息系统建设原则

高层管理人员介入原则    如:CIO介入

用户参与开发原则    用户确定范围、核心用户全程参与、用户深度参与

自顶向下规划原则    以此减少信息不一致的现象

工程化原则    引入【软件工程】

<a name="wtaj-1704951817591"></a>其它原则    创新性原则、整体性原则、发展性原则、经济性原则

<a name="itje-1704951812273"></a>**.信息系统开发方法**

<a name="bnzq-1705819374009"></a>**原型法**

<a name="ujj3-1705819377863"></a>**结构化法-瀑布型**

<a name="8wek-1705819398251"></a>**形式化法-数模**

<a name="jeuk-1705819392097"></a>**敏捷方法**

原型法【需求阶段】  

按功能分：水平原型（界面） 垂直原型（复杂算法-抖音视频推送）

按最终结果分：抛弃式原型       演化式原型

结构化法：面向过程-瀑布型-自顶向下

面相对象方法：抽象-自底向上

面相服务方法： 粗粒度、松耦合、标准化和构件化

其他信息系统开发方式

形式化方法： 数学模型化  飞机，芯片等物理 模型化模拟

统一过程方法【up】

敏捷方法：scrum

<a name="kf2a-1704980979092"></a>基于架构的开发方法：ABSD

<a name="w8yd-1704980881013"></a>**.信息系统分类**

<a name="hlhq-1705819204285"></a>**业务处理系统TPS**

<a name="oksn-1705819204735"></a>**管理信息系统MIS**

<a name="lwm7-1705819204736"></a>**决策支持系统DSS**

<a name="bmeu-1705819204737"></a>**专家系统ES**

<a name="kffq-1705819204738"></a>**办公自动化系统OAS**

<a name="k2px-1705819204739"></a>**企业资源系统ERP**

业务处理系统TPS： OLTP、数据库、报表  -批处理数据

管理信息系统MIS：高度集成化的人机系统    -信息源、信息处理器、信息用户、信息处理者 donphi、pascal

【管理信息系统(Manage lnformation System,MIS)】是由业务处理系统发展而成的，

是在TPS基础上引进大量管理方法对企业整体信息进行处理，并利用信息进行预测、控制、计划、辅助企业全面管理的信息系统。

MIS系统四大部件:信息源、信息处理器、信息用户和信息管理者。十

决策支持系统DSS：语言系统，知识系统和问题处理系统组成，辅助决策

[DSS应具有的特征】

(1)数据和模型是DSS的主要资源。

(2)DSS用来支援用户作决策而不是代替用户作决策。

(3)DSS主要用于解决半结构化及非结构化问题。

(4)DSS的作用在于提高决策的有效性而不是提高决策的效率。

专家系统ES: 知识+推理 。人工智能的一个重要分支

知识库:存储求解实际问题的领域知识。

综合数据库∶存储问题的状态描述、中间结果、求解过程的记录等信息。

推理机:实质是【规则解释器】。

知识获取:两方面功能:知识的编辑求精及知识自学习。

解释程序:面向用户服务的。

办公自动化系统OAS: 

<a name="ct61-1704982049404"></a>企业资源系统ERP: 供应链

<a name="f98t-1704981918920"></a>**过程模型**

<a name="yk4j-1705841608124"></a>**瀑布模型**

严格区分阶段，每个阶段因果关系紧密相连

只适合需求明确的项目

缺点： 

软件需求完整性、正确性难确定

严格串行化，很长时间才能看到结果

<a name="3qne-1705842709255"></a>瀑布模型要求每个阶段一次性完全解决该阶段工作,这不现实。

<a name="oryp-1705841608705"></a>**V模型【瀑布变种-测试贯穿】**

测试贯穿于始终

测试分阶段(测试计划提前

<a name="p0k5-1705846375566"></a>编码后开始测试倒V成V字

<a name="b0cp-1705841621350"></a>**原型模型**

适合需求不明确的项目原型模型两个阶段:

1、原型开发阶段

2、目标软件开发阶段

<a name="cqhh-1705845876255"></a>[抛弃型原型)与【演化型原型】

<a name="sfqi-1705841608707"></a>**螺旋模型【原型+瀑布 风险】**

迭代型与增量型

以快速原型为基础+瀑布模型

<a name="b7wi-1705846464151"></a>考虑了风险问题

<a name="kbjw-1705841608709"></a>**构件组装模型/基于构件的开发方法**

【优点】易扩展、易重用、降低成本、安排任务更灵活。

【缺点】构件设计要求经验丰富的架构师、设计不好的构件难重用、强调重用可能牺牲其它指标(如性能)、第三方构件质量难控制。

【示例】

方舱医院

乐高积木

基于构件的软件工程(CBSE)

CBSE体现了【购买而不是重新构造】的哲学。

(CBSE的构件应该具备的特征】

1、可组装性:所有外部交互必须通过公开定义的接口进行。

2、可部署性:构件总是二进制形式的，能作为一个独立实体在平台上运行。

3、文档化:用户根据文档来判断构件是否满足需求。

4、独立性:可以在无其他特殊构件的情况下进行组装和部署。5、标准化:符合某种标准化的构件模型。

【构件的组装】

1、顺序组装:按顺序调用己经存在的构件，可以用两个已经存在的构件来创造一个新的构件。

2、层次组装:被调用构件的“提供”接口必须和调用构件的“请求”接口兼容。

<a name="zjcw-1705846978074"></a>3、叠加组装:多个构件合并形成新构件，新构件整合原构件的功能，对外提供新的接口。

<a name="mvze-1705841627436"></a>**快速应用开发RAD【瀑布+构件组装】**

业务建模

数据建模

过程建模

应用生成

<a name="nafe-1705930248825"></a>测试与交付

<a name="xici-1705841629815"></a>**统一过程/统一开发方法**

9个核心工作流：

业务建模

需求分析与设计

实现测试部署

配置与变更管理

项目管理

<a name="rsee-1705931291257"></a>环境

<a name="9jca-1705841608711"></a>**敏捷开发方法**

敏捷宣言

√个体和交互胜过过程和工具

√可工作的软件胜过大量的文档

√客户合作胜过合同谈判

√响应变化胜过遵循计划

传统软件开发方法: 预设性的 > 以开发过程为本 > 整体分阶段

<a name="flva-1705938097079"></a>敏捷方法: 适应性的 - 以人为本 - 增量迭代，小步快跑 - 适合小型项目

<a name="28va-1705841590197"></a>**XP**

敏捷方法- XP

4大价值观

沟通【加强面对面沟通】

简单【不过度设计】

反馈【及时反馈】

勇气【接受变更的勇气】

12条过程实践规则:

简单设计 测试驱动 代码重构 结对编程 持续集成 现场客户

发行版本 小型化 系统隐喻 代码集体所有 制规划策略 规范代码

<a name="mbtp-1705938236342"></a>40小时工作机制

<a name="fyfq-1705938223773"></a>**Scrum**

.极限编程\_(XP)∶价值观【交流、朴素、反馈、勇气】、近螺旋式的开发方法。

.水晶方法:提倡“机动性”的方法，拥有对不同类型项目非常有效的敏捷过程。

.SCRUM:侧重于项目管理。

.特征驱动开发方法（FDD)∶认为有效的软件开发需要3要素【人、过程、技术】。

.定义了6种关键的项目角色:项目经理、首席架构设计师、开发经理、主程序员、程序员和领域专家。

.开放式源码:程序开发人员在地域上分布很广【其他方法强调集中办公】。

.ASD方法:其核心是三个非线性的、重叠的开发阶段:猜测合作与学习。

<a name="elzb-1705938420182"></a>.动态系统开发方法(DSDM)︰倡导以业务为核心。

<a name="d5ko-1705938215067"></a>**逆向工程**

现有工程 - 再工程  -新系统   

逆向工程是设计的恢复过程。

\------

实现级:包括程序的抽象语法树、符号表、过程的设计表示

结构级:包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构

功能级:包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型

领域级∶包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型

与逆向工程相关的概念有重构、设计恢复、再工程和正向工程。

(1）重构/重组(Restructuring)。重构是指在【同一抽象级别】上【转换系统描述形式】。

(2）设计恢复(Design recovery)。设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。

(3)逆向工程(Reverse engineering):逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程。

(4）正向工程（Forward engineering)。正向工程是指不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，以改善其整体质量。

<a name="efxo-1705938813039"></a>(5）再工程/重构工程(Re-engineering)。再工程是对现有系统的重新开发过程，包括逆向工程、新需求的考虑过程和正向工程三个步骤。

<a name="tybd-1705938215235"></a>**净室软件工程**

√净室即无尘室、洁净室。也就是一个受控污染级别的环境。

√使用盒结构规约（或形式化方法)进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制。

√使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息。

-- 举例前端的 拖拽式功能框

【技术手段】

√统计过程控制下的增量式开发:控制迭代

√基于函数的规范和设计:盒子结构

`    `定义3种抽象层次:行为视图(黑盒)->有限状态机视图（状态盒)->过程视图（明盒/白盒)

√正确性验证:净室工程的核心

√统计测试和软件认证:使用统计学原理，总体太大时必须采用抽样方法

【缺点】

√太理论化，正确性验证的步骤比较困难且耗时。

√开发小组不进行传统的模块测试，这是不现实的。

<a name="iesl-1705939167964"></a>√脱胎于传统软件工程，不可避免带有传统软件工程的一些弊端。

<a name="ochn-1705940085547"></a>**需求工程**

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。  -需求开发

【需求工程主要活动的阶段划分】

需求获取

需求分析

形成需求规格【形成SRS】

需求确认与验证【形成需求基线(经过评审的SRS)】

需求管理【变更控制、版本控制、需求跟踪、需求状态跟踪】

<a name="nlvu-1705940085546"></a>需求管理是对【需求基线】进行管理

<a name="xdlf-1705940054108"></a>**.需求获取**

软件需求获取方法

用户面谈 - 需求专题讨论会(JRP) - 问卷调查 - 现场观察 - 原型化方法 - 头脑风暴法

分层

√业务需求()整体全局)

√用户需求用户视角

√系统需求(计算机化)   -功能需求  -性能需求(非功能)  -设计约束

项目管理维度QFD

√基本需求(明示，常规需求)

√期望需求（隐含)

√兴奋需求(多余)

`    `方法                                    特点

用户面谈                1对1-3，有代表性的用户，了解主观想法，交互好。成本高，要有领域知识支撑。

联合需求计划(JRP)        高度组织的群体会议，各方参与，了解想法，消除分歧，交互好，成本高。

问卷调查                用户多，无法一一访谈，成本低。

现场观察                针对较为复杂的流程和操作。

原型化方法               通过简易系统方式解决早期需求不确定问题。

<a name="jvim-1705940257086"></a>头脑风暴法               一群人围绕新业务，发散思维,不产生新的观点。

<a name="axny-1705940052332"></a>**.需求分析**

需求工程-需求开发-需求分析- SA(DFD)

数据字典 数据元素-数据结构-数据流-数据存储-加工逻辑-外部实体

功能模型(数据流图DFD):数据流-加工-数据存储-外部实体

行为模型(状态转换图)：  状态(初态、终态)-事件

<a name="ovab-1705940661004"></a>实体模型(E-R图):  实体-联系

<a name="loq2-1705940640473"></a><a name="l03x-1705940634470"></a>**===数据密集型应用===**

<a name="ef5t-1644230945318"></a>数据系统基础

<a name="unbe-1677787447006"></a>**设计数据密集型应用**

<a name="kwfx-1677787447007"></a>**1.可靠性、可拓展性、可维护性能**

<a name="zrzj-1642646974315"></a>小结：一个应用必须满足各种需求才称得上有用

<a name="lykw-1644227240038"></a>**-功能性需求：CRUD**

<a name="b2tu-1644227249556"></a>**-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性**

<a name="qqm5-1644227303238"></a>**.可靠性：**

<a name="vdpc-1699843965882"></a>以为着即使发生故障，系统也能正常工作。

<a name="mk9e-1644227360160"></a>故障可能发生在硬件（通常是随机和不相关的）

<a name="w7by-1644227387308"></a>软件（通常是系统性的bug,很难处理）

<a name="dozl-1644227415061"></a>人类（不可避免的时不时出错）

<a name="fvz4-1644227444254"></a>**容错技术**可以对终端用户隐藏某些类型的故障。

<a name="7xms-1644228225080"></a>**.可扩展性：** 

<a name="t59j-1699843967201"></a>意味着即使在增加负载的情况下也能保持性能的策略。

<a name="gqfn-1644228379215"></a>为了讨论可拓展性，首先要定量描述负载和性能的方法。

<a name="krij-1644228405843"></a>推特主页时间线的例子，介绍描述负载参数，并将响应时间百分点作为衡量性能的一种方式。头部阻塞、尾部延迟。(有很多人通过将工作负载迁移到低延迟、自适应的GC来控制尾部延迟-infoQ java趋势)

<a name="bynr-1644228470161"></a>在可扩展的系统中可以添加**处理容量** 以在高负载下保持可靠。

<a name="elzq-1644228563046"></a>**.可维护性：**   

<a name="vg1v-1699843968229"></a>可维护性实质上是关于工程师和运维团队生活质量的。

<a name="mq1x-1644231096441"></a>良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。

<a name="qj5f-1644228656997"></a>良好的可操作性意味这对系统的健康状态具有良好的可见性，并拥有有效的管理手段。

<a name="gwsd-1644231020558"></a><a name="jufm-1677787447008"></a>**2.数据模型与查询语言**

<a name="guby-1644404619396"></a>本章小结：数据模型时一个巨大的课题，在本章中，我们快速浏览了各种不同的模型。以便激起兴趣，更多的了解**最适合你的应用的需求模型**。（数据库选型）

<a name="o6we-1644404838474"></a>在历史上，**数据最开始被表示为一颗大树（层次型结构**），但是这不利于表示多对多的关系，所以发明了

<a name="pgu6-1699844351041"></a>**-关系模型**

<a name="jayo-1699844352979"></a>来解决这个问题。

<a name="kfpd-1644410618294"></a>**-NoSql (es,redis)**

<a name="uzbw-1699844301003"></a>**通常**不会为存储的数据强制一个模式，这可以使应用程序更容易适应不断变化的需求。

<a name="0p23-1644410807294"></a>**1.文档数据库：**

<a name="9rlb-1699844336493"></a>数据通常是自我包含的，而且文档之间的关系非常稀少

<a name="09bl-1644410666587"></a>  **2.图形数据库 ：**

<a name="imif-1699844337670"></a>与文档数据库相反的场景-任意事务都可能与任何事务相关联

<a name="6fxw-1644410924417"></a>**-其它模型(基因序列)**

<a name="he0m-1699844309707"></a>** 基因组 通常需要 **序列相似性搜索，意味着一**个很长的字符串，并在一个拥有类似但不完全相同的字符串的大型数据库中寻找匹配。这里所描述的数据库都不能处理这种用法。研究人员编写了想GenBank专门的基因组数据库软件。

<a name="opsf-1644411138194"></a>                 粒子物理学家进行大数据类型的大规模数据分析。粒子对撞机（LHC）这样的项目可以工作在数百亿兆字节的范围内。这样的规模下，需要指定解决方案来阻止硬件成本的失控。

<a name="pnul-1644935322505"></a><a name="sm0u-1677787447009"></a>**3.存储与检索**

<a name="ycte-1644935336049"></a>本章小结：数据库如何处理存储何检索。将数据存储在数据库中会发生什么，再次查询数据库会发生什么？

<a name="bivs-1644935398311"></a>在高层次上，存储引擎分两大类：

<a name="bhcv-1644935436804"></a>**-优化事务处理（OLTP）transaction** 

<a name="tbhw-1699844517372"></a>**1.OLTP系统通常面向用户，大量的请求。**

<a name="fnev-1644935714127"></a>**2.磁盘寻道时间往往是这里的瓶颈。**

<a name="cjwp-1644935609899"></a>**3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。**

<a name="jg7s-1699844443567"></a>**-优化分析（OLAP）analys**

<a name="n8me-1644935726822"></a>    OLTP数据 copy and translatin 转换为适合业务分析的数据副本 to 数据仓库（OLAP）

<a name="3cwp-1644935731444"></a>OLAP**数据仓库**和类似的分析系统不太知名，因为只要由业务分析人员使用，而不是由最终用户使用

<a name="s6pt-1644935799372"></a>处理比OLTP系统少得多得查询量，但是每个查询通常要求很高，短时间内扫描百万条记录。

<a name="cyhe-1644935862917"></a>磁盘带宽（不是查找时间）往往是瓶颈，列式存储是这种工作负载的流行解决方案。

<a name="pjd1-1703887811615"></a>**1.列式储存(投影操作，压缩技术，聚合过滤)**

OLAP TB,PB级别的数据(几百列)情况下，索引的相关性就会下降很多，磁盘带宽往往是瓶颈

解决方案-列式存储

1\.将表头设置为列文件名，文件存储单列内容、

2\.如需第23行，则将需要的列文件的第23项形成表的第23行

优势：

.投影操作：仅需检索所需的列，大大减少读取的数据量。

.压缩技术：通常采取高度优化的压缩技术。-相邻的数据通常具有相似的值。减少存储空间，提高查询性能

.向量化处理：通常采用向量化处理，意味着可以一次操作整个数据向量，而不是逐个处理行。-并行处理和SIMD指令集优化非常有利

.聚合操作：在SUM、AVG等聚合操作上表现良好

.过滤操作：特定列过滤更快

.分析查询：部分查询而不是全部

<a name="kg2a-1703885936042"></a>Apache: Cassandra、 HBase

<a name="8sgm-1644935924013"></a>**-OLTP两大主流学派的存储引擎：**

<a name="i55y-1644935943748"></a>**1.日志结构学派**

<a name="4nm8-1644935988277"></a>只允许附加到文件和删除过时文件，但不会更新已经写入的文件。（高效，顺序IO?）

<a name="6ymo-1644936029696"></a>Bitcask, SSTables, LSM树，LevelDB, Cassandra, HBase, Lucene等都属于这个组。

<a name="h3il-1644935977285"></a>**2.就地更新学派**

<a name="2w0c-1644936091115"></a>将磁盘视为一组可以覆盖的固定大小页面。（随机IO?）

<a name="hpzs-1644936142472"></a>B树是这种哲学的最大例子，被用在所有主要的关系数据库中，还有许多非关系数据库。

<a name="fil5-1644936170765"></a><a name="vypn-1644936170925"></a>日志结构的存储引擎是相对较新的发展，他们的主要想法是，系统地将随机访问写入顺序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短的介绍。

<a name="a5tj-1644936526197"></a>然后我们从存储引擎的内部绕开，看看典型的数据仓库的高级架构。这一背景说明了为什么分析工作负载和OLTP差别很大：

<a name="nyml-1644936619727"></a>当您的查询需要在大量（几百列）的行中顺序扫描时，索引的相关性就会下降很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读取的数据量。我们讨论了列式存储如何帮助实现这一目标。

<a name="2akd-1644935679338"></a>作为一名应用开发人员，如果您掌握了有关存储引擎内部知识，那么就能更好地那种工具最适合您的特定应用程序。如果需要调整库的参数，这种理解可以让您设想一个更高或者更低的参数可能会产生什么效果。

<a name="ohao-1644936963029"></a>尽管本章不能让你成为一个特定存储引擎的调参专拣，但它至少有大概率使你有了足够的概念与词汇储备去读懂数据库的文档，从而选择合适的数据库。

<a name="en4q-1644936942676"></a><a name="lbs1-1677787447010"></a>**4.编码（序列化）与演化(XML,JSON,CSV)**

<a name="18rw-1644940257792"></a>在本章中，我们研究了将数据结构转换为网络中的字节或磁盘上的字节的几种方法。编码的细节影响其效率，更重要的是应用程序的体系结构和部署它们的选项。

<a name="bfvx-1644940365841"></a>特别是，许多服务需要支持滚动升级（灰度发布），其中新版本的服务逐步部署到少数节点，而不是同时部署到所有节点。滚动升级允许在不停机的情况下发布新版本的服务（从而鼓励在罕见的大型版本上频繁发布小型版本），并使部署风险降低（允许在影响大量用户之前检测并回滚有故障的版本）。这些属性对于可演化性，以及对应用程序进行更改的容易性都是非常有利的。

<a name="w4qv-1644940598057"></a>在滚动升级期间，或出于其它原因，我们必须假设不同的节点正在运行我们的应用程序代码的不同版本。因此，在系统周围流动的所有数据都是以提供向后兼容性（新代码可以读取旧数据-服务端）和向前兼容性（旧代码可以读取新数据-客户端）的方式进行编码是重要的。我们讨论了几种数据编码格式极其兼容性：

<a name="zw4l-1644940805237"></a>编程语言特定编码仅限于单一编程语言，并且往往无法提供向前和向后兼容性。

<a name="1zx9-1644940881501"></a>JSON, XML和CSV等文本格式非常普遍，其兼容性取决于如何使用它们。他们有可选模式语言，这有时是有用的，有时是一个障碍。这些数据格式对于数据类型有些模糊，所以你必须小心数字和二进制字符串。

<a name="q8m7-1644942050475"></a>像Thrift, Protocol Buffers和Avro这样的二进制模式驱动格式允许使用清晰定义的向前和向后兼容性语义进行紧凑，搞笑的编码。这些模式可以用于静态类型语言的文档和代码生成。但是，他们有一个去缺点，就是在数据可读之前需要对数据进行解码。

<a name="hqvm-1644942192088"></a>我们还讨论了几种数据流的几种模式，说明了数据编码是重要的不同场景：

<a name="c94y-1644942236778"></a>数据库，写入数据库的进程对数据进行编码，并从数据库读取进程对其进行解码

<a name="kcmv-1644942289426"></a>RPC 和 REST API, 客户端对请求进行编码，服务器对请求进行解码并对相应进行编码，客户端最终对相应进行解码。

<a name="nvcq-1644942366178"></a>异步消息传递（使用消息代理或参与者），其中节点之间通过发送消息进行通信，消息由发送者编码并由接收者解码。

<a name="oxsf-1644942481249"></a>我们可以小心地得出这样的结论：向前兼容性和滚动升级在某种成都上是可以实现的。愿您的应用程序的演变迅速，敏捷部署。

<a name="rmsh-1646310193756"></a><a name="d4ge-1677787447011"></a>**分布式系统**

<a name="4p9n-1677787447012"></a>**4.分布式数据**

<a name="gr0m-1646310278506"></a>本章考察了复制的问题，复制可以用于几个目的：

<a name="o4ag-1646310813851"></a>**1.高可用性**

<a name="r7ua-1646310833943"></a>即使在一台机器（或多台机器，或整个数据中心）停机的情况下也能保持系统正常运行

<a name="snwm-1646310894841"></a>**2.断开连接的操作**

<a name="x2dq-1646310900787"></a>允许应用程序在网络中断时继续工作

<a name="evly-1646310918322"></a>**3.减少延迟(节点近)**

<a name="iz8f-1646310928916"></a>将数据放置在距离用户较近的地方，以便用户能够更快地与其交互

<a name="itsh-1646310968967"></a>**4.可拓展性**

<a name="ncek-1646310974776"></a>能够处理比单个机器更高的读取量可以通过对副本进行读取来处理

<a name="ybmg-1646311013702"></a><a name="a6ti-1646311014184"></a>尽管是一个简单的目标-在几台机器上保留相同数据的副本，但复制确实一个非常棘手的一个问题。它需要仔细考虑并发和所有可能出错的事情，并处理这些故障的后果。

<a name="cpjg-1646311086181"></a>至少，我们需要处理不可用的节点和网络中断（甚至不考虑更隐蔽的故障，例如由软件错误导致的无提示数据损坏）。

<a name="gbgq-1646311175182"></a>**-复制的三种主要方法：**

<a name="wg6v-1646311185918"></a>**1.单主复制**

<a name="ehug-1646311426407"></a>客户端将所有写入操作发送到单个节点（领导者），该结点将数据更改事件流发送到其它副本（追随者）。

<a name="wgge-1646311567456"></a>读取可以再任何副本中执行，但从追随者读取可能是陈旧的 （最终一致性问题）

<a name="ftqb-1646311200843"></a>**2.多主复制**

<a name="ak8v-1646311613462"></a>客户端发送每个写入到几个领导节点之一，其中任何一个都可以接受写入。领导者将数据更改事件流发送给彼此以及任何跟随着节点。

<a name="4xbf-1646311410600"></a>**3.无主复制**

<a name="b6zn-1646311685371"></a>客户端发送每个写入到几个节点，并从多个节点并行多去，以检测和纠正具有陈旧数据的节点。

<a name="tyus-1646311850435"></a><a name="dzsw-1646311850942"></a>单主复制是非常流行的。多领导和无领导复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。

<a name="sgmj-1646311002454"></a>我们讨论了一些有助于决定应用程序在复制滞后时的行为的

<a name="nlnz-1699845075606"></a>**-一致性模型：**

<a name="anqq-1646312272172"></a>**1.写后读**

<a name="jvwc-1646312310729"></a>用户应该总是看到自己提交的数据。

<a name="hedn-1646312288296"></a>**2.单调读**

<a name="wxgc-1646312331720"></a>用户在一个时间点看到数据后，他们不应该在某个早期时间点看到数据

<a name="fizh-1646312291911"></a>**3.一致前缀读**

<a name="5okd-1646312382954"></a>用户应该将数据视为具有因果意义的状态：例如，按照正确的顺序查看问题及其答复

<a name="drau-1646310922027"></a><a name="eumz-1646312681469"></a>多领导者和无领导者复制方法所固有的并发问题：允许多个写入并发发生冲突。研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者他们是否同时发生。

<a name="xukg-1646312787143"></a>还谈到了通过合并并发更新来解决冲突的方法。

<a name="cbey-1646310922523"></a><a name="j5o0-1704983008475"></a>**7.事务**

<a name="du4g-1704983767151"></a>**.简化故障失败的机制**

<a name="rfev-1704983016027"></a>数据库软件、硬件可能在任意时刻发⽣故障（包括写操作进⾏到⼀半时）。

<a name="hfad-1704983671342"></a>应⽤程序可能在任意时刻崩溃（包括⼀系列操作的中间）。

<a name="3lnd-1704983671344"></a>⽹络中断可能会意外切断数据库与应⽤的连接，或数据库之间的连接。

<a name="av8h-1704983671346"></a>多个客户端可能会同时写⼊数据库，覆盖彼此的更改。

<a name="emwl-1704983671348"></a>客户端可能读取到⽆意义的数据，因为数据只更新了⼀部分。

<a name="nhvj-1704983671350"></a>客户之间的竞争条件可能导致令⼈惊讶的错误。

<a name="5xk9-1646310922755"></a><a name="vo8p-1704983742288"></a>**事务（transaction）** ⼀直是简化这些问题的⾸选机制。整个事务要么成功（**提交（commit）**）要么失败（**中⽌（abort）**，**回滚（rollback）**）

<a name="pnng-1646310922957"></a>**简化应⽤编程模型  安全保证（safety guarantees）**

<a name="lyog-1646310871301"></a>深⼊**并发控制**的领域   如何实现**读已提交**，**快照隔离**和**可串⾏化**等隔离级别

<a name="k9de-1704984009883"></a>**.事务的棘手问题**

<a name="65nh-1704984028565"></a>**原⼦性（Atomicity）**

<a name="cfkv-1704984213641"></a>**能够在错误时中⽌事务，丢弃该事务进⾏的所有写⼊变更的能⼒。** 或许 **可中⽌性（abortability）是更好的术语**

<a name="6b47-1705118743952"></a>**要么全部成功，要么全部失败，简化系统复杂度， 避免“部分成功失败”等中间态复杂逻辑的修正。**

<a name="qeub-1646310871673"></a>**⼀致性（Consistency）**

<a name="nj8u-1704984284264"></a>**对数据的⼀组特定陈述必须始终成⽴**。即**不变量（invariants）**

<a name="rpju-1646310871817"></a>**隔离性（Isolation）**

<a name="wbo9-1704984301328"></a>**同时执⾏的事务是相互隔离的，快照隔离（snapshot isolation）** 的功能，**这是⼀种⽐可序列化更弱的保证**【8,11】-MVCC

<a name="aq1q-1646310872064"></a>**持久性（Durability）**

<a name="ix2r-1704984436018"></a>硬件故障或数据库崩溃，写⼊的任何数据也不会丢失。

<a name="sesd-1646310817481"></a><a name="yi8z-1704985578742"></a>参考mysql的事务、MVCC及锁

<a name="rlxa-1705080720222"></a>**弱隔离级别**：读已提交，可重复读，序列化

<a name="2jhg-1705080777447"></a>并行事务非阻塞态，MVCC快照读

<a name="avnt-1705080821368"></a>比较并设置(CAS)

<a name="enui-1704985776096"></a>**分布式系统的麻烦**

<a name="rp9s-1705080859004"></a>**一致性共识**

<a name="ssaq-1705080889744"></a> CAP理论-参考微服务架构篇章

<a name="cys8-1705080619829"></a>**分布式事务**

<a name="bjec-1705081008345"></a>**2PC提交**

<a name="vaax-1705118249954"></a>coodinator协调子事务，子事务单独执行完，在准备阶段询问是否可提交

<a name="7zwc-1705118288968"></a>.全部为是，则分别提交。

<a name="3b8s-1705118337513"></a>.其中有否，则中断回滚。

<a name="dyd0-1705118358884"></a>**3PC提交**

<a name="stoe-1705118368214"></a>在提交阶段，如果子事务进程crash,或者协调者崩溃的时的解决方案，弱原子性，最终一致性。

<a name="nlrk-1705118500709"></a>许多coodinator不支持高可用或者只支持基本的复制

<a name="pudp-1705080909535"></a>**实践中的分布式事务**

<a name="hu69-1705081074207"></a>**数据库内部的分布式事务**

<a name="jhqw-1705080950920"></a>VoltDB 与mysql Cluster 的NDB引擎就有这样的内部事务支持。

<a name="mzcr-1705118236321"></a><a name="ozc0-1705080997483"></a>**XA事务(扩展架构（eXtended Architecture)**

<a name="ngse-1705081186469"></a>跨异构技术实现两阶段提交的标准，：许多传统关系数据库（包括PostgreSQL，MySQL，DB2，SQL Server和Oracle）和消息代理（包括ActiveMQ，HornetQ，MSMQ和IBM MQ）都⽀持XA。

<a name="otul-1705081462777"></a>XA事务是使⽤**Java事务API（**JTA, Java Transaction API）实现的，⽽许

<a name="wfx9-1705081463074"></a>多使⽤Java数据库连接（**JDBC**, Java Database Connectivity）的数据库驱动，以及许多使⽤Java消息服务（JMS）API的消息代理**都⽀持Java事务API**（JTA）。

<a name="0dfj-1705081511181"></a>Spring事务基于JDBC事务。

<a name="ssso-1705081563263"></a>**怀疑时持有锁**

<a name="rehq-1705081588086"></a>读已提交，数据库事务通常获取待修改的⾏上的⾏级排他锁，以防⽌脏写(值为NULL，事务A先写，事务B写后提交，A回滚，值变NULL)。

<a name="ue7i-1705118474108"></a>在协调者崩溃时，这些锁将会被coodinator永久持有，如果管理员不手动释放。


# 系统设计与优化&amp;DDIA :see_no_evil:
## 目录

<a name="3060-1621846615933"></a>**本书案例方案的感想：利用工程师思维，从问题的正反面入手，科学分析解决的过程。**

<a name="1tmg-1739985212503"></a>[一.数据库设计](#jeyl-1677787446995)

<a name="op1j-1739985212505"></a>[1. 关系型数据库](#5hya-1677787446996)

<a name="hcfo-1739985212507"></a>[.E-R图，由台湾工程师提出的设计概念](#ohc5-1621692571287)

<a name="er3e-1739985212509"></a>[.流程图-业务逻辑相关，系统用户动作。抽象出E-R图](#5ocb-1645598528868)

<a name="rbbk-1739985212511"></a>[1.1 E-R图 ](#gzqe-1677787446997)

<a name="t8pb-1739985212513"></a>[1.根据名词抽象出实体](#r1ac-1621692724628)

<a name="ycq8-1739985212515"></a>[2.名词找属性](#d2fl-1621692745600)

<a name="jqiu-1739985212517"></a>[3.实体间联系](#dwkp-1621692752824)

<a name="4vrh-1739985212519"></a>[.状态图](#53bo-1621692829033)

<a name="elss-1739985212521"></a>[1.2 转化成数据库设计（公式）](#c2cy-1677787446998)

<a name="6pho-1739985212523"></a>[.1 对1 关系 往记录少的乙方加主键](#xmox-1621692858500)

<a name="zq4j-1739985212525"></a>[.1对n 关系 ，往 n 实体加关联主键 ](#mdr8-1621692924289)

<a name="gzam-1739985212527"></a>[. n对 m 关系，需要一个关联表作映射关联](#hd3i-1621692960576)

<a name="g55r-1739985212529"></a>[2.数据类型选择](#szqu-1715100194538)

<a name="8r5n-1739985212531"></a>[整数类型（Integer Types）](#0rub-1715100184335)

<a name="py2z-1739985212533"></a>[浮点数类型（Floating-Point Types）](#j4ut-1715100184343)

<a name="se0v-1739985212535"></a>[日期和时间类型（Date and Time Types）](#fjm4-1715100184359)

<a name="msns-1739985212537"></a>[其他类型](#tofd-1715100184367)

<a name="ie70-1739985212539"></a>[3. 数据治理](#6bqw-1715100177239)

<a name="xkiw-1739985212541"></a>[二.系统优化](#cdso-1677787447000)

<a name="vakv-1739985212543"></a>[应用整体的优化](#3qep-1642647362896)

<a name="gvjc-1739985212545"></a>[-cpu -> 纳秒级别](#knge-1642647371136)

<a name="kjzh-1739985212547"></a>[1.多线程和并发编程](#ovup-1704437622969)

<a name="tqqe-1739985212549"></a>[2.JNI ](#ufpl-1704437634986)

<a name="qyjp-1739985212551"></a>[3.JIT/AOT编译](#ixb5-1704437634987)

<a name="0dra-1739985212553"></a>[4.算法优化](#kr1f-1704437634988)

<a name="d86b-1739985212555"></a>[-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)](#1xur-1642647384168)

<a name="9ogu-1739985212557"></a>[1.JVM内存管理](#7hi9-1704437851514)

<a name="y0cl-1739985212559"></a>[2.缓存](#te7c-1704437851799)

<a name="sva2-1739985212561"></a>[3.消息中间件](#bqty-1704437851800)

<a name="7eok-1739985212563"></a>[-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)](#ziti-1642647439005)

<a name="h448-1739985212565"></a>[1.减少磁盘io](#zups-1704437900079)

<a name="dwpl-1739985212567"></a>[2.数据压缩   ](#u3ok-1704438035018)

<a name="wfqr-1739985212569"></a>[-网络传输/系统交互 -> 秒级 (减少io，连接池化) ](#irbp-1642647458856)

<a name="z4ij-1739985212571"></a>[1.减少网络请求   ](#6qil-1704438276193)

<a name="kzgn-1739985212573"></a>[2.使用CDN](#p5dt-1704438283633)

<a name="epuj-1739985212575"></a>[3.Sockets异步通信                                      ](#zhp8-1704438283634)

<a name="ma0p-1739985212577"></a>[项目架构层面的优化](#3l0l-1704424353262)

<a name="sot1-1739985212579"></a>[-多级缓存](#8o8s-1704424396933)

<a name="vph9-1739985212581"></a>[-应用层](#trcg-1704438366333)

<a name="fmbh-1739985212583"></a>[.代码优化](#68oa-1704438530062)

<a name="r9jy-1739985212585"></a>[.数据库优化](#clmf-1704438530257)

<a name="snct-1739985212587"></a>[.日志优化](#md03-1704438530259)

<a name="j17b-1739985212589"></a>[-监控与调优](#ocux-1704438477879)

<a name="usei-1739985212591"></a>[.性能监控：](#vdq2-1704438556836)

<a name="4p4q-1739985212593"></a>[.分析和调优](#t29d-1704438557094)

<a name="b38b-1739985212595"></a>[-分布式系统架构](#ukjf-1704424419442)

<a name="dcn8-1739985212597"></a>[ .负载均衡](#a0bx-1704438677201)

<a name="hyao-1739985212599"></a>[.分布式缓存](#xn9x-1704438687994)

<a name="3fdv-1739985212601"></a>[.服务降级和容错](#zcdp-1704438687996)

<a name="vvwh-1739985212603"></a>[读写层面](#six7-1642647372926)

<a name="ht7j-1739985212605"></a>[.读优化](#g4uv-1704732583614)

<a name="4nb9-1739985212607"></a>[1.缓存](#uuzh-1704732602620)

<a name="hkgf-1739985212609"></a>[2.索引](#qobc-1704732605892)

<a name="cfnc-1739985212611"></a>[3.减少io/批量读/非阻塞io](#zlg9-1704732609048)

<a name="v1cj-1739985212613"></a>[4.减少多余数据加载/列式存储读](#fpjd-1704732631316)

<a name="oyu1-1739985212615"></a>[.写优化](#oyob-1704732598377)

<a name="r0gk-1739985212617"></a>[1.异步写](#6jmb-1704732509150)

<a name="e9ch-1739985212619"></a>[2.并发写](#tkwp-1704732723564)

<a name="ykgu-1739985212621"></a>[3.批量写](#hewz-1704732862030)

<a name="jpwq-1739985212623"></a>[4.优化算法和数据结构](#ccd8-1704732727854)

<a name="gfuz-1739985212625"></a>[5.缓存写](#eqd9-1704732736281)

<a name="uxyp-1739985212627"></a>[6.非阻塞io](#hyq8-1704732768916)

<a name="vavo-1739985212629"></a>[1.分控系统优化复盘](#tncv-1677787447001)

<a name="ab9m-1739985212631"></a>[1.1 数据库系统](#ydq7-1677787447002)

<a name="8oie-1739985212633"></a>[1.2 sql慢](#wxdd-1677787447003)

<a name="nqwr-1739985212635"></a>[1.3 接口慢](#olpb-1677787447004)

<a name="sd5e-1739985212637"></a>[2.简化应用复杂度](#hxbs-1739984957390)

<a name="d7pi-1739985212639"></a>[分布式BASE理论，最终一致，补偿对账机制。不强求强一致性引入复杂问题。](#fbky-1739984987936)

<a name="ibem-1739985212641"></a>[高并发系统设计](#wrwk-1642647280506)

<a name="hae9-1739985212643"></a>[1.满足大规模用户同时访问，提供良好响应时间和性能](#8ien-1704757782146)

<a name="pgg9-1739985212645"></a>[2.设计之初就要考虑伸缩性和容错性是非常重要的](#xy0g-1704757785190)

<a name="kydv-1739985212647"></a>[.垂直伸缩 ](#wr12-1704947861599)

<a name="k5u4-1739985212649"></a>[.水平伸缩](#bizh-1704947959744)

<a name="l2ek-1739985212651"></a>[1.分布式架构](#fvzi-1704756770858)

<a name="pfgh-1739985212653"></a>[.微服务架构](#ywzr-1704756872033)

<a name="l4xl-1739985212655"></a>[.分布式计算](#xgna-1704756877646)

<a name="fssm-1739985212657"></a>[2.负载均衡](#wnfy-1704756775272)

<a name="ycrp-1739985212659"></a>[.负载均衡](#h6nf-1704756891918)

<a name="uhur-1739985212661"></a>[.水平扩展](#c8zr-1704756894402)

<a name="ysfz-1739985212663"></a>[3.数据库设计](#wxjk-1704756782840)

<a name="alfl-1739985212665"></a>[.读写分离](#lxca-1704756910837)

<a name="yeox-1739985212667"></a>[.数据库分片](#p7d2-1704756922362)

<a name="pglu-1739985212669"></a>[.缓存](#hxjt-1704756963988)

<a name="znju-1739985212671"></a>[4.缓存优化](#iivs-1704756788012)

<a name="mdtf-1739985212673"></a>[.分布式缓存](#cvui-1704756971791)

<a name="ewdp-1739985212675"></a>[.本地缓存](#ysly-1704756979122)

<a name="kz8b-1739985212677"></a>[.缓存预热](#rqwj-1704756986363)

<a name="knbj-1739985212679"></a>[5.消息队列](#so9h-1704756800253)

<a name="fvcx-1739985212681"></a>[.异步处理](#sxlo-1704756996000)

<a name="hfcs-1739985212683"></a>[.削峰填谷](#llm2-1704757002994)

<a name="7gse-1739985212685"></a>[6.分布式事务](#n39o-1704756805232)

<a name="kj90-1739985212687"></a>[.两阶段提交](#5bhj-1704757017700)

<a name="hslc-1739985212689"></a>[.补偿事务](#becc-1704757028036)

<a name="rgws-1739985212691"></a>[7.高可用和容错](#wgkk-1704756813448)

<a name="smpj-1739985212693"></a>[.多地域部署](#akwz-1704757035393)

<a name="byfw-1739985212695"></a>[.设计容错](#3nxv-1704757055271)

<a name="oemh-1739985212697"></a>[1. 熔断限流](#g3xx-1704757371028)

<a name="pxig-1739985212699"></a>[2. 多节点服务](#jafy-1704757374368)

<a name="qxzl-1739985212701"></a>[8.监控和性能调优](#ilyo-1704756820772)

<a name="25la-1739985212703"></a>[.实时监控](#kpwq-1704757064566)

<a name="kqny-1739985212705"></a>[.性能测试](#shf4-1704757066453)

<a name="qvgu-1739985212707"></a>[9.安全性设计](#2pry-1704756830245)

<a name="cfhh-1739985212709"></a>[.防御性编程](#pkiw-1704757078583)

<a name="1aie-1739985212711"></a>[.访问控制](#g4l1-1704757084924)

<a name="dbmq-1739985212713"></a>[10.水平扩展](#1tsd-1704756838192)

<a name="bxci-1739985212715"></a>[.自动化部署](#r1dd-1704757092061)

<a name="ybpn-1739985212717"></a>[.云服务](#7mhk-1704757104117)

<a name="9mfq-1739985212719"></a>[高并发性能指标](#rpxb-1677787447005)

<a name="gmbh-1739985212721"></a>[QPS(每秒请求)](#klnv-1704761369323)

<a name="hmxa-1739985212723"></a>[TPS(每秒事务)](#zvlz-1704761369324)

<a name="vxfv-1739985212725"></a>[RT(响应时间)](#gvrn-1704761369325)

<a name="7fzw-1739985212727"></a>[(原子操作)并发编程中保证数据一致性/安全的方法](#ysmj-1709309531982)

<a name="jaml-1739985212729"></a>[原子性+悲观锁：各种锁机制](#fdxy-1709308630108)

<a name="6od1-1739985212731"></a>[.（事务+锁/ 分布式事务+分布式事务）](#v06l-1709312268021)

<a name="khue-1739985212733"></a>[.  CASmysql版本号实现 (前提是数据库的update已经是原子写：mysql update排它锁）](#k0op-1709312304164)

<a name="wb7a-1739985212735"></a>[原子性+乐观锁/不加锁: CAS原子操作(java原子类)，](#qth5-1709308703202)

<a name="plv7-1739985212737"></a>[CAS底层实现原理 (与数据库SSI类似，不加锁的序列化隔离)](#g3uo-1709309147469)

<a name="sf5h-1739985212739"></a>[总线锁定（Bus Locking）：](#qpbw-1709308842021)

<a name="pyjy-1739985212741"></a>[缓存一致性协议（Cache Coherence Protocol）：](#ikm2-1709308842025)

<a name="vvfw-1739985212743"></a>[指令序列化（Instruction Serialization）：](#wpeu-1709308842029)

<a name="ebre-1739985212745"></a>[不同的场景适用哪种锁](#olfu-1709309769107)

<a name="waer-1739985212747"></a>[.共享数据的读写操作：](#y60t-1709309615585)

<a name="wjag-1739985212749"></a>[适用措施：读写锁（ReadWrite Lock）、互斥锁（Mutex）、原子操作、无锁算法。Copy on Write优化读写锁](#lqad-1709309615587)

<a name="thl6-1739985212751"></a>[.并发容器的操作：](#fsfa-1709309615591)

<a name="acgc-1739985212753"></a>[适用措施：线程安全的容器类（如ConcurrentHashMap、ConcurrentLinkedQueue）、原子操作。](#rs2n-1709309615593)

<a name="rgsj-1739985212755"></a>[.多个线程协作的场景：](#xdpv-1709309615597)

<a name="lyc0-1739985212757"></a>[适用措施：信号量（Semaphore）、条件变量（Condition Variable）。](#uzlr-1709309615599)

<a name="etaj-1739985212759"></a>[.分布式系统的并发操作：](#0aah-1709309615603)

<a name="rqng-1739985212761"></a>[适用措施：分布式锁、分布式事务。](#wlhe-1709309615605)

<a name="0vmz-1739985212763"></a>[.不可变数据的并发访问：](#angi-1709309615609)

<a name="e3pi-1739985212765"></a>[适用措施：不可变数据结构、原子操作。](#pga0-1709309615611)

<a name="eykx-1739985212767"></a>[.高性能要求的并发操作：](#pw5v-1709309615615)

<a name="qk7s-1739985212769"></a>[适用措施：无锁算法、并发数据结构。 -CAS乐观锁](#plv6-1709309615617)

<a name="6tlp-1739985212771"></a>[互斥访问：](#62mg-1709309976431)

<a name="node-1739985212773"></a>[.互斥锁（Mutex）：](#0qt3-1709307350160)

<a name="8szq-1739985212775"></a>[.原子操作：](#7xva-1709307350164)

<a name="xw8r-1739985212777"></a>[.临界区（Critical Section）：](#r8cl-1709307350168)

<a name="gwry-1739985212779"></a>[.读写锁（ReadWrite Lock）：主要用于避免脏读](#occj-1709307350172)

<a name="f2yq-1739985212781"></a>[.信号量（Semaphore）：](#vej9-1709307350176)

<a name="gi07-1739985212784"></a>[.条件变量（Condition Variable）：](#ssge-1709307350180)

<a name="wi63-1739985212786"></a>[.无锁算法（Lock-Free Algorithms）：](#zk0j-1709307350184)

<a name="xoxl-1739985212788"></a>[.数据拷贝-写时复制（Copy-on-Write）：优化读写锁，写时复制且串行执行(锁)，读不加锁（数据库一致性备份写时复制是读备份，而这个是在备份操作防止脏读主数据）](#tiqo-1709307350188)

<a name="xnxf-1739985212790"></a>[.线程安全的数据结构：](#b8ca-1709307350192)

<a name="gnbx-1739985212792"></a>[===系统架构设计师===](#nyrv-1709307688718)

<a name="sewx-1739985212794"></a>[系统工程与信息系统基础](#mpwu-1704949756608)

<a name="a3cw-1739985212796"></a>[.系统工程方法](#2gzz-1704980837071)

<a name="osqd-1739985212798"></a>[.系统工程生命周期阶段](#mk93-1704952875199)

<a name="uuyv-1739985212800"></a>[.系统工程生命周期方法](#ny2c-1704952893636)

<a name="roes-1739985212802"></a>[.信息系统建设原则](#shmt-1704952904062)

<a name="a1hb-1739985212804"></a>[.信息系统开发方法](#itje-1704951812273)

<a name="ivz8-1739985212806"></a>[原型法](#bnzq-1705819374009)

<a name="ymx4-1739985212808"></a>[结构化法-瀑布型](#ujj3-1705819377863)

<a name="d5st-1739985212810"></a>[形式化法-数模](#8wek-1705819398251)

<a name="9t6g-1739985212812"></a>[敏捷方法](#jeuk-1705819392097)

<a name="68gc-1739985212814"></a>[.信息系统分类](#w8yd-1704980881013)

<a name="wnaw-1739985212816"></a>[业务处理系统TPS](#hlhq-1705819204285)

<a name="lgih-1739985212818"></a>[管理信息系统MIS](#oksn-1705819204735)

<a name="a30x-1739985212820"></a>[决策支持系统DSS](#lwm7-1705819204736)

<a name="sx44-1739985212822"></a>[专家系统ES](#bmeu-1705819204737)

<a name="j7x0-1739985212824"></a>[办公自动化系统OAS](#kffq-1705819204738)

<a name="lo3o-1739985212826"></a>[企业资源系统ERP](#k2px-1705819204739)

<a name="u8rv-1739985212828"></a>[过程模型](#f98t-1704981918920)

<a name="e8z4-1739985212830"></a>[瀑布模型](#yk4j-1705841608124)

<a name="naed-1739985212832"></a>[V模型【瀑布变种-测试贯穿】](#oryp-1705841608705)

<a name="l0gx-1739985212834"></a>[原型模型](#b0cp-1705841621350)

<a name="jw8h-1739985212836"></a>[螺旋模型【原型+瀑布 风险】](#sfqi-1705841608707)

<a name="tr17-1739985212838"></a>[构件组装模型/基于构件的开发方法](#kbjw-1705841608709)

<a name="sfad-1739985212840"></a>[快速应用开发RAD【瀑布+构件组装】](#mvze-1705841627436)

<a name="hunh-1739985212842"></a>[统一过程/统一开发方法](#xici-1705841629815)

<a name="txva-1739985212844"></a>[敏捷开发方法](#9jca-1705841608711)

<a name="jb9a-1739985212846"></a>[XP](#28va-1705841590197)

<a name="jj86-1739985212848"></a>[Scrum](#fyfq-1705938223773)

<a name="b1q0-1739985212850"></a>[逆向工程](#d5ko-1705938215067)

<a name="2r0j-1739985212852"></a>[实现级](#os3c-1706090901666)

<a name="ieej-1739985212854"></a>[结构级](#irxb-1706090905276)

<a name="fmxp-1739985212856"></a>[功能级](#rk8d-1706090908958)

<a name="ie3c-1739985212858"></a>[领域级](#k3pt-1706090912460)

<a name="iy8x-1739985212860"></a>[净室软件工程](#tybd-1705938215235)

<a name="8udu-1739985212862"></a>[需求工程](#ochn-1705940085547)

<a name="w3dg-1739985212864"></a>[.需求获取](#xdlf-1705940054108)

<a name="lvql-1739985212866"></a>[用户面谈 ](#s1uq-1706090846730)

<a name="tzsg-1739985212868"></a>[联合需求计划(JRP) ](#vuil-1706090851858)

<a name="2lwk-1739985212870"></a>[问卷调查 ](#gpxg-1706090851859)

<a name="gpxz-1739985212872"></a>[现场观察   ](#mg9n-1706090851860)

<a name="0dwe-1739985212874"></a>[原型化方法        ](#3ww6-1706090851861)

<a name="9exe-1739985212876"></a>[头脑风暴法](#0awr-1706090851863)

<a name="uqmn-1739985212878"></a>[.需求分析](#axny-1705940052332)

<a name="pyct-1739985212880"></a>[1.功能模型(数据流图DFD)](#v8wz-1706090812929)

<a name="5f5z-1739985212882"></a>[2.行为模型(状态转换图)](#3uls-1706090814821)

<a name="htrv-1739985212884"></a>[3.实体模型(E-R图)](#69df-1706090816407)

<a name="m4gn-1739985212886"></a>[UML](#loq2-1705940640473)

<a name="oxee-1739985212888"></a>[需求定义](#4aeg-1706091062964)

<a name="abwo-1739985212890"></a>[需求验证](#ud2s-1706090947930)

<a name="fkqw-1739985212892"></a>[需求跟踪](#l03x-1705940634470)

<a name="xv0z-1739985212894"></a>[需求变更管理](#muqf-1706093218719)

<a name="l9ls-1739985212896"></a>[软件系统建模](#ilpb-1706093190683)

<a name="9qvx-1739985212898"></a>[软件界面设计](#j396-1706094675778)

<a name="brno-1739985212900"></a>[结构化设计](#vqsk-1706094478028)

<a name="lild-1739985212902"></a>[内聚](#jczo-1706095018132)

<a name="arbf-1739985212904"></a>[耦合](#qa8z-1706095402118)

<a name="6atv-1739985212906"></a>[模块四要素](#g1dc-1706095391028)

<a name="k0oj-1739985212908"></a>[面相对象设计](#ydwa-1706095870710)

<a name="xcfx-1739985212910"></a>[类的分类](#fouz-1706095958643)

<a name="vxuy-1739985212912"></a>[基本过程](#9pd1-1706095996137)

<a name="91bl-1739985212914"></a>[设计原则(同设计模式)](#k8lc-1706096001163)

<a name="ygqz-1739985212916"></a>[计算机](#qvol-1706095952165)

<a name="tctg-1739985212918"></a>[计算机结构(★)](#ef1b-1706108352037)

<a name="xrfd-1739985212920"></a>[存储系统(★★★★)](#4kj7-1706108373776)

<a name="pnuz-1739985212922"></a>[层次化存储结构](#ucta-1706109825295)

<a name="lfph-1739985212924"></a>[Cache](#j9hn-1706109828962)

<a name="ybgn-1739985212926"></a>[主存编址计算](#pv51-1706109847372)

<a name="e83q-1739985212928"></a>[磁盘基本结构与存储过程](#jcqv-1706108377026)

<a name="coir-1739985212930"></a>[磁盘优化分布存储](#puux-1706111215530)

<a name="v9cx-1739985212932"></a>[磁盘单缓冲区与双缓冲区读取](#dvin-1706111222861)

<a name="iacs-1739985212934"></a>[磁盘移臂调度算法](#jr2r-1706111239137)

<a name="pdgp-1739985212936"></a>[数据传输控制方式（★)](#sz2k-1706111188014)

<a name="nkkz-1739985212938"></a>[总线（★★)](#cbul-1706108378755)

<a name="b535-1739985212940"></a>[CISC与RISC(★)](#0hb5-1706108373778)

<a name="vn6g-1739985212942"></a>[流水线(★★)](#ernn-1706108380109)

<a name="gvgp-1739985212944"></a>[校验码(★)](#grix-1706108381278)

<a name="cwbx-1739985212946"></a>[嵌入式（★)](#1p2v-1706108382511)

<a name="z4iw-1739985212948"></a>[计算机网络](#8vmt-1706198382356)

<a name="swbf-1739985212950"></a>[TCP/IP协议族(7层/4层网络模型)](#a4es-1706106975412)

<a name="kmkz-1739985212952"></a>[.TCP与UDP (★★★)](#vwim-1706198561289)

<a name="ltp6-1739985212954"></a>[.DHCP与DNS (★★★)](#imsh-1706198537828)

<a name="go0f-1739985212956"></a>[网络规划与设计](#u7sd-1706198559304)

<a name="yqi4-1739985212958"></a>[1.逻辑设计与物理设计(★★★★）](#nov8-1706198591905)

<a name="pnjj-1739985212960"></a>[2.层次化网络设计](#sy2g-1706198599196)

<a name="swpq-1739985212962"></a>[3.网络冗余设计](#igl7-1706257923205)

<a name="1qbv-1739985212964"></a>[网络存储（★★)](#zkxb-1706257899477)

<a name="cx3p-1739985212966"></a>[磁盘阵列Raid](#fxma-1706198636789)

<a name="hphm-1739985212968"></a>[lPv6 (★)](#vlem-1706259832461)

<a name="gp8o-1739985212970"></a>[网络接入(有线/无线)](#g438-1706198637653)

<a name="pzaj-1739985212972"></a>[综合布线(★)](#lxli-1706198497856)

<a name="w3hd-1739985212974"></a>[网络技术扩展](#5dlt-1706198650540)

<a name="r1hj-1739985212976"></a>[物联网(IOT)](#jgll-1706198586849)

<a name="wpqq-1739985212978"></a>[云计算(Saas/Paas/Iaas)](#pr8x-1706198586851)

<a name="azxp-1739985212980"></a>[===系统架构设计case===](#1rnn-1706941312871)

<a name="zf7y-1739985212982"></a>[google L5设计一个分布式数据库架构](#nm5q-1706969255961)

<a name="mdgv-1739985212984"></a>[.what is total ordering(ordering first 100 custormer)](#g7yu-1707229908505)

<a name="ki65-1739985212986"></a>[.why single leader()](#ebxf-1707230056989)

<a name="upvh-1739985212988"></a>[.request router](#ttmg-1707230034624)

<a name="codg-1739985212990"></a>[.variations](#aftd-1707229925082)

<a name="avfx-1739985212992"></a>[1.Failover handing](#uk2k-1707457488655)

<a name="o6uy-1739985212994"></a>[2.Reblancing after new node added](#btbd-1707457496651)

<a name="5nxk-1739985212996"></a>[3.Leaderless for heavy write-shard](#moaq-1707457524278)

<a name="yx7j-1739985212998"></a>[4.TicketMasler (and total ordering is necessary](#wyvq-1707458882987)



<a name="jeyl-1677787446995"></a>**一.数据库设计**

<a name="5hya-1677787446996"></a>**1. 关系型数据库**

<a name="ohc5-1621692571287"></a>**.E-R图，由台湾工程师提出的设计概念**

<a name="4z7m-1645598900270"></a>权益系统数据库设计复盘：雄爷并行看需求文档一两天设计DB。

<a name="5ocb-1645598528868"></a>**.流程图-业务逻辑相关，系统用户动作。抽象出E-R图**

<a name="gzqe-1677787446997"></a>**1.1 E-R图** 

<a name="r1ac-1621692724628"></a>**1.根据名词抽象出实体**

<a name="d2fl-1621692745600"></a>**2.名词找属性**

<a name="dwkp-1621692752824"></a>**3.实体间联系**

<a name="cyqi-1699843717785"></a>（单条记录对应关系 A表一条记录对应B表多条记录，B表一条记录对应A表多条记录即 m对）

<a name="53bo-1621692829033"></a>**.状态图**

<a name="c2cy-1677787446998"></a>**1.2 转化成数据库设计（公式）**

<a name="xmox-1621692858500"></a>**.1 对1 关系 往记录少的乙方加主键**

<a name="mdr8-1621692924289"></a>**.1对n 关系 ，往 n 实体加关联主键** 

<a name="hd3i-1621692960576"></a>**. n对 m 关系，需要一个关联表作映射关联**

<a name="p0tb-1655431896857"></a><a name="i6pd-1655431897042"></a>最好不要自己设计自己的表，关乎字段名统一（属性思想上的统一），以及字段冗余，字段依赖问题。

<a name="kneq-1715100176411"></a><a name="szqu-1715100194538"></a>**2.数据类型选择**

<a name="she1-1715100176604"></a>选择合适的数据类型对于数据库设计和性能至关重要。

<a name="0rub-1715100184335"></a>**整数类型（Integer Types）**

<a name="ww2f-1715100184339"></a>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT：分别用于存储不同范围的整数值。

<a name="xz9x-1715100184341"></a>建议根据数据范围选择合适的整数类型，以节省存储空间和提高性能。例如，如果数据范围在 -128 到 127 之间，可以选择 TINYINT 类型。

<a name="j4ut-1715100184343"></a>**浮点数类型（Floating-Point Types）**

<a name="ribt-1715100184347"></a>FLOAT、DOUBLE、DECIMAL：用于存储浮点数值。

<a name="fayg-1715100184349"></a>建议根据精度和范围选择合适的浮点数类型。FLOAT 适用于单精度浮点数，DOUBLE 适用于双精度浮点数，DECIMAL 适用于需要精确计算的场景。

<a name="muci-1715100184351"></a>**字符串类型（String Types）**

<a name="w0kv-1715100184355"></a>CHAR、VARCHAR、TEXT、BLOB：用于存储字符串数据。

<a name="yxnd-1715100184357"></a>建议根据存储的数据长度和使用场景选择合适的字符串类型。CHAR 适用于固定长度字符串，VARCHAR 适用于可变长度字符串，TEXT 适用于存储较大文本数据，BLOB 适用于存储二进制数据。

<a name="fjm4-1715100184359"></a>**日期和时间类型（Date and Time Types）**

<a name="hxzu-1715100184363"></a>DATE、TIME、DATETIME、TIMESTAMP：用于存储日期和时间数据。

<a name="phcm-1715100184365"></a>建议根据需要存储的精度和范围选择合适的日期和时间类型。DATE 适用于仅存储日期，TIME 适用于仅存储时间，DATETIME 适用于存储日期和时间，TIMESTAMP 适用于存储时间戳，通常用于记录数据的创建和修改时间。

<a name="tofd-1715100184367"></a>**其他类型**

<a name="ozmi-1715100184371"></a>ENUM、SET：用于存储枚举值和集合值。

<a name="885s-1715100184373"></a>建议在需要枚举或固定集合值的情况下使用这些类型，以提高数据的完整性和可读性。

<a name="vjgq-1715100184375"></a>在选择数据类型时，除了考虑数据范围、精度和使用场景外，还应考虑存储空间、性能和数据完整性等因素。选择合适的数据类型可以**提高数据库的性能和可维护性，同时降低存储成本。**

<a name="6bqw-1715100177239"></a>**3. 数据治理**

<a name="044n-1738420834129"></a>航信：XML  schema

<a name="7lkx-1738420998090"></a>空管：数据治理，整理各个空管局硬件设备命名统一各个系统规范，华东已做。标准化命名。

<a name="kdpj-1738421050431"></a>恒大：各系统各自命名，对账时需要做转换层数据映射。

<a name="cdso-1677787447000"></a>**二.系统优化**

<a name="3qep-1642647362896"></a>**应用整体的优化**

<a name="knge-1642647371136"></a>**-cpu -> 纳秒级别**

<a name="ovup-1704437622969"></a>**1.多线程和并发编程**

<a name="ufpl-1704437634986"></a>**2.JNI** 

<a name="ixb5-1704437634987"></a>**3.JIT/AOT编译**

<a name="kr1f-1704437634988"></a>**4.算法优化**

1\.多线程和并发编程：多线程和并发重复利用多核CPU,利用线程池管理复用线程，避免创建和销毁线程昂贵开销。

2\.JNI: C本地代码调度CPU

3\.JIT/AOT编译：JVM 和 JIT 足够时间来优化热点代码 / 云原生native Graavm ahead of time(AOT)静态编译

<a name="pojo-1704436320217"></a>4.算法优化：优化关键算法和数据结构，确保CPU执行效率

<a name="1xur-1642647384168"></a>**-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)**

<a name="7hi9-1704437851514"></a>**1.JVM内存管理**

<a name="te7c-1704437851799"></a>**2.缓存**

<a name="bqty-1704437851800"></a>**3.消息中间件**

(空间换时间)

1\.JVM内存管理：设置合理的堆大小及垃圾回收策略。

2\.缓存：redis缓存，spring缓存，ORM缓存

<a name="pxxu-1704436648342"></a>3.消息中间件：异步写，提高并发写能力。-吞吐量

<a name="ziti-1642647439005"></a>**-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)**

<a name="zups-1704437900079"></a>**1.减少磁盘io**

<a name="u3ok-1704438035018"></a>**2.数据压缩**   

1\.减少io(磁盘读写): 异步io,sql索引,局部性原理加载相邻页数据 ,DB数据磁盘预读----数据存储一般在DB系统中

<a name="ayss-1704436737847"></a>2.数据压缩：对需要存储或传输的数据进行压缩，减少磁盘占用

<a name="irbp-1642647458856"></a>**-网络传输/系统交互 -> 秒级 (减少io，连接池化)** 

<a name="6qil-1704438276193"></a>**1.减少网络请求**   

<a name="p5dt-1704438283633"></a>**2.使用CDN**

<a name="zhp8-1704438283634"></a>**3.Sockets异步通信**                                      

1\.减少网络请求：减少io(系统交互/连接池连接数)：去除for循环sql 

`    `--池化思想，创建和销毁消耗大的资源创建一个资源池，维护一定数量的资源数，统一管理资源创建和销毁

2\.使用CDN: 对于静态资源，使用内容分发网络（CDN）来加速资源的加载。

<a name="85si-1704436765735"></a>3.Sockets异步通信：对于需要等待的网络通信，可以考虑使用异步方式。

<a name="3l0l-1704424353262"></a>**项目架构层面的优化**

<a name="8o8s-1704424396933"></a>**-多级缓存**

亿级流量-多级缓存

<a name="lm7b-1704438499917"></a>浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

<a name="trcg-1704438366333"></a>**-应用层**

<a name="68oa-1704438530062"></a>**.代码优化**

<a name="clmf-1704438530257"></a>**.数据库优化**

<a name="md03-1704438530259"></a>**.日志优化**

·代码优化:通过代码审查和性能分析工具来识别和优化慢速或低效的代码。

·数据库优化:对于数据库访问，使用索引、合理的查询语句，以及数据库连接池等来提高性能。

<a name="8o0m-1704438517387"></a>·日志优化:避免过度记录日志，尽量异步记录，或者使用日志级别进行动态调整。

<a name="ocux-1704438477879"></a>**-监控与调优**

<a name="vdq2-1704438556836"></a>**.性能监控：**

<a name="t29d-1704438557094"></a>**.分析和调优**

·性能监控:使用性能监控工具，例如Java Mission Control、VisualVM等，来实时监测应用程序的性能。

<a name="l3kg-1704437252457"></a>·分析和调优:根据监控结果，进行分析并进行调优，优化性能瓶颈。

<a name="ukjf-1704424419442"></a>**-分布式系统架构**

<a name="a0bx-1704438677201"></a> **.负载均衡**

<a name="xn9x-1704438687994"></a>**.分布式缓存**

<a name="zcdp-1704438687996"></a>**.服务降级和容错**

浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

`                `CDN                  SLB负载均衡        分布式缓存          异步通信、MQ异步写/并发写、容错降级

·负载均衡:对于分布式系统，使用负载均衡来分配请求，以确保各个节点的负载均匀。

·分布式缓存:使用分布式缓存来减轻数据库负担，提高数据读取速度。

<a name="xpee-1704438657125"></a>·服务降级和容错:实现服务降级和容错机制，以应对网络或服务不稳定的情况。

<a name="six7-1642647372926"></a>**读写层面**

<a name="g4uv-1704732583614"></a>**.读优化**

<a name="uuzh-1704732602620"></a>**1.缓存**

<a name="qobc-1704732605892"></a>**2.索引**

<a name="zlg9-1704732609048"></a>**3.减少io/批量读/非阻塞io**

<a name="fpjd-1704732631316"></a>**4.减少多余数据加载/列式存储读**

<a name="oyob-1704732598377"></a>**.写优化**

<a name="6jmb-1704732509150"></a>**1.异步写**

<a name="tkwp-1704732723564"></a>**2.并发写**

<a name="hewz-1704732862030"></a>**3.批量写**

<a name="ccd8-1704732727854"></a>**4.优化算法和数据结构**

<a name="eqd9-1704732736281"></a>**5.缓存写**

<a name="hyq8-1704732768916"></a>**6.非阻塞io**

1\.批量操作:将多个写操作合并为批量操作，减少与数据库或其他外部存储的交互次数。例如，使用批量插入、批量更新或批量删除等操作，以减少单个写操作的开销。2.异步写入:使用异步写入的方式，将写操作放入队列或缓冲区中，由专门的线程异步处理。这样可以将写操作与主程序解耦，提高响应速度，并将写入操作批量化。

3\.数据库优化:对于关系型数据库，可以考虑优化数据库的配置和索引，以提高写入性

能。使用合适的数据库引擎和事务隔离级别，并优化查询和写入语句的性能。

4\.使用缓存:对于频繁的写入操作，可以使用缓存来减少对数据库的直接访问。将数据写入缓存，并通过批量或定期更新将数据同步到持久化存储。

5\.数据结构优化:选择合适的数据结构来存储数据，以提高写入性能。例如，使用哈希表、跳表等高效的数据结构来支持快速插入和更新操作。

6\.并发处理:使用多线程或分布式处理来并行处理写入操作，以提高写入性能。使用线程池或任务调度器来管理并发写入任务，并确保线程安全和数据─致性。

7\.使用非阻塞IO:对于高并发的写入操作，可以使用非阻塞IO技术，如NIO (New lO)或Netty等，以提高写入性能和吞吐量。

8\.数据分片:如果数据量较大，可以考虑将数据分片存储，将数据分散到多个存储节点上。这样可以将写入操作分散到多个节点上并行处理，以提高写入性能和扩展性。9.写缓冲:使用写缓冲区来缓存写入的数据，减少对物理存储设备的实时写入。通过批

<a name="z4ya-1704738513279"></a>量或异步的方式将缓冲区的数据定期写入存储设备，以提高写入性能。

<a name="tncv-1677787447001"></a>**1.分控系统优化复盘**

<a name="ydq7-1677787447002"></a>**1.1 数据库系统**

<a name="xsbg-1642647218571"></a>数据库的性能过低

<a name="eg0t-1642647223498"></a>提升硬件配置

<a name="wxdd-1677787447003"></a>**1.2 sql慢**

<a name="javd-1642647045138"></a>数据量大一千6百多万条数据

<a name="no1c-1642647140123"></a>删除冗余数据，每天采集13次，需求7天外数据只保留最新一批数据，修正删除的sql, 剩余数据，200w~600w左右。

<a name="ykot-1642649009232"></a>添加索引

<a name="olpb-1677787447004"></a>**1.3 接口慢**

<a name="blpq-1642649142995"></a>for循环遍历sql

<a name="s2zh-1642649153917"></a>去除for循环sql

<a name="yryq-1642649204976"></a> 频繁的采集种erverywhere log.info

<a name="afeg-1642649254648"></a>减少日志文件io，非必要信息改为debug。

<a name="hxbs-1739984957390"></a>**2.简化应用复杂度**

<a name="fbky-1739984987936"></a>**分布式BASE理论，最终一致，补偿对账机制。不强求强一致性引入复杂问题。**

<a name="fjt3-1643394063817"></a><a name="efqc-1643394063942"></a>优先考虑优化代价比较少的代码优化及sql优化，完成此类优化再考虑系统设计层面的优化，如：分库分表等（系统复杂度提升）。

<a name="navz-1652597408993"></a>一期历史数据重大bug修复方案设计问题（参看文档）： 注意像算法那样考虑极端情况（bug）处理，梳理方案的优缺点，对比不同方案实现优缺点接受度。

<a name="w6cm-1652597504660"></a>1.保证数据为最新的一批：

<a name="o4ka-1652597649729"></a>原方案. 每天13批次数据，不做事务回滚，取maxid ，>24小时数据删除---<24小时当天取消航班会在其中

<a name="ihuw-1652599412442"></a>配置难点：采集时段不同，每个账号采集不同天数; 采集的时间频率不同：

<a name="uarz-1652598784895"></a>熊爷方案：不改动原有逻辑，增加字段增加判段历史数据逻辑。

<a name="yxwj-1652599128439"></a>优点：基本不用改动一期代码和逻辑，改动sql增加判断历史条件。

<a name="rjdk-1652599326567"></a>缺点：新增判断的逻辑需要批次保证事务性，且配置难度很大，跨小时频率或者地区重叠，不可保证批次完整性，对比无效且配置和代码都得写死。

<a name="cehv-1652599093885"></a>我的方案：保证批次完整性，失败的批次直接整批删除，取最新一批。也是仅改动sql，获取最新一批批次代替 max(id)。

<a name="fm9n-1652599202701"></a>优点：只需要天数不重叠即可，配置相对灵活。

<a name="0ckh-1652599307805"></a>缺点：需要改sql逻辑，业务逻辑影响风险较大，需仔细验证。

<a name="nwww-1652597653246"></a> 

<a name="yjau-1644231171609"></a>分控系统重构设计

<a name="q9y5-1644231078993"></a>可靠性：写操作频繁，250k/h ~70次请求/s，将采集和后台分开两个应用。目前问题，采集两周左右系统资源耗尽会挂，可有多台服务器，实际上只用了两台。（集成应用监控，实现预警）

<a name="1ozg-1644231149674"></a>可拓展性：暂无,用户负载暂无数据

<a name="nbg9-1644231153386"></a>可维护性：代码质量，可读性。

<a name="wrwk-1642647280506"></a>**高并发系统设计**

<a name="8ien-1704757782146"></a>**1.满足大规模用户同时访问，提供良好响应时间和性能**

<a name="xy0g-1704757785190"></a>**2.设计之初就要考虑伸缩性和容错性是非常重要的**

<a name="wr12-1704947861599"></a>**.垂直伸缩** 

<a name="bizh-1704947959744"></a>**.水平伸缩**

·随着互联网的普及，用户访问量可能会在短时间内急剧增加。高并发系统设计可以确保系统在面对大规模用户同时访问时能够提供良好的响应时间和性能。

.高并发系统的设计是一个复杂而动态的过程，需要根据业务需求和系统特点不断优化。在设计之初就考虑到系统的可伸缩性和容错性是非常重要的。

` `垂直伸缩

`  `+配置32核CPU +124GB内存 +500G硬盘

优点；方案简单，易理解操作

缺点：容易达到机器物理上限，不具备高可用能力，单点故障高。

水平伸缩

<a name="4kjn-1704757525367"></a>多实例高可用，无需高性能服务器也可进行伸缩。

<a name="fvzi-1704756770858"></a>**1.分布式架构**

<a name="ywzr-1704756872033"></a>**.微服务架构**

<a name="xgna-1704756877646"></a>**.分布式计算**

·微服务架构:使用微服务拆分系统，将系统拆分成多个小而独立的服务，每个服务专注于特定的业务功能。

<a name="6khx-1704757167738"></a>·分布式计算:将任务分布到多个节点上，以充分利用计算资源。

<a name="wnfy-1704756775272"></a>**2.负载均衡**

<a name="h6nf-1704756891918"></a>**.负载均衡**

<a name="c8zr-1704756894402"></a>**.水平扩展**

·负载均衡器:使用负载均衡器分配请求到多个服务器，确保各个服务器的负载均衡。

<a name="o1d2-1704757209512"></a>·水平扩展:可以通过增加服务器数量来水平扩展系统，以支持更多的并发请求。

<a name="wxjk-1704756782840"></a>**3.数据库设计**

<a name="lxca-1704756910837"></a>**.读写分离**

<a name="p7d2-1704756922362"></a>**.数据库分片**

<a name="hxjt-1704756963988"></a>**.缓存**

·读写分离:使用读写分离来分担数据库的读写负载，提高数据库性能。

·数据库分片:将数据库分片，使数据分布在多个节点上，降低单—数据库的压力

<a name="yymm-1704757244191"></a>·缓存:使用缓存来减轻数据库负担，提高数据读取速度。

<a name="iivs-1704756788012"></a>**4.缓存优化**

<a name="cvui-1704756971791"></a>**.分布式缓存**

<a name="ysly-1704756979122"></a>**.本地缓存**

<a name="rqwj-1704756986363"></a>**.缓存预热**

·分布式缓存:使用分布式缓存，如Redis或Memcached，以提高数据的读取速度。

·本地缓存:在服务端使用本地缓存，减少对数据库或远程服务的请求次数。

<a name="vkcq-1704757254304"></a>·缓存预热:在系统启动时，预先加载一部分热门数据到缓存中，提高缓存命中率。

<a name="so9h-1704756800253"></a>**5.消息队列**

<a name="sxlo-1704756996000"></a>**.异步处理**

<a name="llm2-1704757002994"></a>**.削峰填谷**

·异步处理:使用消息队列进行异步处理，将一些非实时关键路径的任务放入队列中处理，减轻服务器负担。

<a name="99fz-1704757286906"></a>·削峰填谷:缓解系统压力，通过消息队列实现请求的削峰填谷，防止瞬时大量请求导致系统崩溃。

<a name="n39o-1704756805232"></a>**6.分布式事务**

<a name="5bhj-1704757017700"></a>**.两阶段提交**

<a name="becc-1704757028036"></a>**.补偿事务**

两阶段提交（2PC):在分布式环境中，确保事务的一致性，可以使用两阶段提交协议。

<a name="qset-1704757299753"></a>·补偿事务:使用补偿事务机制，处理在分布式环境中的异常情况。

<a name="wgkk-1704756813448"></a>**7.高可用和容错**

<a name="akwz-1704757035393"></a>**.多地域部署**

<a name="3nxv-1704757055271"></a>**.设计容错**

<a name="g3xx-1704757371028"></a>**1. 熔断限流**

<a name="jafy-1704757374368"></a>**2. 多节点服务**

·多地域部署:在不同地理位置部署系统，提高系统的可用性。

<a name="h6bn-1704757326243"></a>·容错设计:使用容错设计，确保系统在部分节点或服务失效时能够继续提供服务。

<a name="ilyo-1704756820772"></a>**8.监控和性能调优**

<a name="kpwq-1704757064566"></a>**.实时监控**

<a name="shf4-1704757066453"></a>**.性能测试**

·实时监控:使用监控系统实时监测系统性能，对系统进行及时调整。

<a name="lkos-1704757433031"></a>性能测试:定期进行性能测试，模拟高并发情况，找出系统的瓶颈并进行优化。

<a name="2pry-1704756830245"></a>**9.安全性设计**

<a name="pkiw-1704757078583"></a>**.防御性编程**

<a name="g4l1-1704757084924"></a>**.访问控制**

·防御性编程:编写安全的代码，防范SQL注入、XSS攻击等。

<a name="g9ef-1704757459182"></a>·访问控制:对系统的访问进行严格控制，避免未经授权的访问。

<a name="1tsd-1704756838192"></a>**10.水平扩展**

<a name="r1dd-1704757092061"></a>**.自动化部署**

<a name="7mhk-1704757104117"></a>**.云服务**

·自动化扩展:设计自动化扩展机制，根据系统负载自动增减节点。

<a name="g3qv-1704757477668"></a>·云服务:使用云服务提供商的弹性计算能力，根据需求调整计算资源。

<a name="rpxb-1677787447005"></a>**高并发性能指标**

<a name="klnv-1704761369323"></a>**QPS(每秒请求)**

<a name="zvlz-1704761369324"></a>**TPS(每秒事务)**

<a name="gvrn-1704761369325"></a>**RT(响应时间)**

我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。

公式：( 总PV数 \* 80% ) / ( 每天秒数 \* 20% ) = 峰值时间每秒请求数(QPS)

机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器

1、每天300w PV(网页浏览量) 的在单台机器上，这台机器需要多少QPS？ 

( 3000000 \* 0.8 ) / (86400 \* 0.2 ) = 139 (QPS)

2、如果一台机器的QPS是58，需要几台机器（cpu瓶颈）来支持？ ---得分析性能瓶颈，例如是CPU还是数据库。

<a name="02ut-1704761377369"></a>139 / 58 = 3 

<a name="nuln-1709310472128"></a><a name="ysmj-1709309531982"></a>**(原子操作)并发编程中保证数据一致性/安全的方法**

<a name="gawc-1709307342094"></a>在并发编程中，为了保证数据安全（**即避免数据竞争和并发访问导致的不确定行为**），可以采取以下一些措施：

<a name="kfs4-1709308475961"></a>总体来看，就是需要保证原子操作：**原子性（事务）   +    隔离性(锁串行化执行/cas)=一致性** ，用事务的思想可以简化并发问题。

<a name="nian-1709319335754"></a>保证 **原子性+串行化执行 。**

<a name="fdxy-1709308630108"></a>**原子性+悲观锁：各种锁机制**

<a name="v06l-1709312268021"></a>**.（事务+锁/ 分布式事务+分布式事务）**

<a name="k0op-1709312304164"></a>**.  CASmysql版本号实现 (前提是数据库的update已经是原子写：mysql update排它锁）**

<a name="qth5-1709308703202"></a>**原子性+乐观锁/不加锁: CAS原子操作(java原子类)，**

<a name="emi9-1739292888548"></a>百度AI   **分布式锁的优点和适用场景**：**分布式系统中通常使用分布式锁而不是乐观锁**‌。分布式锁和乐观锁各有其适用场景和优缺点，但在分布式系统中，分布式锁更为常见和适用。

<a name="whfk-1739294678878"></a>‌**确保数据一致性**‌：分布式锁的主要目的是确保在分布式系统中的多个节点之间对共享资源的访问是互斥的，即同一时间只有一个节点可以获取锁并执行关键代码段，其他节点需要等待锁的释放才能继续执行‌1。

<a name="t1re-1739294678880"></a>‌**避免数据竞争和冲突**‌：在分布式环境中，多个节点或进程同时访问共享资源时，分布式锁可以协调并发访问，避免数据竞争和冲突‌1。

<a name="uuev-1739294678882"></a>‌**高可用性和容错性**‌：分布式锁的实现需要考虑节点故障和网络分区等异常情况，确保在故障发生时锁可以正常释放或切换到其他节点。此外，分布式锁通常会设置超时时间或自动释放机制，以防止死锁情况的发生

<a name="sa91-1739294834562"></a>百度AI  CAS使用场景：（即缓存罗）

<a name="fl4p-1739294545260"></a>‌**适用于读多写少的场景**‌：乐观锁适用于读操作远多于写操作的场景。通过版本号或时间戳来检测数据在读取和写入之间是否被修改，从而避免写冲突‌2。

<a name="bk4n-1739294545262"></a>‌**性能较高**‌：在写操作不频繁的情况下，乐观锁可以减少锁的争用，提高系统的并发性能‌2。

<a name="3xao-1739294545264"></a>‌**适用性有限**‌：由于乐观锁依赖于检测数据在读取和写入之间是否被修改，因此在写操作频繁或数据一致性要求高的场景中，乐观锁可能不够可靠‌23。

反驳去年脉脉问题：什么情况下事务下还用锁？

少淋笛子：1.for update、可重复读级别显式加锁解决幻读 或者 2.CAS乐观锁

我现在的反驳：这些的确都可以解决数据一致性。

1\.一般为了性能默认为RC读已提交。for update RC下会幻读（读null数据，但插入阻塞不影响业务），

`   `而 RR下for update 走索引会有临键锁，如果不走索引会锁表，性能低。

2\.乐观锁只适用读多写少的场景，写入频繁竞争开销会增大。


==============CAS 适用于 库存扣减、账户余额更新 等场景：

UPDATE products

SET stock = stock - 1, version = version + 1

WHERE product\_id = 1001 AND version = 5;

如果 version 发生变化，则更新失败，需要 重试

==============Redis 分布式锁

import redis.clients.jedis.Jedis;

public class RedisDistributedLock {

`    `private static final int LOCK\_EXPIRE\_TIME = 10000; // 锁的过期时间，单位毫秒

`    `private static final String LOCK\_KEY = "my\_lock"; // 锁的键名

`    `private static final String LOCK\_VALUE = "locked"; // 锁的值，用于标识锁的持有者

`    `private Jedis jedis;

`    `public RedisDistributedLock(Jedis jedis) {

`        `this.jedis = jedis;

`    `}

`    `public boolean acquireLock() {

`        `String result = jedis.set(LOCK\_KEY, LOCK\_VALUE, "NX", "PX", LOCK\_EXPIRE\_TIME);

`        `return "OK".equals(result);

`    `}

`    `public boolean releaseLock() {

`        `Long result = jedis.del(LOCK\_KEY);

`        `return result != null && result > 0;

`    `}

`    `public static void main(String[] args) {

`        `// 假设已经创建了一个连接Redis的Jedis实例

`        `Jedis jedis = new Jedis("localhost", 6379);

`        `// 创建一个RedisDistributedLock对象

`        `RedisDistributedLock lock = new RedisDistributedLock(jedis);

`        `// 获取锁

`        `boolean locked = lock.acquireLock();

`        `if (locked) {

`            `try {

`                `// 成功获取到锁后的业务逻辑

`                `System.out.println("Successfully acquired lock");

`            `} finally {

`                `// 释放锁

`                `lock.releaseLock();

`                `System.out.println("Lock released");

`            `}

`        `} else {

`            `// 获取锁失败时的处理逻辑

`            `System.out.println("Failed to acquire lock");

`        `}

`        `// 关闭Jedis连接

`        `jedis.close();

`    `}

<a name="gmx8-1709799551752"></a>}

<a name="g3uo-1709309147469"></a>**CAS底层实现原理 (与数据库SSI类似，不加锁的序列化隔离)**

<a name="vgcy-1709308841739"></a>在现代 CPU 中，CAS 操作的原子性是通过硬件级别的支持来实现的。CPU 提供了特殊的原子性指令（如 x86 架构中的 cmpxchg 指令），这些指令在执行过程中能够保证操作的原子性。

<a name="talv-1709308842019"></a>具体来说，CPU 在执行 CAS 操作时会采取以下措施来保证原子性：

<a name="qpbw-1709308842021"></a>**总线锁定（Bus Locking）：**

<a name="awe7-1709308842023"></a> 在执行 CAS 操作期间，CPU 会向总线发送一个锁定信号，阻止其他 CPU 访问相同的内存位置。这样可以确保在同一时间只有一个 CPU 能够成功执行 CAS 操作。

<a name="ikm2-1709308842025"></a>**缓存一致性协议（Cache Coherence Protocol）：**

<a name="fqvh-1709308842027"></a> 现代 CPU 都支持缓存一致性协议，如 MESI（Modified, Exclusive, Shared, Invalid）协议。当一个 CPU 修改了某个内存位置的值时，它会通知其他 CPU 缓存中相同内存位置的数据无效，从而保证所有 CPU 都能看到最新的数据。

<a name="wpeu-1709308842029"></a>**指令序列化（Instruction Serialization）：**

<a name="ubwg-1709308842031"></a> CAS 操作是一个原子性的指令序列，CPU 会确保在执行 CAS 操作期间不会被中断，以避免其他指令插入导致 CAS 操作失效。

<a name="elct-1709308842033"></a>通过这些硬件级别的支持，CPU 能够保证 CAS 操作的原子性。这种硬件支持使得 CAS 操作成为实现无锁并发算法的重要基础，大大提高了并发程序的性能和效率。

<a name="olfu-1709309769107"></a>**不同的场景适用哪种锁**

<a name="zfod-1709308647416"></a>不同的并发安全措施适用于不同的场景，具体选择取决于应用的需求、性能要求、数据结构以及并发访问模式。以下是一些常见的场景以及相应的并发安全措施：

<a name="y60t-1709309615585"></a>**.共享数据的读写操作：**

<a name="lqad-1709309615587"></a>**适用措施：读写锁（ReadWrite Lock）、互斥锁（Mutex）、原子操作、无锁算法。Copy on Write优化读写锁**

<a name="p6fs-1709309615589"></a>场景说明：当多个线程需要同时读取共享数据，但只有一个线程能够修改数据时，可以使用读写锁来提高读操作的并发性能。互斥锁适用于读写操作都较为频繁的场景，原子操作和无锁算法适用于对共享数据的简单修改操作。

<a name="t4at-1709312672885"></a>-读写锁与copy on write适用于写不依赖于读，令写是原子操作(单写原子性+锁隔离性)，如写缓存。写时复制则令读无需加锁，读性能更高。

<a name="zxpo-1709355699609"></a>nacos注册新实例的时候也是写时复制写缓存。

<a name="fsfa-1709309615591"></a>**.并发容器的操作：**

<a name="rs2n-1709309615593"></a>**适用措施：线程安全的容器类（如ConcurrentHashMap、ConcurrentLinkedQueue）、原子操作。**

<a name="qw0y-1709309615595"></a>场景说明：当多个线程需要对容器进行并发操作时，可以使用线程安全的容器类，这些类内置了并发安全的机制。如果需要更精细的控制，可以使用原子操作来保证数据的一致性。

<a name="xdpv-1709309615597"></a>**.多个线程协作的场景：**

<a name="uzlr-1709309615599"></a>**适用措施：信号量（Semaphore）、条件变量（Condition Variable）。**

<a name="xaa9-1709309615601"></a>场景说明：当多个线程需要在特定条件下进行协作，例如生产者-消费者模型中的缓冲区满或空时，可以使用信号量或条件变量来实现线程之间的同步和通信。

<a name="0aah-1709309615603"></a>**.分布式系统的并发操作：**

<a name="wlhe-1709309615605"></a>**适用措施：分布式锁、分布式事务。**

<a name="5gvg-1709309615607"></a>场景说明：在分布式系统中，多个节点可能需要并发地访问共享资源，可以使用分布式锁来保证资源的互斥访问。对于涉及到多个节点的事务操作，可以使用分布式事务来保证数据的一致性。

<a name="angi-1709309615609"></a>**.不可变数据的并发访问：**

<a name="pga0-1709309615611"></a>**适用措施：不可变数据结构、原子操作。**

<a name="dbat-1709309615613"></a>场景说明：当数据不会发生变化时，可以使用不可变数据结构来避免并发修改导致的数据安全问题。原子操作可以保证对不可变数据的并发访问的线程安全性。

<a name="pw5v-1709309615615"></a>**.高性能要求的并发操作：**

<a name="plv6-1709309615617"></a>**适用措施：无锁算法、并发数据结构。 -CAS乐观锁**

<a name="j4zd-1709309615619"></a>场景说明：在对性能要求较高的场景下，可以使用无锁算法或者特定的并发数据结构来提高并发操作的性能，避免因锁竞争而导致的性能下降。

<a name="pfj2-1709309615621"></a>根据具体的应用场景和需求，选择合适的并发安全措施可以保证程序的正确性、可靠性和性能。

<a name="hjak-1709309764888"></a><a name="62mg-1709309976431"></a>**互斥访问：**

<a name="0qt3-1709307350160"></a>**.互斥锁（Mutex）：**

<a name="yvog-1709307350162"></a>使用互斥锁来保护共享数据的访问，确保在同一时刻只有一个线程可以访问共享数据，其他线程需要等待锁释放后才能访问。常见的互斥锁有互斥量（Mutex）、读写锁（ReadWriteLock）等。

<a name="7xva-1709307350164"></a>**.原子操作：**

<a name="sdcn-1709307350166"></a>使用原子操作来执行对共享数据的读取和修改，确保这些操作是不可分割的，不会被其他线程中断。例如，C++中的原子操作、Java中的Atomic类。

<a name="r8cl-1709307350168"></a>**.临界区（Critical Section）：**

<a name="ctfn-1709307350170"></a>将访问共享数据的代码段包裹在临界区中，通过对临界区进行互斥保护，确保同一时刻只有一个线程可以执行临界区内的代码。

<a name="occj-1709307350172"></a>**.读写锁（ReadWrite Lock）：主要用于避免脏读**

<a name="bhqi-1709307350174"></a>使用读写锁来区分读取和修改操作。读取操作可以被多个线程同时执行，但修改操作需要互斥执行。这样可以提高读取操作的并发性能。

<a name="vej9-1709307350176"></a>**.信号量（Semaphore）：**

<a name="cbah-1709307350178"></a>使用信号量来控制并发线程的数量，限制同时访问共享资源的线程数量。通过信号量的计数值来控制资源的可用性。

<a name="ssge-1709307350180"></a>**.条件变量（Condition Variable）：**

<a name="zp3w-1709307350182"></a>使用条件变量来实现线程之间的同步和通信。当共享数据的状态发生变化时，通过条件变量通知等待的线程。

<a name="zk0j-1709307350184"></a>**.无锁算法（Lock-Free Algorithms）：**

<a name="ijop-1709307350186"></a>使用无锁算法来实现对共享数据的并发访问，避免使用互斥锁等同步机制。常见的无锁算法有CAS（Compare-And-Swap）等。

<a name="tiqo-1709307350188"></a>**.数据拷贝-写时复制（Copy-on-Write）：优化读写锁，写时复制且串行执行(锁)，读不加锁（数据库一致性备份写时复制是读备份，而这个是在备份操作防止脏读主数据）**

<a name="rhsp-1709307350190"></a>对于不可变数据结构，可以采用数据拷贝的方式来保证线程安全。当数据发生修改时，将数据进行复制，而不是直接修改原始数据。

<a name="b8ca-1709307350192"></a>**.线程安全的数据结构：**

<a name="mxvy-1709307350194"></a>使用线程安全的数据结构来替代普通的数据结构，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些数据结构已经内置了线程安全机制。

<a name="qzbb-1709307350196"></a>以上措施都可以在并发编程中用于保证数据安全，具体选择取决于应用场景、性能需求和编程语言特性。

<a name="qy4e-1709307703527"></a><a name="nyrv-1709307688718"></a>**===系统架构设计师===**

<a name="mpwu-1704949756608"></a>**系统工程与信息系统基础**

<a name="2gzz-1704980837071"></a>**.系统工程方法**

|<a name="ufly-1704951943937"></a>系统工程方法|<a name="nxus-1704951943940"></a>关键点|
| :- | :- |
|<p><a name="1laj-1704951943944"></a>霍尔三维结构</p><p><a name="sxj8-1704951943946"></a>“硬科学”方法论</p>|<p><a name="lfis-1704951943949"></a>逻辑维:逻辑维即解决问题的逻辑过程。</p><p><a name="mbik-1704951943951"></a>时间维:时间维即是工作进程。</p><p><a name="6eif-1704951943953"></a>知识维:知识维即是专业科学知识。</p><p><a name="ujck-1704951943955"></a>应用场景:组织和管理大型工程建设项目</p>|
|<p><a name="jrym-1704951943959"></a>切克兰德方法</p><p><a name="q8lv-1704951943961"></a>“软科学”方法论</p>|<p><a name="iypv-1704951943964"></a>核心不是“最优化”，而是“比较”和“探寻”</p><p><a name="ovv5-1704951943966"></a>7步骤:认识问题、根底定义、建立概念模型、比较及探寻、选择、设计与实│</p><p><a name="nbrk-1704951943968"></a>施、评估与反馈</p>|
|<a name="klwq-1704951943972"></a>并行工程方法|<p><a name="lys5-1704951943975"></a>“制造过程”与“支持过程”并行</p><p><a name="fst8-1704951943977"></a>强调三个方面:产品设计开发期间，最快速度按质完成;各项工作问题协调解决;适当的信息系统工具。</p>|
|<a name="prt1-1704951943981"></a>综合集成法|<p><a name="khme-1704951943984"></a>钱学森命名【简单系统】和【巨系统】</p><p><a name="t5z1-1704951943986"></a>四原则:整体论原则、相互联系原则、有序性原则、动态原则</p>|
|<a name="6lvr-1704951943990"></a>wSR系统方法|<a name="1mrj-1704951943993"></a>实践准则:【懂物理】–【明事理】–【通人理】|

<a name="yvug-1704980841473"></a>时间维

1、规划阶段 调研，谋求活动的规划与战略    2、拟定方案    提出具体的计划方案    3、研制阶段 完成研制方案及生产计划      

4、生产阶段生    产零部件及提出安装计划    5、安装阶段 安装完毕，完成系统的运行计划    6、运行阶段    系统按照预期的用途开展服务

7、更新阶段    改进原有系统、或消亡原有系统

逻辑维    

1、明确问题    2、确定目标    建立价值体系或评价体系    3、系统综合    4、系统分析    

<a name="bf7c-1704980841472"></a>5、优化    系统方案的优化选择    6、系统决策    7、实施计划

<a name="mk93-1704952875199"></a>**.系统工程生命周期阶段**

系统工程生命周期阶段

<a name="lrmz-1704980944545"></a>探索性研究>概念阶段>开发阶段>生产阶段>使用阶段（5年）>保障阶段>退役阶段

<a name="ny2c-1704952893636"></a>**.系统工程生命周期方法**

系统工程生命周期方法

计划驱动方法:需求->设计->构建->测试->部署  ---瀑布模型

渐进迭代式开发:提供连续交付以达到期望的系统

精益开发:起源于丰田，是一个动态的、知识驱动的，以客户为中心的过程

<a name="0u7n-1704980953163"></a>敏捷开发:更好的灵活性

<a name="shmt-1704952904062"></a>**.信息系统建设原则**

信息系统建设原则

高层管理人员介入原则    如:CIO介入

用户参与开发原则    用户确定范围、核心用户全程参与、用户深度参与

自顶向下规划原则    以此减少信息不一致的现象

工程化原则    引入【软件工程】

<a name="wtaj-1704951817591"></a>其它原则    创新性原则、整体性原则、发展性原则、经济性原则

<a name="itje-1704951812273"></a>**.信息系统开发方法**

<a name="bnzq-1705819374009"></a>**原型法**

<a name="ujj3-1705819377863"></a>**结构化法-瀑布型**

<a name="8wek-1705819398251"></a>**形式化法-数模**

<a name="jeuk-1705819392097"></a>**敏捷方法**

原型法【需求阶段】  

按功能分：水平原型（界面） 垂直原型（复杂算法-抖音视频推送）

按最终结果分：抛弃式原型       演化式原型

结构化法：面向过程-瀑布型-自顶向下

面相对象方法：抽象-自底向上

面相服务方法： 粗粒度、松耦合、标准化和构件化

其他信息系统开发方式

形式化方法： 数学模型化  飞机，芯片等物理 模型化模拟

统一过程方法【up】

敏捷方法：scrum

<a name="kf2a-1704980979092"></a>基于架构的开发方法：ABSD

<a name="w8yd-1704980881013"></a>**.信息系统分类**

<a name="hlhq-1705819204285"></a>**业务处理系统TPS**

<a name="oksn-1705819204735"></a>**管理信息系统MIS**

<a name="lwm7-1705819204736"></a>**决策支持系统DSS**

<a name="bmeu-1705819204737"></a>**专家系统ES**

<a name="kffq-1705819204738"></a>**办公自动化系统OAS**

<a name="k2px-1705819204739"></a>**企业资源系统ERP**

业务处理系统TPS： OLTP、数据库、报表  -批处理数据

管理信息系统MIS：高度集成化的人机系统    -信息源、信息处理器、信息用户、信息处理者 donphi、pascal

【管理信息系统(Manage lnformation System,MIS)】是由业务处理系统发展而成的，

是在TPS基础上引进大量管理方法对企业整体信息进行处理，并利用信息进行预测、控制、计划、辅助企业全面管理的信息系统。

MIS系统四大部件:信息源、信息处理器、信息用户和信息管理者。十

决策支持系统DSS：语言系统，知识系统和问题处理系统组成，辅助决策

[DSS应具有的特征】

(1)数据和模型是DSS的主要资源。

(2)DSS用来支援用户作决策而不是代替用户作决策。

(3)DSS主要用于解决半结构化及非结构化问题。

(4)DSS的作用在于提高决策的有效性而不是提高决策的效率。

专家系统ES: 知识+推理 。人工智能的一个重要分支

知识库:存储求解实际问题的领域知识。

综合数据库∶存储问题的状态描述、中间结果、求解过程的记录等信息。

推理机:实质是【规则解释器】。

知识获取:两方面功能:知识的编辑求精及知识自学习。

解释程序:面向用户服务的。

办公自动化系统OAS: 

<a name="ct61-1704982049404"></a>企业资源系统ERP: 供应链

<a name="f98t-1704981918920"></a>**过程模型**

<a name="yk4j-1705841608124"></a>**瀑布模型**

严格区分阶段，每个阶段因果关系紧密相连

只适合需求明确的项目

缺点： 

软件需求完整性、正确性难确定

严格串行化，很长时间才能看到结果

<a name="3qne-1705842709255"></a>瀑布模型要求每个阶段一次性完全解决该阶段工作,这不现实。

<a name="oryp-1705841608705"></a>**V模型【瀑布变种-测试贯穿】**

测试贯穿于始终

测试分阶段(测试计划提前

<a name="p0k5-1705846375566"></a>编码后开始测试倒V成V字

<a name="b0cp-1705841621350"></a>**原型模型**

适合需求不明确的项目原型模型两个阶段:

1、原型开发阶段

2、目标软件开发阶段

<a name="cqhh-1705845876255"></a>[抛弃型原型)与【演化型原型】

<a name="sfqi-1705841608707"></a>**螺旋模型【原型+瀑布 风险】**

迭代型与增量型

以快速原型为基础+瀑布模型

<a name="b7wi-1705846464151"></a>考虑了风险问题

<a name="kbjw-1705841608709"></a>**构件组装模型/基于构件的开发方法**

【优点】易扩展、易重用、降低成本、安排任务更灵活。

【缺点】构件设计要求经验丰富的架构师、设计不好的构件难重用、强调重用可能牺牲其它指标(如性能)、第三方构件质量难控制。

【示例】

方舱医院

乐高积木

基于构件的软件工程(CBSE)

CBSE体现了【购买而不是重新构造】的哲学。

(CBSE的构件应该具备的特征】

1、可组装性:所有外部交互必须通过公开定义的接口进行。

2、可部署性:构件总是二进制形式的，能作为一个独立实体在平台上运行。

3、文档化:用户根据文档来判断构件是否满足需求。

4、独立性:可以在无其他特殊构件的情况下进行组装和部署。5、标准化:符合某种标准化的构件模型。

【构件的组装】

1、顺序组装:按顺序调用己经存在的构件，可以用两个已经存在的构件来创造一个新的构件。

2、层次组装:被调用构件的“提供”接口必须和调用构件的“请求”接口兼容。

<a name="zjcw-1705846978074"></a>3、叠加组装:多个构件合并形成新构件，新构件整合原构件的功能，对外提供新的接口。

<a name="mvze-1705841627436"></a>**快速应用开发RAD【瀑布+构件组装】**

业务建模

数据建模

过程建模

应用生成

<a name="nafe-1705930248825"></a>测试与交付

<a name="xici-1705841629815"></a>**统一过程/统一开发方法**

9个核心工作流：

业务建模

需求分析与设计

实现测试部署

配置与变更管理

项目管理

<a name="rsee-1705931291257"></a>环境

<a name="9jca-1705841608711"></a>**敏捷开发方法**

敏捷宣言

√个体和交互胜过过程和工具

√可工作的软件胜过大量的文档

√客户合作胜过合同谈判

√响应变化胜过遵循计划

传统软件开发方法: 预设性的 > 以开发过程为本 > 整体分阶段

<a name="flva-1705938097079"></a>敏捷方法: 适应性的 - 以人为本 - 增量迭代，小步快跑 - 适合小型项目

<a name="28va-1705841590197"></a>**XP**

敏捷方法- XP

4大价值观

沟通【加强面对面沟通】

简单【不过度设计】

反馈【及时反馈】

勇气【接受变更的勇气】

12条过程实践规则:

简单设计 测试驱动 代码重构 结对编程 持续集成 现场客户

发行版本 小型化 系统隐喻 代码集体所有 制规划策略 规范代码

<a name="mbtp-1705938236342"></a>40小时工作机制

<a name="fyfq-1705938223773"></a>**Scrum**

.极限编程\_(XP)∶价值观【交流、朴素、反馈、勇气】、近螺旋式的开发方法。

.水晶方法:提倡“机动性”的方法，拥有对不同类型项目非常有效的敏捷过程。

.SCRUM:侧重于项目管理。

.特征驱动开发方法（FDD)∶认为有效的软件开发需要3要素【人、过程、技术】。

.定义了6种关键的项目角色:项目经理、首席架构设计师、开发经理、主程序员、程序员和领域专家。

.开放式源码:程序开发人员在地域上分布很广【其他方法强调集中办公】。

.ASD方法:其核心是三个非线性的、重叠的开发阶段:猜测合作与学习。

<a name="elzb-1705938420182"></a>.动态系统开发方法(DSDM)︰倡导以业务为核心。

<a name="d5ko-1705938215067"></a>**逆向工程**

<a name="os3c-1706090901666"></a>**实现级**

<a name="irxb-1706090905276"></a>**结构级**

<a name="rk8d-1706090908958"></a>**功能级**

<a name="k3pt-1706090912460"></a>**领域级**

现有工程 - 再工程  -新系统   

逆向工程是设计的恢复过程。

\------

实现级:包括程序的抽象语法树、符号表、过程的设计表示

结构级:包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构

功能级:包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型

领域级∶包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型

与逆向工程相关的概念有重构、设计恢复、再工程和正向工程。

(1）重构/重组(Restructuring)。重构是指在【同一抽象级别】上【转换系统描述形式】。

(2）设计恢复(Design recovery)。设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。

(3)逆向工程(Reverse engineering):逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程。

(4）正向工程（Forward engineering)。正向工程是指不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，以改善其整体质量。

<a name="efxo-1705938813039"></a>(5）再工程/重构工程(Re-engineering)。再工程是对现有系统的重新开发过程，包括逆向工程、新需求的考虑过程和正向工程三个步骤。

<a name="tybd-1705938215235"></a>**净室软件工程**

√净室即无尘室、洁净室。也就是一个受控污染级别的环境。

√使用盒结构规约（或形式化方法)进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制。

√使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息。

-- 举例前端的 拖拽式功能框

【技术手段】

√统计过程控制下的增量式开发:控制迭代

√基于函数的规范和设计:盒子结构

`    `定义3种抽象层次:行为视图(黑盒)->有限状态机视图（状态盒)->过程视图（明盒/白盒)

√正确性验证:净室工程的核心

√统计测试和软件认证:使用统计学原理，总体太大时必须采用抽样方法

【缺点】

√太理论化，正确性验证的步骤比较困难且耗时。

√开发小组不进行传统的模块测试，这是不现实的。

<a name="iesl-1705939167964"></a>√脱胎于传统软件工程，不可避免带有传统软件工程的一些弊端。

<a name="ochn-1705940085547"></a>**需求工程**

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。  -需求开发

【需求工程主要活动的阶段划分】

需求获取

需求分析

形成需求规格【形成SRS】

需求确认与验证【形成需求基线(经过评审的SRS)】

需求管理【变更控制、版本控制、需求跟踪、需求状态跟踪】

<a name="nlvu-1705940085546"></a>需求管理是对【需求基线】进行管理

<a name="xdlf-1705940054108"></a>**.需求获取**

<a name="s1uq-1706090846730"></a>**用户面谈** 

<a name="vuil-1706090851858"></a>**联合需求计划(JRP)** 

<a name="gpxg-1706090851859"></a>**问卷调查** 

<a name="mg9n-1706090851860"></a>**现场观察**   

<a name="3ww6-1706090851861"></a>**原型化方法**        

<a name="0awr-1706090851863"></a>**头脑风暴法**

软件需求获取方法

用户面谈 - 需求专题讨论会(JRP) - 问卷调查 - 现场观察 - 原型化方法 - 头脑风暴法

分层

√业务需求()整体全局)

√用户需求用户视角

√系统需求(计算机化)   -功能需求  -性能需求(非功能)  -设计约束

项目管理维度QFD

√基本需求(明示，常规需求)

√期望需求（隐含)

√兴奋需求(多余)

`    `方法                                    特点

用户面谈                1对1-3，有代表性的用户，了解主观想法，交互好。成本高，要有领域知识支撑。

联合需求计划(JRP)        高度组织的群体会议，各方参与，了解想法，消除分歧，交互好，成本高。

问卷调查                用户多，无法一一访谈，成本低。

现场观察                针对较为复杂的流程和操作。

原型化方法               通过简易系统方式解决早期需求不确定问题。

<a name="jvim-1705940257086"></a>头脑风暴法               一群人围绕新业务，发散思维,不产生新的观点。

<a name="axny-1705940052332"></a>**.需求分析**

<a name="v8wz-1706090812929"></a>**1.功能模型(数据流图DFD)**

<a name="3uls-1706090814821"></a>**2.行为模型(状态转换图)**

<a name="69df-1706090816407"></a>**3.实体模型(E-R图)**

需求工程-需求开发-需求分析- SA(DFD)

数据字典 数据元素-数据结构-数据流-数据存储-加工逻辑-外部实体

功能模型(数据流图DFD):数据流-加工-数据存储-外部实体

行为模型(状态转换图)：  状态(初态、终态)-事件

<a name="ovab-1705940661004"></a>实体模型(E-R图):  实体-联系

<a name="loq2-1705940640473"></a>**UML**

UML(统一建模语言)︰平台无关、语言无关。

结构事物:最静态的部分，包括:类、接口、协作、用例、活动类、构件和节点。

\>行为事物:代表时间和空间上的动作。包括:消息、动作次序、连接。

\>分组事物:看成是个盒子，如:包、构件。

\>注释事物:UML模型的解释部分。描述、说明和标注模型的元素。

动态图(行为图)

用例图:系统与外部参与者的交互

顺序图:强调按时间顺序

通信图(协作图)

状态图:状态转换变迁

活动图:类似程序流程图，并行行为

定时图:强调实际时间

交互概览图

静态图(结构图)

类图:一组类、接口、协作和它们之间的

关系对象图:一组对象及它们之间的关系

构件图:一个封装的类和它的接口

部署图:软硬件之间映射

制品图:系统的物理结构

·包图:由模型本身分解而成的组织单元，以及它们之间的依赖关系

·组合结构图

系统分析、设计人员                        程序员

逻辑视图(logical view)            实现视图(implementation view)

类与对象                           物理代码文件和组件 

系统集成人员                                系统和网络工程师

进程视图(process view)                部署视图(deployment view)    

<a name="ygog-1706091052296"></a>线程、进程、并发                            软件到硬件的映射

<a name="4aeg-1706091062964"></a>**需求定义**

严格定义法：

√所有需求都能够被预先定义

√开发人员与用户之间能够准确而清晰地交流

√采用图形/文字可以充分体现最终系统

原型法：

√并非所有的需求都能在开发前被准确的说明

√项目参加者之间通常都存在交流上的困难

√需要实际的、可供用户参与的系统模型

√有合适的系统开发环境

<a name="xyp0-1706092631364"></a>√反复是完全需要和值得提倡的，需求一旦确定，就应遵从严格的方法

<a name="ud2s-1706090947930"></a>**需求验证**

SRS:

需求评审  正式评审>非正式评审

需求测试

<a name="yies-1706092882866"></a>用户签字>确认验收标准之一

<a name="l03x-1705940634470"></a>**需求跟踪**

<a name="muqf-1706093218719"></a>**需求变更管理**

识别出问题

`    `问题分析和变更描述

`        `变更分析和成本计算   CCB

<a name="g9hm-1706093512613"></a>             变更实现  > 修改后的需求

<a name="ilpb-1706093190683"></a>**软件系统建模**

<a name="j396-1706094675778"></a>**软件界面设计**

黄金三法则

★置于用户控制之下

·以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式

·提供灵活的交互

·允许用户交互可以被中断和撤销

.当技能级别增加时可以使交互流水化并允许定制交互

·使用户隔离内部技术细节

·设计应允许用户和出现在屏幕上的对象直接交互

★减少用户的记忆负担

.减少对短期记忆的要求

·建立有意义的缺省

·定义直觉性的捷径

·界面的视觉布局应该基于真实世界的隐喻

·以不断进展的方式揭示信息

★保持界面的一致性

·允许用户将当前任务放入有意义的语境

·在应用系列内保持一致性

<a name="zy6c-1706094832554"></a>·如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要改变它

<a name="vqsk-1706094478028"></a>**结构化设计**

概要设计【外部设计】︰功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图

详细设计【内部设计】︰为每个具体任务选择适当的技术手段和处理方法

结构化设计原则:

模块独立性原则(高内聚、低耦合)

·保持模块的大小适中

·多扇入，少扇出       模块A扇入3(高复用)，扇出2(高依赖)       1>A 2>A 3>A  A<4 A<5  -高扇入即A被多个函数调用，复用率高good; 高扇出A调用多个函数，系统复杂性不可预见性增加；

<a name="upqt-1706095030525"></a>·深度和宽度均不宜过高

<a name="jczo-1706095018132"></a>**内聚**

内聚类型(由高到低)                描述

功能内聚    完成一个单一功能,各个部分协同工作，缺一不可

顺序内聚    处理元素相关,而且必须顺序执行

通信内聚    所有处理元素集中在一个数据结构的区域上

过程内聚    处理元素相关，而且必须按特定的次序执行

时间内聚    所包含的任务必须在同一时间间隔内执行  (瞬时内聚)

逻辑内聚    完成逻辑上相关的一组任务

<a name="snap-1706095411069"></a>偶然内聚    完成一组没有关系或松散关系的任务  (巧合内聚)

<a name="qa8z-1706095402118"></a>**耦合**

耦合类型（由低到高）        描述

非直接耦合  两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的

数据耦合    

标记耦合    一组模块借助参数表传递简单数据

控制耦合    一组模块通过参数表传递记录信息(数据结构

外部耦合    模块之间传递的信息中包含用于控制模块内部逻辑的信息一组模块都访问同一全局简单变量，而且不是通过参数表传递该全局变量的信息

公共耦合    多个模块都访问同一个公共数据环境

<a name="yov0-1706095508310"></a>内容耦合    一个模块直接访问另一个模块的内部数据;一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠;一个模块有多个入口

<a name="g1dc-1706095391028"></a>**模块四要素**

模块的四个要素

输入和输出:模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。

处理功能:指模块把输入转换成输出所做的工作。

内部数据:指仅供该模块本身引用的数据。

<a name="j80k-1706095890170"></a>程序代码:指用来实现模块功能的程序。

<a name="ydwa-1706095870710"></a>**面相对象设计**

<a name="fouz-1706095958643"></a>**类的分类**

边界类：机器接口-API接口、人机交互-用户界面

`    `例:显示屏、窗体、打印机接口、、通信协议、对话框、菜单、购物、车、报表、二维码

控制类: 应用逻辑、业务逻辑、数据访问逻辑

`    `例:身份验证器

实体类：数据

<a name="fa2r-1706096021041"></a>    例:学员类、课程类

<a name="9pd1-1706095996137"></a>**基本过程**

分析模型            设计师            设计模型

用例模型        设计用例实现方案    架构图(用包图表示)

`                `设计技术支撑实施    用例实现图(用交互图表示)

`                `设计用户界面        类图（完整、精确)

分析模型        细化设计模型            其他（状态图、活动图等)l

<a name="tdyn-1706096267080"></a>(领域模型)

<a name="k8lc-1706096001163"></a>**设计原则(同设计模式)**

★单一职责原则:设计目的单一的类

★开放-封闭原则:对扩展开放，对修改封闭

★李氏(Liskov)替换原则:子类可以替换父类    泛化/继承

★依赖倒置原则:要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程

★接口隔离原则:使用多个专门的接口比使用单一的总接口要好

★组合重用原则:要尽量使用组合，而不是继承关系达到重用目的

<a name="we2w-1706096471101"></a>★迪米特(Demeter)原则（最少知识原则)︰一个对象应当对其他对象有尽可能少的了解（信息隐蔽，避免绕过接口）

<a name="qvol-1706095952165"></a>**计算机**

<a name="ef1b-1706108352037"></a>**计算机结构(★)**

CPU

运算器

算术逻辑单元ALU:数据的算术运算和逻辑运算

累加寄存器AC:通用寄存器，为ALU提供一个工作区，用在暂存数据数据

缓冲寄存器DR:写内存时，暂存指令或数据

状态条件寄存器PSW:存状态标志与控制标志(争议:也有将其归为控制器的)

控制器

程序计数器PC:存储下一条要执行指令的地址

指令寄存器IR:存储即将执行的指令

指令译码器ID:对指令中的操作码字段进行分析解释

<a name="2tuf-1706108642011"></a>时序部件:提供时序控制信号

<a name="4kj7-1706108373776"></a>**存储系统(★★★★)**

<a name="ucta-1706109825295"></a>**层次化存储结构**

<a name="j9hn-1706109828962"></a>**Cache**

<a name="pv51-1706109847372"></a>**主存编址计算**

层次化存储结构

CPU:寄存器

Cache:按内容存取(相联存储器)

内存(主存):DRAM

外存(辅存):硬盘、光盘、U盘等

Cache  -高命中率+快速访问能力  -L1、L2cache 高速缓存器

√ Cache的功能:提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。

√在计算机的存储系统体系中，Cache是访问速度最快的层次。  

√Cache对程序员来说是透明的。  -硬件相关，与程序员无法操作

√使用Cache改善系统性能的依据是程序的局部性原理。

√时间局部性:指程序中的某条指令一旦执行，不久以后该指令可能再次执行，典型原因是由于程序中存在着大量的循环操作。 -循环

√空间局部性:指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，

其典型情况是程序顺序执行。                -索引局部性

√工作集理论:工作集是进程运行时被频繁访问的页面集合。

主存编址计算

存储单元：存储单个数=最大地址最小地址1 

编址内容：

按字编址存储体的存储单元是存储单元，即最小寻址单位是一个字

按字节编址存储体的存储单元是字节存储单元，即最小寻址单位是一个字节。

总容量=存储单元个数\*编址内容

根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出所需芯片的总数，即:

<a name="nfaa-1706109451658"></a>        总片数总容量/每片的容量

<a name="jcqv-1706108377026"></a>**磁盘基本结构与存储过程**

<a name="gnlm-1706111292670"></a>存取时间=寻道时间+等待时间，寻道时间是指磁头移动到磁道所需的时间;等待时间为等待读写的扇区转到磁头下方所用的时间。

<a name="puux-1706111215530"></a>**磁盘优化分布存储**

<a name="dvin-1706111222861"></a>**磁盘单缓冲区与双缓冲区读取**

<a name="jr2r-1706111239137"></a>**磁盘移臂调度算法**

先来先服务(FCFS)

最短寻意时间优先(SSIE)

扫描算法(SCAN) -电梯算法

<a name="eh8a-1706113646563"></a>循环扫描(CSCAN)算法

<a name="sz2k-1706111188014"></a>**数据传输控制方式（★)**

I/O

√程序控制(查询)方式:分为无条件传送和程序查询方式两种。方法简单，硬件开销小，但I/O能力不高，严重影响CPU的利用率。

√程序中断方式:与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度。

<a name="ox7i-1706114676724"></a>√DMA方式:DMA方式是为了在主存与外设之间实现高速、批量数据交换而设置的。DMA方式比程序控制方式与中断方式都高效。

<a name="cbul-1706108378755"></a>**总线（★★)**

√总线是一组能为多个部件分时共享的公共信息传送线路。

`    `·共享

`    `·分时:是指同一时刻仅允许一个部件向总线发送信息，但允许多个部件同时从总线上接收相同的信息。

√串行总线(适合长距离传输)与并行总线(适合近距离连接，不宜过长)√单工、半双工与全双工

√总线宽度与总线带宽

总线的分类:

数据总线(Data Bus,DB)︰在CPU与RAM之间来回传送需要处理或是需要储存的数据。

地址总线(Address Bus，AB)︰用来指定在RAM (Random AccessMemory)之中储存的数据的地址。

<a name="ohwy-1706118513285"></a>控制总线(Control Bus，CB)∶将微处理器控制单元(Control Unit)的信号，传送到周边设备。

<a name="0hb5-1706108373778"></a>**CISC与RISC(★)**

<a name="ernn-1706108380109"></a>**流水线(★★)**

相关参数计算:流水线执行时间计算、流水线吞吐率、流水线加速比等。

流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，

<a name="ssri-1706118953399"></a>它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度

<a name="grix-1706108381278"></a>**校验码(★)**

<a name="1p2v-1706108382511"></a>**嵌入式（★)**

<a name="8vmt-1706198382356"></a>**计算机网络**

网际互连协议(IP,Internet Protocol)

传输控制协议(TCP,Transmission Control Protocol)  长连接3次握手

<a name="mucg-1706198453540"></a>用户数据报协议(UDP，User Datagram Protocol)       扔数据包

<a name="a4es-1706106975412"></a>**TCP/IP协议族(7层/4层网络模型)**

OSI七层模型    TCP/IP模型

应用层            -                POP3：110 

表示层            应用层            FTP：20/21    HTTP:80    DHCP：67     TFTP：69

会话层            -                Telnet：23    SMTP：25 简单邮件    SNMP：161     DNS：53

传输层            传输层            TCP    UDP

网络层            网际层            IP  ICMP    IGMP    ARP    RARP

数据链路层        网络接口层

物理层            -                CSMA/CD    TokingRing

TCP/IP协议族

POP3: 110端口，邮件收取

SMTP:25端口，邮件发送

FTP:20数据端口/21控制端口，文件传输协议

HTTP:80端口，超文本传输协议，网页传输

DHCP:67端口，IP地址自动分配

SNMP: 161端口，简单网络管理协议

DNS:53端口，域名解析协议，记录域名与IP的映射关系

TCP:可靠的传输层协议

UDP:不可靠的传输层协议

ICMP:因特网控制协议，PING命令来自该协议IGMP:组播协议 - trace

ARP:地址解析协议，IP地址转换为MAC地址

<a name="cgyp-1706249614651"></a>RARP:反向地址解析协议，MAC地址转lP地址

<a name="vwim-1706198561289"></a>**.TCP与UDP (★★★)**

共同点：基于IP协议的传输层协议，可以端口寻址

不同点:             

TCP -面向连接（连接管理)、三次握手、流量控制-滑动窗口限流、差错校验和重传、IP数据报按序接收(不  丢失、不重复)、可靠性强、牺牲通信量、效率低                         

UDP -不可靠、无连接、错误检测功能弱，无拥塞控制、无流量控制， 有助于提高传输的高速率性。

`     `不对无序IP数据报重新排序、不负责重传、不消除重复IP数据报、不对已收到的数据报进行确认、不负责建立或终止连接，

`     `这些由UDP进行通信的应用程序进行处理。



相关协议:

TCP - HTTP、FTP、Telnet、POP3、SMTP

<a name="2nxi-1706256522084"></a>UDP - DNS、DHCP、TFTP、SNMP

<a name="imsh-1706198537828"></a>**.DHCP与DNS (★★★)**

主机向本地域名服务器的查询采用递归查询。

本地域名服务器向根域名服务器的查询通常采用迭代查询。

域名解析链路：

`    `域名  - 本地host-缓存-（递归查询）本地域名服务器 dns.xyz.com -    

`                `（迭代查询，全球仅几台）3根域名服务器 / 4顶级域名服务器  / 5权限域名服务器



递归查询:服务器必需回答自标IP与域名的映射关系

迭代查询:服务器收到一次迭代查询回复一次结果，这个结果不一定是目标IP与域名的映射关系,也可以是其它DNS服务器的地址。

浏览器输入域名 ： HOSTS→本地DNS缓存→本地DNS服务器→根域名服务器→顶级域名服务器→权限域名服务器。

主域名服务器接收到域名请求 ：   本地缓存记录→区域记录→转发域名服务器→根域名服务器。

动态主机配置协议(DHCP，Dynamic Host Configuration Protocol)

1、客户机/服务器模型2、租约默认为8天

3、当租约过半时，客户机需要向DHCP服务器申请续租;

4、当租约超过87.5%时，如果仍然没有和当初提供IP的DHCP服务器联系上则开始联系其他的DHCP服务器。

5、分配方式

固定分配(管理员分配静态绑定固定的IP地址)

动态分配（为客户端分配租期为无限长的IP地址)

自动分配（为客户端分配具有一定有效期限的IP地址)

<a name="oikq-1706256859327"></a>6、无效地址:169.254.X.X和0.0.0.0

<a name="u7sd-1706198559304"></a>**网络规划与设计**

<a name="nov8-1706198591905"></a>**1.逻辑设计与物理设计(★★★★）**

网络规划与设计-逻辑网络设计

逻辑网络设计是体现网络设计核心思想的关键阶段，在这一阶段根据需

求规范和通信规范，选择一种比较适宜的网络逻辑结构，并基于该逻辑结构实施后续的资源分配规划、安全规划等内容。利用需求分析和现有网络体系分析的

结果来设计逻辑网络结构，最后得到一份逻辑网络设计文档。

逻辑网络设计工作主要包括以下内容:

(1）网络结构的设计

(2）物理层技术的选择

3）局域网技术的选择与应用

(4)广域网技术的选择与应用

(5)地址设计和命名模型

(6）路由选择协议

(7)网络管理

(8）网络安全

(9)逻辑网络设计文档

输出内容包括以下几点:

.逻辑网络设计图

.IP地址方案

.安全管理方案

.具体的软/硬件、广域网连接设备和基本的网络服务

.招聘和培训网络员工的具体说明

.对软/硬件费用、服务提供费用、员王和培训的费用初步估计

网络规划与设计–物理网络设计

物理网络设计是对逻辑网络设计的物理实现，通过对设备的具体物理分布、运行环境等确定，确保网络的物理连接符合逻辑连接的要求。

在这一阶段，网络设计者需要确定具体的软/硬件、连接设备、布线和服务的部署方案，

输出如下内容:

.网络物理结构图和布线方案

.设备和部件的详细列表清单

.软硬件和安装费用的估算

.安装日程表，详细说明服务的时间以及期限

.安装后的测试计划

<a name="1jly-1706257567932"></a>.用户的培训计划

<a name="sy2g-1706198599196"></a>**2.层次化网络设计**

核心层:主要是高速数据交换，实现高速数据传输、出口路由，常用冗余机制。

汇聚层∶网络访问策略控制、数据包处理和过滤、策略路由、广播域定义、寻址。

<a name="notp-1706257986732"></a>接入层:主要是针对用户端，实现用户接入、计费管理、MAC地址认证、MAC地址过滤、收集用户信息,可以使用集线器代替交换机。

<a name="igl7-1706257923205"></a>**3.网络冗余设计**

在网络冗余设计中，对于通信线路常见的设计目标

主要有两个:

`    `备用路径

`    `负载分担。

备用路径，提高可用性,由路由器、交换机等设备之间的独立备用链路构成，一般情况下备用路径仅仅在主路径失效时投入使用。

设计时主要考虑:

(1）备用路径的带宽

(2)切换时间

(3）非对称

(4）自动切换

(5）测试

负载分担,是对备用路径方式的扩充,通过并行链路提供流量分担(冗余的形式)来提高性能，主要的实现方法是利用两个或多个网络接口和路径来同时传递流量，

设计时注意考虑:

.网络中存在备用路径、备用链路时,可以考虑加入负载分担设计

.对于主路径、备用路径都相同的情况,可以实施负载分担的特例—负载均衡

<a name="hmbb-1706259541284"></a>.对于主路径、备用路径不相同的情况,可以采用策略路由机制，让一部分应

<a name="zkxb-1706257899477"></a>**网络存储（★★)**

分类

直连式存储(DAS，Direct-Attached Storage)

网络附加存储(NAS，Network-Attached Storage)

存储区域网络(SAN，Storage Area Network)

Internet小型计算机系统接口（iSCSl，Internet Small Computer System Interface)

DAS/SAS: 通过SCSI连接到服务器，本身是硬件的堆叠，不带有任何操作系统。存储器必须被直接连接到应用服务器上，不能跨平台共享文件，

`        `各系统平台下文件分别存储。

NAS: 通过网络接口与网络直接连接，由用户通过网络访问(支持多种TCP/IP协议)。NAS设备有自己的OS，类似于一个专用的文件服务器，

`        `一般存储信息采用RAID进行管理。即插即用。

SAN: 通过专用高速网络将一个或多个网络存储设备和服务器连接起来的专用存储系统，采用数据块的方式进行数据和信息的存储。

`        `目前主要使用以太网(IP SAN)和光纤通道(FC SAN)两类环境。

<a name="e8rr-1706259655613"></a>IP-SAN/iSCSI : 基于IP网络实现,设备成本低，配置技术简单，可共享和使用大容量的存储空间。

<a name="fxma-1706198636789"></a>**磁盘阵列Raid**

磁盘阵列(RAID，Redundant Arrays of Independent Disk)

Raid0(条块化):性能最高，并行处理，无冗余，损坏无法恢复

Raidl(镜像结构):可用性，可修复性好，仅有50%利用率

RaidO+1(Raid10): Raid0与Raidl长处的结合，高效也可靠

Raid3(奇偶校验并行传送):N+1模式，有固定的校验盘，坏一个盘可恢复

Raid5(分布式奇偶校验的独立磁盘):N+1模式，无固定的校验盘，坏一个盘可恢复

<a name="zf39-1706259856625"></a>Raid6(两种存储的奇偶校验):N+2模式，无固定的校验盘，坏两个盘可恢复

<a name="vlem-1706259832461"></a>**lPv6 (★)**

IPv6是设计用于替代现行版本lP协议(IPv4)的下一代IP协议。

(1）寻址能力方面的扩展。IPv6地址长度为128位，地址空间增大了2的96次方倍;

(2）灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPv4中可变长度的选项字段。IPv6中选项部分的出现方式也有所变化，

使路由器可以简单路过选项而不做任何处理，加快了报文处理速度;

(3)IPv6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量;

(4）提高安全性。身份认证和隐私权是IPv6的关键特性;

(5）支持更多的服务类型;

(6)允许协议继续演变，增加新的功能，使之适应未来技术的发展;

IPv6地址由8个16进制字段构成。例如:

2001:0db8:85a3:0000:1319:8a2e:0370:7344

lPv6地址的省写，上面的IP地址等价于:

2001:0db8:85a3.:1319:8a2e:0370:7344。

遵守这些规则，如果因为省略而出现了两个以上的冒号，则可以压缩为一个，

但这种零压缩在地址中只能出现一次。因此:

2001:0DB8:0000:0000:0000:0000:1428:57ab2001:0DB8:0:0:0:0:1428:57ab

2001:0DB8::1428:57ab

2001:DB8::1428:57ab

以上都是合法的地址，并且它们是等价的。同时前导的零可以省略，因此:

2001:0DB8:02de::Oe13等价于2001:DB8:2de:e13。

·单播地址(Unicast):用于单个接口的标识符，传统的点对点通信。

·组播地址(Multicast):多播地址，一点对多点的通信，数据包交付到一组计算机中的每一个。IPv6没有广播的术语，而是将广播看做多播的一个特例。

.任播地址(Anycast):泛播地址，这是IPv6增加的一种类型。任播的目的站是一组计算机，但数据包在交付时只交付给其中一个，通常是距离最近的一个。

多播:前缀为11111111

任播:前缀固定，其余位置为0

单播

·可聚合全球单播地址:前缀001。

.本地单播地址:

`    `链路本地:前缀为1111111010 (一般以fe80开头)

`    `站点本地:前缀为1111111011

lPv6规定每个网卡最少有3个IPv6地址，分别是链路本地地址、全球单播地址和回送地址(站点本地地址)。

lPv6把自动IP地址配置作为标准功能，只要计算机连接上网络便可自动f分配IP地址。

√全状态自动配置(Stateful Auto-Configuration): IPv6继承了IPv4动态主机配置协议(DHCP）这种自动配置服务。

√无状态自动配置(Stateless Auto-Configuration):主机通过两个阶段分别获得链路本地地址和可聚合全球单播地址。

.首先主机将其网卡MAC地址附加在链路本地地址前缀11111111010之后，产生一个链路本

地地址，发出一个ICMPv6邻居发现请求，验证其地址唯一性。不唯一则便用随机接口ID组成一个新的链路本地地址。

.主机以链路本地地址为源地址，向本地链路中所有路由器的组播ICMPv6路由器请求报文并返回一个包含可聚合全球单播地址前缀的路由器公告报文响应。

该地址前缀加上自己的接口ID，自动配置一个全球单播地址。使用无状态自动配置，无须用户手工干预就可以改变主机的IPv6地址。

lPv4/ IPv6过渡技术有:

(1）双协议栈技术:双栈技术通过节点对IPv4和IPv6双协议栈的支持，从而支持两种业务的共存。

(2）隧道技术:隧道技术通过在IPv4网络中部署隧道，实现在IPv4网络上对IPv6业务的承载，保证业务的共存和过渡。

隧道技术包括:

6to4隧道；

6over4隧道;

ISATAP隧道。

<a name="cfbw-1706259967110"></a>(3)NAT-PT技术: NAT一PT使用网关设备连接IPv6和IPv4网络。当IPv4和IPv6节点互相访问时，NAT一PT网关实现两种协议的转换翻译和地址的映射。

<a name="g438-1706198637653"></a>**网络接入(有线/无线)**

有线接入：

公用交换电话网络(PSTN)

数宁数据网(DDN)

综合业务数字网(ISDN)

非对称数字用户线路(ADSL)

同轴光纤技术(HFC)

无线接入：

IEEE 802.11(WiFi)

IEEE 802.15(蓝牙Bluetooth)

红外(IrDA)

WAPI

<a name="wbb7-1706260463027"></a>1G~5G

<a name="lxli-1706198497856"></a>**综合布线(★)**

.工作区子系统由信息插座、插座盒、连接跳线和适配器组成。

.水平子系统由一个工作区的信息插座开始，经水平布置到管理区的内侧配线架的线缆所组成。

.管理子系统由交连、互连配线架组成。管理子系统为连接其它子系统提供连接手段。

.垂直干线子系统由建筑物内所有的垂直干线多对数电缆及相关支撑硬件组成，

`    `以提供设备间总配线架与干线接线间楼层配线架之间的干线路由。

.设备间子系统是由设备间中的电缆、连接器和有关的支撑硬件组成，

`    `作用是将计算机、PBX、摄像头、监视器等弱电设备互连起来并连接到主配线架上。

.建筑群子系统将一个建筑物的电缆延伸到建筑群的另外一些建筑物中的通信设备和装置上，是结构化布线系统的一部分，

<a name="3phi-1706275430215"></a>    支持提供楼群之间通信所需的硬件。它由电缆、光缆和入楼处的过流过压电气保护设备等相关硬件组成，常用介质是光缆。

<a name="5dlt-1706198650540"></a>**网络技术扩展**

<a name="jgll-1706198586849"></a>**物联网(IOT)**

物联网(The Internet of Things）是实现物物相连的互联网络 IOT

其内涵包含两个方面:

.物联网的核心和基础仍然是互联网，是在互联网基础上延伸和扩展的网络;

.其用户端延伸和扩展到了任何物体与物体之间，使其进行信息交换和通信

.感知层:识别物体、采集信息。如:二维码、RFID、摄像头、传感器(温度、湿度)

.网络层:传递信息和处理信息。通信网与互联网的融合网络、网络管理中心、信息中心和智能处理中心等

.应用层:解决信息处理和人机交互的问题

关键技术--RFID QRcode

射频识别技术\_(Radio Frequency ldentification，RFID),又称电子标签，是一种通信技术，可通过无线电讯号识别特定目标并读写相关数据，

而无需识别系统与特定目标之间建立机械或光学接触。该技术是物联网的一项核心技术,很多物联网应用都离不开它

RFID的基本组成部分通常包括:标签、阅读器、天线。

二维码是用某种特定的几何图形按一定规律在平面(二维方向上）分布的黑白相间的图形记录数据符号信息的。在代码编制上巧妙地利用构成计算机

内部逻辑基础的“O”、 “1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信

息自动处理.

二维条码中，常用的码制有:Data Matrix，Maxi Code，Aztec,QR Code，Vericode,PDF417,Ultracode，Code 49，Code 16K

.若采用扩展的字母数字压缩格式,可容纳1850个字符

.若采用二进制/ASCII格式,可容纳1108个字节

<a name="xro7-1706275865320"></a>.若采用数字压缩格式，可容纳>710个数字

<a name="pr8x-1706198586851"></a>**云计算(Saas/Paas/Iaas)**

云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需提供给计算机和其他设备。云其实是网络、互联网的一种比喻说法。

云计算的核心思想，是将大量用网络连接的计算资源统一管理和调度，构成一个计算资源池向用户按需服务。提供资源的网络被称为“云”。

狭义云计算指IT基础设施的交付和使用模式，指通过网络以按需、易扩展的方式获得所需资源;广义云计算指服务的交付和使用模式，指通过网络以按需、

易扩展的方式获得所需服务。这种服务可以是IT和软件、互联网相关，也可是其他服务

特点:

.集合了大量计算机，规模达到成千上万

.多种软硬件技术相结合

.对客户端设备的要求低

.规模化效应

√软件即服务(SaaS)    -软件

√平台即服务(PaaS)       -二次开发

<a name="824i-1706275570096"></a>√基础设施即服务(laaS)   -硬件

<a name="1rnn-1706941312871"></a>**===系统架构设计case===**

<a name="nm5q-1706969255961"></a>**google L5设计一个分布式数据库架构**

DESIGN-A DISTRIBUTED DATABASE

RESOURCES:

-taken ·from-somebody's real -google system-design-interview

REQUIREMENTS:

--distributed database

-specify stuff like isolation- level, transactions support,consistency-level

variations:

\1) Read-heavy

\2) write-heavy

\3) Total ordering and heavy writes for ticketmaster/"flashsale"

Most use cases are read-heavy

\------

snapshot isolation

multi-version concurrency control 

use-some- "version-vectors"?

Does it·make sense to have a separate coordinator for all of the shards?-(Like ZooKeeper)

or-does the: request - router - handle coordinating the-shards?

\==========================

write-heavy or read-heavy

read-heavy

B-tree

single-leader

DynamoDB/spanner style 

snapshot isolation

multi-version concurrency control

use some "version vectors""?

aim for sequential consistency

write-heavy

LSM-tree 

leaderless

cassandra/riak/scylla styled

cosmos DB is also some inspiration  here

probably still-snapshot isolation & multi-version concurrencycontrol

( requestrouter stuff might be -different)

just-aim for causal-consistency,

and do risk & cosmos DB's write conflict resolution specifying thing

ticketmaster/distributed linked list/"flash sale" oriented DBwrite-heavy and total ordering is important)

meaning aim for sequential consistency

BUT,we're super write-heavy

single-leader

LSM-tree


<a name="fug2-1707454709063"></a>request router is likely going to stay looking like theread-heavy approach

<a name="g7yu-1707229908505"></a>**.what is total ordering(ordering first 100 custormer)**

Can- you explain -whats total ordering use case briefly?

ordering all the records of the database, for example: flashsales on amazon.com  - first 100 customers will be luckers to get free iphone;  

fairness"

I am going to be using  "weak fairness"

which is the difference between"sequential consistency" and"linearizability - seattle to your IDC 100km, be later 5 sec than others which approach your IDC;

there's actually multiple there.jepsen.io/consistency

------by the way----

distributed system node serizability rank

https://jepsen.io/consistency  

when network down

Total Available

Sticky Available

<a name="qzxn-1707454693080"></a>Unavailable

<a name="ebxf-1707230056989"></a>**.why single leader()**

why single-leader?

simplifies write conflicts

concurrent-writes are imposssible when PostgreSQL is set to serializable-isolation-level

zookeeper -and- etcd or-strongly consistent- KV storesetcd is used by kubernetes internally

<a name="llq0-1707455190492"></a>aim for sequential consistency

<a name="ttmg-1707230034624"></a>**.request router**

\- my opinion is that it is likely mycat;

"request router"

`             `strong consistent kv store(cassadra)

`                             `|

client   -        "request router"    -    (partion1) postgreSQL shard(leader node)  -  sychronus read raplica(follower) -gossinping  read raplic

`                                                `|

`                                           `(partion2) postreSQL shard(leader)     



Strong Read Consistency  :  do request to leader, leader will expi

<a name="tuet-1707455232935"></a>Eventual Consistyency  : do request to  raplica

<a name="aftd-1707229925082"></a>**.variations**

<a name="uk2k-1707457488655"></a>**1.Failover handing**

<a name="btbd-1707457496651"></a>**2.Reblancing after new node added**

<a name="moaq-1707457524278"></a>**3.Leaderless for heavy write-shard**

<a name="wyvq-1707458882987"></a>**4.TicketMasler (and total ordering is necessary**

variations 1-Failover handling

1\.detect the failur

`    `From "Database leader->"phi accruar

2\.do the leader election and switch over to the new leader

1\.detect the failur

2\.prmote The syrchronous read replica(this is our leader election we're doing the 'ring') in the kv store

variation 1 reblancing after new node added

1\.start gossiping data over to the new machines

2\.the machines become sychronuse read replica 

`    `for the partition that they should be promoted to 'leader' of

3\.promotes one of the machines to 'leader' (in kv store)

4\.it is now being router write request;

variation 2 leaderless for heavy write (No total ordering support only causal consistency)

write scenario: wirte to machine 1 ,machine 2

`    `gossiping -> concurrent write is detected!! now we have to do a write conflict resolution

`    `under Last-Write-Win. you just take the write from machine 2 . and that becomes the value on both machines(cassandre dose this)

`    `with  cosmosDB and (IIRC) Riak, you can specify the conflict resolution strategy instead of the defualt of LWW



FOR-THIS-SCENARIO,

basically just follow Variation· 1, but-shard the hell out of.it( fewer read: replicas necessary)

and use· LSM-trees

and - use the serializable isolation level on each leader node

Variation 3-TicketMasler (and total ordering is necessary)->just copy variation 1 but with tollowing changes

-use LSMM-trees

\- fewer read replicas necessary- shard the hell out of it

<a name="m8yp-1706969251706"></a>- seriazation isolation level



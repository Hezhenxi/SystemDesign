# 系统设计与优化&amp;DDIA :see_no_evil:
## 目录

<a name="3060-1621846615933"></a><a name="u5gn-1706276342372"></a>[一.数据库设计](#jeyl-1677787446995)

<a name="yew3-1706276342374"></a>[1. 关系型数据库](#5hya-1677787446996)

<a name="6c0u-1706276342377"></a>[.E-R图，由台湾工程师提出的设计概念](#ohc5-1621692571287)

<a name="fcxv-1706276342379"></a>[.流程图-业务逻辑相关，系统用户动作。抽象出E-R图](#5ocb-1645598528868)

<a name="9zjr-1706276342381"></a>[1.1 E-R图 ](#gzqe-1677787446997)

<a name="ndp9-1706276342383"></a>[1.根据名词抽象出实体](#r1ac-1621692724628)

<a name="uzak-1706276342385"></a>[2.名词找属性](#d2fl-1621692745600)

<a name="qluv-1706276342387"></a>[3.实体间联系](#dwkp-1621692752824)

<a name="xexq-1706276342389"></a>[1.2 转化成数据库设计（公式）](#c2cy-1677787446998)

<a name="dqym-1706276342391"></a>[.1 对1 关系 往记录少的乙方加主键](#xmox-1621692858500)

<a name="eajw-1706276342393"></a>[.1对n 关系 ，往 n 实体加关联主键 ](#mdr8-1621692924289)

<a name="ylog-1706276342395"></a>[. n对 m 关系，需要一个关联表作映射关联](#hd3i-1621692960576)

<a name="0tke-1706276342397"></a>[二.系统优化](#cdso-1677787447000)

<a name="lmvl-1706276342399"></a>[应用整体的优化](#3qep-1642647362896)

<a name="hayw-1706276342401"></a>[-cpu -> 纳秒级别](#knge-1642647371136)

<a name="gzak-1706276342403"></a>[1.多线程和并发编程](#ovup-1704437622969)

<a name="4vy2-1706276342405"></a>[2.JNI ](#ufpl-1704437634986)

<a name="dh6h-1706276342407"></a>[3.JIT/AOT编译](#ixb5-1704437634987)

<a name="9fwx-1706276342409"></a>[4.算法优化](#kr1f-1704437634988)

<a name="r26f-1706276342411"></a>[-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)](#1xur-1642647384168)

<a name="mkhc-1706276342413"></a>[1.JVM内存管理](#7hi9-1704437851514)

<a name="hqch-1706276342415"></a>[2.缓存](#te7c-1704437851799)

<a name="z7xn-1706276342417"></a>[3.消息中间件](#bqty-1704437851800)

<a name="ifml-1706276342419"></a>[-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)](#ziti-1642647439005)

<a name="syjs-1706276342421"></a>[1.减少磁盘io](#zups-1704437900079)

<a name="aic7-1706276342423"></a>[2.数据压缩   ](#u3ok-1704438035018)

<a name="trwp-1706276342425"></a>[-网络传输/系统交互 -> 秒级 (减少io，连接池化) ](#irbp-1642647458856)

<a name="rmno-1706276342427"></a>[1.减少网络请求   ](#6qil-1704438276193)

<a name="ilvr-1706276342429"></a>[2.使用CDN](#p5dt-1704438283633)

<a name="4dmf-1706276342431"></a>[3.Sockets异步通信                                      ](#zhp8-1704438283634)

<a name="8xdu-1706276342433"></a>[项目架构层面的优化](#3l0l-1704424353262)

<a name="97qv-1706276342435"></a>[-多级缓存](#8o8s-1704424396933)

<a name="onl5-1706276342437"></a>[-应用层](#trcg-1704438366333)

<a name="hulz-1706276342439"></a>[代码优化](#68oa-1704438530062)

<a name="vqt2-1706276342441"></a>[数据库优化](#clmf-1704438530257)

<a name="doga-1706276342443"></a>[日志优化](#md03-1704438530259)

<a name="akv9-1706276342445"></a>[-监控与调优](#ocux-1704438477879)

<a name="y7qm-1706276342447"></a>[性能监控：](#vdq2-1704438556836)

<a name="a9iz-1706276342449"></a>[分析和调优](#t29d-1704438557094)

<a name="jnin-1706276342451"></a>[-分布式系统架构](#ukjf-1704424419442)

<a name="fbnv-1706276342454"></a>[  .负载均衡](#a0bx-1704438677201)

<a name="dnrs-1706276342456"></a>[分布式缓存](#xn9x-1704438687994)

<a name="qx2o-1706276342458"></a>[服务降级和容错](#zcdp-1704438687996)

<a name="mqj9-1706276342460"></a>[读写层面](#six7-1642647372926)

<a name="x0zz-1706276342462"></a>[.读优化](#g4uv-1704732583614)

<a name="xlpr-1706276342464"></a>[1.缓存](#uuzh-1704732602620)

<a name="a093-1706276342466"></a>[2.索引](#qobc-1704732605892)

<a name="csfk-1706276342468"></a>[3.减少io/批量读](#zlg9-1704732609048)

<a name="qnbe-1706276342470"></a>[4.减少多余数据加载/列式存储读](#fpjd-1704732631316)

<a name="4pw3-1706276342472"></a>[.写优化](#oyob-1704732598377)

<a name="bueo-1706276342474"></a>[1.异步写](#6jmb-1704732509150)

<a name="c8ry-1706276342476"></a>[2.并发写](#tkwp-1704732723564)

<a name="b7qv-1706276342478"></a>[3.批量写](#hewz-1704732862030)

<a name="zcau-1706276342480"></a>[4.优化算法和数据结构](#ccd8-1704732727854)

<a name="bizv-1706276342482"></a>[5.缓存写](#eqd9-1704732736281)

<a name="gje4-1706276342484"></a>[6.非阻塞io](#hyq8-1704732768916)

<a name="u70i-1706276342486"></a>[1.分控系统优化复盘](#tncv-1677787447001)

<a name="7j0o-1706276342488"></a>[1.1 数据库系统](#ydq7-1677787447002)

<a name="kga4-1706276342490"></a>[1.2 sql慢](#wxdd-1677787447003)

<a name="a63r-1706276342492"></a>[1.3 接口慢](#olpb-1677787447004)

<a name="e5ln-1706276342494"></a>[高并发系统设计](#wrwk-1642647280506)

<a name="mwjf-1706276342496"></a>[1.满足大规模用户同时访问，提供良好响应时间和性能](#8ien-1704757782146)

<a name="rqdx-1706276342498"></a>[2.设计之初就要考虑伸缩性和容错性是非常重要的](#xy0g-1704757785190)

<a name="zbi1-1706276342500"></a>[.垂直伸缩 ](#wr12-1704947861599)

<a name="ucia-1706276342502"></a>[.水平伸缩](#bizh-1704947959744)

<a name="33bx-1706276342504"></a>[1.分布式架构](#fvzi-1704756770858)

<a name="cfmg-1706276342506"></a>[.微服务架构](#ywzr-1704756872033)

<a name="yvud-1706276342508"></a>[.分布式计算](#xgna-1704756877646)

<a name="mqkd-1706276342510"></a>[2.负载均衡](#wnfy-1704756775272)

<a name="qu0n-1706276342512"></a>[.负载均衡](#h6nf-1704756891918)

<a name="zp6t-1706276342514"></a>[.水平扩展](#c8zr-1704756894402)

<a name="iuyb-1706276342516"></a>[3.数据库设计](#wxjk-1704756782840)

<a name="wd8d-1706276342518"></a>[.读写分离](#lxca-1704756910837)

<a name="hwkw-1706276342520"></a>[.数据库分片](#p7d2-1704756922362)

<a name="csmc-1706276342522"></a>[.缓存](#hxjt-1704756963988)

<a name="b8zn-1706276342524"></a>[4.缓存优化](#iivs-1704756788012)

<a name="8x8v-1706276342526"></a>[.分布式缓存](#cvui-1704756971791)

<a name="8e1r-1706276342528"></a>[.本地缓存](#ysly-1704756979122)

<a name="cw9y-1706276342530"></a>[.缓存预热](#rqwj-1704756986363)

<a name="qdr0-1706276342532"></a>[5.消息队列](#so9h-1704756800253)

<a name="zy4l-1706276342534"></a>[.异步处理](#sxlo-1704756996000)

<a name="pgj8-1706276342536"></a>[.削峰填谷](#llm2-1704757002994)

<a name="cub0-1706276342538"></a>[6.分布式事务](#n39o-1704756805232)

<a name="wrvg-1706276342541"></a>[.两阶段提交](#5bhj-1704757017700)

<a name="ewr4-1706276342543"></a>[.补偿事务](#becc-1704757028036)

<a name="7jej-1706276342545"></a>[7.高可用和容错](#wgkk-1704756813448)

<a name="avr7-1706276342547"></a>[.多地域部署](#akwz-1704757035393)

<a name="7de0-1706276342549"></a>[.设计容错](#3nxv-1704757055271)

<a name="0xgv-1706276342551"></a>[1. 熔断限流](#g3xx-1704757371028)

<a name="cyvo-1706276342553"></a>[2. 多节点服务](#jafy-1704757374368)

<a name="klhk-1706276342555"></a>[8.监控和性能调优](#ilyo-1704756820772)

<a name="gb43-1706276342557"></a>[.实时监控](#kpwq-1704757064566)

<a name="mkjk-1706276342559"></a>[.性能测试](#shf4-1704757066453)

<a name="nfrc-1706276342561"></a>[9.安全性设计](#2pry-1704756830245)

<a name="dlbv-1706276342563"></a>[.防御性编程](#pkiw-1704757078583)

<a name="kker-1706276342565"></a>[.访问控制](#g4l1-1704757084924)

<a name="wad8-1706276342567"></a>[10.水平扩展](#1tsd-1704756838192)

<a name="3z3r-1706276342569"></a>[.自动化部署](#r1dd-1704757092061)

<a name="dt2z-1706276342571"></a>[.云服务](#7mhk-1704757104117)

<a name="sfnj-1706276342573"></a>[高并发性能指标](#rpxb-1677787447005)

<a name="fggh-1706276342575"></a>[QPS(每秒请求)](#klnv-1704761369323)

<a name="q9px-1706276342577"></a>[TPS(每秒事务)](#zvlz-1704761369324)

<a name="mix8-1706276342579"></a>[RT(响应时间)](#gvrn-1704761369325)

<a name="gbv2-1706276342581"></a>[===系统架构设计师===](#ozkt-1704761368259)

<a name="nd1m-1706276342583"></a>[系统工程与信息系统基础](#mpwu-1704949756608)

<a name="gthq-1706276342585"></a>[.系统工程方法](#2gzz-1704980837071)

<a name="xrfg-1706276342587"></a>[.系统工程生命周期阶段](#mk93-1704952875199)

<a name="kag5-1706276342589"></a>[.系统工程生命周期方法](#ny2c-1704952893636)

<a name="yvbd-1706276342591"></a>[.信息系统建设原则](#shmt-1704952904062)

<a name="oj1h-1706276342593"></a>[.信息系统开发方法](#itje-1704951812273)

<a name="mayp-1706276342595"></a>[原型法](#bnzq-1705819374009)

<a name="kshs-1706276342597"></a>[结构化法-瀑布型](#ujj3-1705819377863)

<a name="h48p-1706276342599"></a>[形式化法-数模](#8wek-1705819398251)

<a name="7viz-1706276342601"></a>[敏捷方法](#jeuk-1705819392097)

<a name="v0na-1706276342603"></a>[.信息系统分类](#w8yd-1704980881013)

<a name="xoqs-1706276342605"></a>[业务处理系统TPS](#hlhq-1705819204285)

<a name="01dk-1706276342607"></a>[管理信息系统MIS](#oksn-1705819204735)

<a name="nrkf-1706276342609"></a>[决策支持系统DSS](#lwm7-1705819204736)

<a name="ntfs-1706276342611"></a>[专家系统ES](#bmeu-1705819204737)

<a name="mrvn-1706276342613"></a>[办公自动化系统OAS](#kffq-1705819204738)

<a name="1jaw-1706276342615"></a>[企业资源系统ERP](#k2px-1705819204739)

<a name="toeu-1706276342617"></a>[过程模型](#f98t-1704981918920)

<a name="lntq-1706276342619"></a>[瀑布模型](#yk4j-1705841608124)

<a name="onnj-1706276342622"></a>[V模型【瀑布变种-测试贯穿】](#oryp-1705841608705)

<a name="u2jw-1706276342624"></a>[原型模型](#b0cp-1705841621350)

<a name="r4k5-1706276342626"></a>[螺旋模型【原型+瀑布 风险】](#sfqi-1705841608707)

<a name="2tg1-1706276342628"></a>[构件组装模型/基于构件的开发方法](#kbjw-1705841608709)

<a name="7wdc-1706276342630"></a>[快速应用开发RAD【瀑布+构件组装】](#mvze-1705841627436)

<a name="6gnf-1706276342632"></a>[统一过程/统一开发方法](#xici-1705841629815)

<a name="bgy3-1706276342634"></a>[敏捷开发方法](#9jca-1705841608711)

<a name="vjgf-1706276342636"></a>[XP](#28va-1705841590197)

<a name="o4l7-1706276342638"></a>[Scrum](#fyfq-1705938223773)

<a name="bchh-1706276342640"></a>[逆向工程](#d5ko-1705938215067)

<a name="ftib-1706276342642"></a>[实现级](#os3c-1706090901666)

<a name="qhud-1706276342644"></a>[结构级](#irxb-1706090905276)

<a name="kl8c-1706276342646"></a>[功能级](#rk8d-1706090908958)

<a name="ephm-1706276342648"></a>[领域级](#k3pt-1706090912460)

<a name="v7ru-1706276342650"></a>[净室软件工程](#tybd-1705938215235)

<a name="54s8-1706276342652"></a>[需求工程](#ochn-1705940085547)

<a name="zcen-1706276342654"></a>[.需求获取](#xdlf-1705940054108)

<a name="nqyj-1706276342656"></a>[用户面谈 ](#s1uq-1706090846730)

<a name="djob-1706276342658"></a>[联合需求计划(JRP) ](#vuil-1706090851858)

<a name="rxxx-1706276342660"></a>[问卷调查 ](#gpxg-1706090851859)

<a name="35sb-1706276342662"></a>[现场观察   ](#mg9n-1706090851860)

<a name="pofa-1706276342664"></a>[原型化方法        ](#3ww6-1706090851861)

<a name="xfjj-1706276342666"></a>[头脑风暴法](#0awr-1706090851863)

<a name="unqk-1706276342668"></a>[.需求分析](#axny-1705940052332)

<a name="axj2-1706276342670"></a>[1.功能模型(数据流图DFD)](#v8wz-1706090812929)

<a name="x5to-1706276342672"></a>[2.行为模型(状态转换图)](#3uls-1706090814821)

<a name="0cdh-1706276342674"></a>[3.实体模型(E-R图)](#69df-1706090816407)

<a name="5mtd-1706276342676"></a>[UML](#loq2-1705940640473)

<a name="cusd-1706276342678"></a>[需求定义](#4aeg-1706091062964)

<a name="zxua-1706276342680"></a>[需求验证](#ud2s-1706090947930)

<a name="ovgv-1706276342682"></a>[需求跟踪](#l03x-1705940634470)

<a name="tiwt-1706276342684"></a>[需求变更管理](#muqf-1706093218719)

<a name="ir8q-1706276342686"></a>[软件系统建模](#ilpb-1706093190683)

<a name="xh4k-1706276342688"></a>[软件界面设计](#j396-1706094675778)

<a name="gfl0-1706276342690"></a>[结构化设计](#vqsk-1706094478028)

<a name="kcnt-1706276342692"></a>[内聚](#jczo-1706095018132)

<a name="vjvu-1706276342694"></a>[耦合](#qa8z-1706095402118)

<a name="rcyv-1706276342696"></a>[模块四要素](#g1dc-1706095391028)

<a name="bl6e-1706276342698"></a>[面相对象设计](#ydwa-1706095870710)

<a name="otec-1706276342700"></a>[类的分类](#fouz-1706095958643)

<a name="gpdo-1706276342702"></a>[基本过程](#9pd1-1706095996137)

<a name="0wkr-1706276342704"></a>[设计原则(同设计模式)](#k8lc-1706096001163)

<a name="bifh-1706276342706"></a>[计算机](#qvol-1706095952165)

<a name="jjvj-1706276342708"></a>[计算机结构(★)](#ef1b-1706108352037)

<a name="4pie-1706276342711"></a>[存储系统(★★★★)](#4kj7-1706108373776)

<a name="75o7-1706276342713"></a>[层次化存储结构](#ucta-1706109825295)

<a name="kzmp-1706276342715"></a>[Cache](#j9hn-1706109828962)

<a name="3zbp-1706276342717"></a>[主存编址计算](#pv51-1706109847372)

<a name="qfyc-1706276342719"></a>[磁盘基本结构与存储过程](#jcqv-1706108377026)

<a name="tepj-1706276342721"></a>[磁盘优化分布存储](#puux-1706111215530)

<a name="yrkf-1706276342723"></a>[磁盘单缓冲区与双缓冲区读取](#dvin-1706111222861)

<a name="18ux-1706276342725"></a>[磁盘移臂调度算法](#jr2r-1706111239137)

<a name="ggwa-1706276342727"></a>[数据传输控制方式（★)](#sz2k-1706111188014)

<a name="c4j2-1706276342729"></a>[总线（★★)](#cbul-1706108378755)

<a name="jacc-1706276342731"></a>[CISC与RISC(★)](#0hb5-1706108373778)

<a name="urxp-1706276342733"></a>[流水线(★★)](#ernn-1706108380109)

<a name="uonk-1706276342735"></a>[校验码(★)](#grix-1706108381278)

<a name="ifsv-1706276342737"></a>[嵌入式（★)](#1p2v-1706108382511)

<a name="dgs6-1706276342739"></a>[计算机网络](#8vmt-1706198382356)

<a name="ixiy-1706276342741"></a>[TCP/IP协议族(7层/4层网络模型)](#a4es-1706106975412)

<a name="xhz9-1706276342743"></a>[.TCP与UDP (★★★)](#vwim-1706198561289)

<a name="moy4-1706276342745"></a>[.DHCP与DNS (★★★)](#imsh-1706198537828)

<a name="fhpu-1706276342747"></a>[网络规划与设计](#u7sd-1706198559304)

<a name="pwqx-1706276342749"></a>[1.逻辑设计与物理设计(★★★★）](#nov8-1706198591905)

<a name="ho5r-1706276342751"></a>[2.层次化网络设计](#sy2g-1706198599196)

<a name="lszu-1706276342753"></a>[3.网络冗余设计](#igl7-1706257923205)

<a name="y2zf-1706276342755"></a>[网络存储（★★)](#zkxb-1706257899477)

<a name="irlg-1706276342757"></a>[磁盘阵列Raid](#fxma-1706198636789)

<a name="1r90-1706276342759"></a>[lPv6 (★)](#vlem-1706259832461)

<a name="wwgb-1706276342761"></a>[网络接入(有线/无线)](#g438-1706198637653)

<a name="hs65-1706276342763"></a>[综合布线(★)](#lxli-1706198497856)

<a name="bjid-1706276342765"></a>[网络技术扩展](#5dlt-1706198650540)

<a name="bmw6-1706276342767"></a>[物联网(IOT)](#jgll-1706198586849)

<a name="leav-1706276342769"></a>[云计算(Saas/Paas/Iaas)](#pr8x-1706198586851)

<a name="ciu7-1706276342771"></a>[===数据密集型应用===](#sswx-1706094478181)

<a name="m40e-1706276342773"></a>[设计数据密集型应用](#unbe-1677787447006)

<a name="pjpk-1706276342775"></a>[1.可靠性、可拓展性、可维护性能](#kwfx-1677787447007)

<a name="6xse-1706276342777"></a>[-功能性需求：CRUD](#lykw-1644227240038)

<a name="2mgc-1706276342779"></a>[-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性](#b2tu-1644227249556)

<a name="hra9-1706276342781"></a>[.可靠性：](#qqm5-1644227303238)

<a name="japm-1706276342783"></a>[.可扩展性： ](#7xms-1644228225080)

<a name="vx3t-1706276342785"></a>[.可维护性：   ](#elzq-1644228563046)

<a name="avfy-1706276342787"></a>[2.数据模型与查询语言](#jufm-1677787447008)

<a name="0nqe-1706276342789"></a>[-关系模型](#pgu6-1699844351041)

<a name="xurv-1706276342792"></a>[-NoSql (es,redis)](#kfpd-1644410618294)

<a name="8ad1-1706276342794"></a>[1.文档数据库：](#0p23-1644410807294)

<a name="bxvp-1706276342796"></a>[  2.图形数据库 ：](#09bl-1644410666587)

<a name="6wna-1706276342798"></a>[-其它模型(基因序列)](#6fxw-1644410924417)

<a name="vfxn-1706276342800"></a>[3.存储与检索](#sm0u-1677787447009)

<a name="odak-1706276342802"></a>[-优化事务处理（OLTP）transaction ](#bhcv-1644935436804)

<a name="0oia-1706276342804"></a>[1.OLTP系统通常面向用户，大量的请求。](#tbhw-1699844517372)

<a name="bedr-1706276342806"></a>[2.磁盘寻道时间往往是这里的瓶颈。](#fnev-1644935714127)

<a name="nugx-1706276342808"></a>[3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。](#cjwp-1644935609899)

<a name="ubzt-1706276342810"></a>[-优化分析（OLAP）analys](#jg7s-1699844443567)

<a name="41ax-1706276342812"></a>[1.列式储存(投影操作，压缩技术，聚合过滤)](#pjd1-1703887811615)

<a name="ctjy-1706276342814"></a>[-OLTP两大主流学派的存储引擎：](#8sgm-1644935924013)

<a name="yrbp-1706276342816"></a>[1.日志结构学派](#i55y-1644935943748)

<a name="pjeo-1706276342818"></a>[2.就地更新学派](#h3il-1644935977285)

<a name="recw-1706276342820"></a>[4.编码（序列化）与演化(XML,JSON,CSV)](#lbs1-1677787447010)

<a name="jy1m-1706276342822"></a>[分布式系统](#d4ge-1677787447011)

<a name="oltz-1706276342824"></a>[4.分布式数据](#4p9n-1677787447012)

<a name="780t-1706276342826"></a>[1.高可用性](#o4ag-1646310813851)

<a name="safn-1706276342828"></a>[2.断开连接的操作](#snwm-1646310894841)

<a name="z0z3-1706276342830"></a>[3.减少延迟(节点近)](#evly-1646310918322)

<a name="3sph-1706276342832"></a>[4.可拓展性](#itsh-1646310968967)

<a name="pycd-1706276342834"></a>[-复制的三种主要方法：](#gbgq-1646311175182)

<a name="nczx-1706276342836"></a>[1.单主复制](#wg6v-1646311185918)

<a name="ngfs-1706276342838"></a>[2.多主复制](#ftqb-1646311200843)

<a name="jmyu-1706276342840"></a>[3.无主复制](#4xbf-1646311410600)

<a name="ogka-1706276342842"></a>[-一致性模型：](#nlnz-1699845075606)

<a name="roue-1706276342844"></a>[1.写后读](#anqq-1646312272172)

<a name="3qrv-1706276342846"></a>[2.单调读](#hedn-1646312288296)

<a name="j6en-1706276342848"></a>[3.一致前缀读](#fizh-1646312291911)

<a name="wbjp-1706276342850"></a>[7.事务](#j5o0-1704983008475)

<a name="m7ya-1706276342852"></a>[.简化故障失败的机制](#du4g-1704983767151)

<a name="qvav-1706276342854"></a>[.事务的棘手问题](#k9de-1704984009883)

<a name="btaf-1706276342856"></a>[原⼦性（Atomicity）](#65nh-1704984028565)

<a name="z1cn-1706276342858"></a>[⼀致性（Consistency）](#qeub-1646310871673)

<a name="l8am-1706276342860"></a>[隔离性（Isolation）](#rpju-1646310871817)

<a name="o71s-1706276342862"></a>[持久性（Durability）](#aq1q-1646310872064)

<a name="0tto-1706276342864"></a>[分布式系统的麻烦](#enui-1704985776096)

<a name="wb0e-1706276342866"></a>[一致性共识](#rp9s-1705080859004)

<a name="kytr-1706276342868"></a>[分布式事务](#cys8-1705080619829)

<a name="izuu-1706276342870"></a>[2PC提交](#bjec-1705081008345)

<a name="bz8w-1706276342873"></a>[3PC提交](#dyd0-1705118358884)

<a name="0wxj-1706276342875"></a>[实践中的分布式事务](#pudp-1705080909535)

<a name="h18o-1706276342877"></a>[XA事务(扩展架构（eXtended Architecture)](#ozc0-1705080997483)



<a name="jeyl-1677787446995"></a>**一.数据库设计**

<a name="5hya-1677787446996"></a>**1. 关系型数据库**

<a name="ohc5-1621692571287"></a>**.E-R图，由台湾工程师提出的设计概念**

<a name="4z7m-1645598900270"></a>权益系统数据库设计复盘：雄爷并行看需求文档一两天设计DB。

<a name="5ocb-1645598528868"></a>**.流程图-业务逻辑相关，系统用户动作。抽象出E-R图**

<a name="gzqe-1677787446997"></a>**1.1 E-R图** 

<a name="r1ac-1621692724628"></a>**1.根据名词抽象出实体**

<a name="d2fl-1621692745600"></a>**2.名词找属性**

<a name="dwkp-1621692752824"></a>**3.实体间联系**

<a name="cyqi-1699843717785"></a>（单条记录对应关系 A表一条记录对应B表多条记录，B表一条记录对应A表多条记录即 m对）

<a name="53bo-1621692829033"></a>**.状态图**

<a name="c2cy-1677787446998"></a>**1.2 转化成数据库设计（公式）**

<a name="xmox-1621692858500"></a>**.1 对1 关系 往记录少的乙方加主键**

<a name="mdr8-1621692924289"></a>**.1对n 关系 ，往 n 实体加关联主键** 

<a name="hd3i-1621692960576"></a>**. n对 m 关系，需要一个关联表作映射关联**

<a name="p0tb-1655431896857"></a><a name="i6pd-1655431897042"></a>最好不要自己设计自己的表，关乎字段名统一（属性思想上的统一），以及字段冗余，字段依赖问题。

<a name="cdso-1677787447000"></a>**二.系统优化**

<a name="3qep-1642647362896"></a>**应用整体的优化**

<a name="knge-1642647371136"></a>**-cpu -> 纳秒级别**

<a name="ovup-1704437622969"></a>**1.多线程和并发编程**

<a name="ufpl-1704437634986"></a>**2.JNI** 

<a name="ixb5-1704437634987"></a>**3.JIT/AOT编译**

<a name="kr1f-1704437634988"></a>**4.算法优化**

1\.多线程和并发编程：多线程和并发重复利用多核CPU,利用线程池管理复用线程，避免创建和销毁线程昂贵开销。

2\.JNI: C本地代码调度CPU

3\.JIT/AOT编译：JVM 和 JIT 足够时间来优化热点代码 / 云原生native Graavm ahead of time(AOT)静态编译

<a name="pojo-1704436320217"></a>4.算法优化：优化关键算法和数据结构，确保CPU执行效率

<a name="1xur-1642647384168"></a>**-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)**

<a name="7hi9-1704437851514"></a>**1.JVM内存管理**

<a name="te7c-1704437851799"></a>**2.缓存**

<a name="bqty-1704437851800"></a>**3.消息中间件**

(空间换时间)

1\.JVM内存管理：设置合理的堆大小及垃圾回收策略。

2\.缓存：redis缓存，spring缓存，ORM缓存

<a name="pxxu-1704436648342"></a>3.消息中间件：异步写，提高并发写能力。-吞吐量

<a name="ziti-1642647439005"></a>**-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)**

<a name="zups-1704437900079"></a>**1.减少磁盘io**

<a name="u3ok-1704438035018"></a>**2.数据压缩**   

1\.减少io(磁盘读写): 异步io,sql索引,局部性原理加载相邻页数据 ,DB数据磁盘预读----数据存储一般在DB系统中

<a name="ayss-1704436737847"></a>2.数据压缩：对需要存储或传输的数据进行压缩，减少磁盘占用

<a name="irbp-1642647458856"></a>**-网络传输/系统交互 -> 秒级 (减少io，连接池化)** 

<a name="6qil-1704438276193"></a>**1.减少网络请求**   

<a name="p5dt-1704438283633"></a>**2.使用CDN**

<a name="zhp8-1704438283634"></a>**3.Sockets异步通信**                                      

1\.减少网络请求：减少io(系统交互/连接池连接数)：去除for循环sql 

`    `--池化思想，创建和销毁消耗大的资源创建一个资源池，维护一定数量的资源数，统一管理资源创建和销毁

2\.使用CDN: 对于静态资源，使用内容分发网络（CDN）来加速资源的加载。

<a name="85si-1704436765735"></a>3.Sockets异步通信：对于需要等待的网络通信，可以考虑使用异步方式。

<a name="3l0l-1704424353262"></a>**项目架构层面的优化**

<a name="8o8s-1704424396933"></a>**-多级缓存**

亿级流量-多级缓存

<a name="lm7b-1704438499917"></a>浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

<a name="trcg-1704438366333"></a>**-应用层**

<a name="68oa-1704438530062"></a>**代码优化**

<a name="clmf-1704438530257"></a>**数据库优化**

<a name="md03-1704438530259"></a>**日志优化**

·代码优化:通过代码审查和性能分析工具来识别和优化慢速或低效的代码。

·数据库优化:对于数据库访问，使用索引、合理的查询语句，以及数据库连接池等来提高性能。

<a name="8o0m-1704438517387"></a>·日志优化:避免过度记录日志，尽量异步记录，或者使用日志级别进行动态调整。

<a name="ocux-1704438477879"></a>**-监控与调优**

<a name="vdq2-1704438556836"></a>**性能监控：**

<a name="t29d-1704438557094"></a>**分析和调优**

·性能监控:使用性能监控工具，例如Java Mission Control、VisualVM等，来实时监测应用程序的性能。

<a name="l3kg-1704437252457"></a>·分析和调优:根据监控结果，进行分析并进行调优，优化性能瓶颈。

<a name="ukjf-1704424419442"></a>**-分布式系统架构**

<a name="a0bx-1704438677201"></a>  **.负载均衡**

<a name="xn9x-1704438687994"></a>**分布式缓存**

<a name="zcdp-1704438687996"></a>**服务降级和容错**

浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

`                `CDN                  SLB负载均衡        分布式缓存          异步通信、MQ异步写/并发写、容错降级

·负载均衡:对于分布式系统，使用负载均衡来分配请求，以确保各个节点的负载均匀。

·分布式缓存:使用分布式缓存来减轻数据库负担，提高数据读取速度。

<a name="xpee-1704438657125"></a>·服务降级和容错:实现服务降级和容错机制，以应对网络或服务不稳定的情况。

<a name="six7-1642647372926"></a>**读写层面**

<a name="g4uv-1704732583614"></a>**.读优化**

<a name="uuzh-1704732602620"></a>**1.缓存**

<a name="qobc-1704732605892"></a>**2.索引**

<a name="zlg9-1704732609048"></a>**3.减少io/批量读/非阻塞io**

<a name="fpjd-1704732631316"></a>**4.减少多余数据加载/列式存储读**

<a name="oyob-1704732598377"></a>**.写优化**

<a name="6jmb-1704732509150"></a>**1.异步写**

<a name="tkwp-1704732723564"></a>**2.并发写**

<a name="hewz-1704732862030"></a>**3.批量写**

<a name="ccd8-1704732727854"></a>**4.优化算法和数据结构**

<a name="eqd9-1704732736281"></a>**5.缓存写**

<a name="hyq8-1704732768916"></a>**6.非阻塞io**

1\.批量操作:将多个写操作合并为批量操作，减少与数据库或其他外部存储的交互次数。例如，使用批量插入、批量更新或批量删除等操作，以减少单个写操作的开销。2.异步写入:使用异步写入的方式，将写操作放入队列或缓冲区中，由专门的线程异步处理。这样可以将写操作与主程序解耦，提高响应速度，并将写入操作批量化。

3\.数据库优化:对于关系型数据库，可以考虑优化数据库的配置和索引，以提高写入性

能。使用合适的数据库引擎和事务隔离级别，并优化查询和写入语句的性能。

4\.使用缓存:对于频繁的写入操作，可以使用缓存来减少对数据库的直接访问。将数据写入缓存，并通过批量或定期更新将数据同步到持久化存储。

5\.数据结构优化:选择合适的数据结构来存储数据，以提高写入性能。例如，使用哈希表、跳表等高效的数据结构来支持快速插入和更新操作。

6\.并发处理:使用多线程或分布式处理来并行处理写入操作，以提高写入性能。使用线程池或任务调度器来管理并发写入任务，并确保线程安全和数据─致性。

7\.使用非阻塞IO:对于高并发的写入操作，可以使用非阻塞IO技术，如NIO (New lO)或Netty等，以提高写入性能和吞吐量。

8\.数据分片:如果数据量较大，可以考虑将数据分片存储，将数据分散到多个存储节点上。这样可以将写入操作分散到多个节点上并行处理，以提高写入性能和扩展性。9.写缓冲:使用写缓冲区来缓存写入的数据，减少对物理存储设备的实时写入。通过批

<a name="z4ya-1704738513279"></a>量或异步的方式将缓冲区的数据定期写入存储设备，以提高写入性能。

<a name="tncv-1677787447001"></a>**1.分控系统优化复盘**

<a name="ydq7-1677787447002"></a>**1.1 数据库系统**

<a name="xsbg-1642647218571"></a>数据库的性能过低

<a name="eg0t-1642647223498"></a>提升硬件配置

<a name="wxdd-1677787447003"></a>**1.2 sql慢**

<a name="javd-1642647045138"></a>数据量大一千6百多万条数据

<a name="no1c-1642647140123"></a>删除冗余数据，每天采集13次，需求7天外数据只保留最新一批数据，修正删除的sql, 剩余数据，200w~600w左右。

<a name="ykot-1642649009232"></a>添加索引

<a name="olpb-1677787447004"></a>**1.3 接口慢**

<a name="blpq-1642649142995"></a>for循环遍历sql

<a name="s2zh-1642649153917"></a>去除for循环sql

<a name="yryq-1642649204976"></a> 频繁的采集种erverywhere log.info

<a name="afeg-1642649254648"></a>减少日志文件io，非必要信息改为debug。

<a name="fjt3-1643394063817"></a><a name="efqc-1643394063942"></a>优先考虑优化代价比较少的代码优化及sql优化，完成此类优化再考虑系统设计层面的优化，如：分库分表等（系统复杂度提升）。

<a name="navz-1652597408993"></a>一期历史数据重大bug修复方案设计问题（参看文档）： 注意像算法那样考虑极端情况（bug）处理，梳理方案的优缺点，对比不同方案实现优缺点接受度。

<a name="w6cm-1652597504660"></a>1.保证数据为最新的一批：

<a name="o4ka-1652597649729"></a>原方案. 每天13批次数据，不做事务回滚，取maxid ，>24小时数据删除---<24小时当天取消航班会在其中

<a name="ihuw-1652599412442"></a>配置难点：采集时段不同，每个账号采集不同天数; 采集的时间频率不同：

<a name="uarz-1652598784895"></a>熊爷方案：不改动原有逻辑，增加字段增加判段历史数据逻辑。

<a name="yxwj-1652599128439"></a>优点：基本不用改动一期代码和逻辑，改动sql增加判断历史条件。

<a name="rjdk-1652599326567"></a>缺点：新增判断的逻辑需要批次保证事务性，且配置难度很大，跨小时频率或者地区重叠，不可保证批次完整性，对比无效且配置和代码都得写死。

<a name="cehv-1652599093885"></a>我的方案：保证批次完整性，失败的批次直接整批删除，取最新一批。也是仅改动sql，获取最新一批批次代替 max(id)。

<a name="fm9n-1652599202701"></a>优点：只需要天数不重叠即可，配置相对灵活。

<a name="0ckh-1652599307805"></a>缺点：需要改sql逻辑，业务逻辑影响风险较大，需仔细验证。

<a name="nwww-1652597653246"></a> 

<a name="yjau-1644231171609"></a>分控系统重构设计

<a name="q9y5-1644231078993"></a>可靠性：写操作频繁，250k/h ~70次请求/s，将采集和后台分开两个应用。目前问题，采集两周左右系统资源耗尽会挂，可有多台服务器，实际上只用了两台。（集成应用监控，实现预警）

<a name="1ozg-1644231149674"></a>可拓展性：暂无,用户负载暂无数据

<a name="nbg9-1644231153386"></a>可维护性：代码质量，可读性。

<a name="wrwk-1642647280506"></a>**高并发系统设计**

<a name="8ien-1704757782146"></a>**1.满足大规模用户同时访问，提供良好响应时间和性能**

<a name="xy0g-1704757785190"></a>**2.设计之初就要考虑伸缩性和容错性是非常重要的**

<a name="wr12-1704947861599"></a>**.垂直伸缩** 

<a name="bizh-1704947959744"></a>**.水平伸缩**

·随着互联网的普及，用户访问量可能会在短时间内急剧增加。高并发系统设计可以确保系统在面对大规模用户同时访问时能够提供良好的响应时间和性能。

.高并发系统的设计是一个复杂而动态的过程，需要根据业务需求和系统特点不断优化。在设计之初就考虑到系统的可伸缩性和容错性是非常重要的。

` `垂直伸缩

`  `+配置32核CPU +124GB内存 +500G硬盘

优点；方案简单，易理解操作

缺点：容易达到机器物理上限，不具备高可用能力，单点故障高。

水平伸缩

<a name="4kjn-1704757525367"></a>多实例高可用，无需高性能服务器也可进行伸缩。

<a name="fvzi-1704756770858"></a>**1.分布式架构**

<a name="ywzr-1704756872033"></a>**.微服务架构**

<a name="xgna-1704756877646"></a>**.分布式计算**

·微服务架构:使用微服务拆分系统，将系统拆分成多个小而独立的服务，每个服务专注于特定的业务功能。

<a name="6khx-1704757167738"></a>·分布式计算:将任务分布到多个节点上，以充分利用计算资源。

<a name="wnfy-1704756775272"></a>**2.负载均衡**

<a name="h6nf-1704756891918"></a>**.负载均衡**

<a name="c8zr-1704756894402"></a>**.水平扩展**

·负载均衡器:使用负载均衡器分配请求到多个服务器，确保各个服务器的负载均衡。

<a name="o1d2-1704757209512"></a>·水平扩展:可以通过增加服务器数量来水平扩展系统，以支持更多的并发请求。

<a name="wxjk-1704756782840"></a>**3.数据库设计**

<a name="lxca-1704756910837"></a>**.读写分离**

<a name="p7d2-1704756922362"></a>**.数据库分片**

<a name="hxjt-1704756963988"></a>**.缓存**

·读写分离:使用读写分离来分担数据库的读写负载，提高数据库性能。

·数据库分片:将数据库分片，使数据分布在多个节点上，降低单—数据库的压力

<a name="yymm-1704757244191"></a>·缓存:使用缓存来减轻数据库负担，提高数据读取速度。

<a name="iivs-1704756788012"></a>**4.缓存优化**

<a name="cvui-1704756971791"></a>**.分布式缓存**

<a name="ysly-1704756979122"></a>**.本地缓存**

<a name="rqwj-1704756986363"></a>**.缓存预热**

·分布式缓存:使用分布式缓存，如Redis或Memcached，以提高数据的读取速度。

·本地缓存:在服务端使用本地缓存，减少对数据库或远程服务的请求次数。

<a name="vkcq-1704757254304"></a>·缓存预热:在系统启动时，预先加载一部分热门数据到缓存中，提高缓存命中率。

<a name="so9h-1704756800253"></a>**5.消息队列**

<a name="sxlo-1704756996000"></a>**.异步处理**

<a name="llm2-1704757002994"></a>**.削峰填谷**

·异步处理:使用消息队列进行异步处理，将一些非实时关键路径的任务放入队列中处理，减轻服务器负担。

<a name="99fz-1704757286906"></a>·削峰填谷:缓解系统压力，通过消息队列实现请求的削峰填谷，防止瞬时大量请求导致系统崩溃。

<a name="n39o-1704756805232"></a>**6.分布式事务**

<a name="5bhj-1704757017700"></a>**.两阶段提交**

<a name="becc-1704757028036"></a>**.补偿事务**

两阶段提交（2PC):在分布式环境中，确保事务的一致性，可以使用两阶段提交协议。

<a name="qset-1704757299753"></a>·补偿事务:使用补偿事务机制，处理在分布式环境中的异常情况。

<a name="wgkk-1704756813448"></a>**7.高可用和容错**

<a name="akwz-1704757035393"></a>**.多地域部署**

<a name="3nxv-1704757055271"></a>**.设计容错**

<a name="g3xx-1704757371028"></a>**1. 熔断限流**

<a name="jafy-1704757374368"></a>**2. 多节点服务**

·多地域部署:在不同地理位置部署系统，提高系统的可用性。

<a name="h6bn-1704757326243"></a>·容错设计:使用容错设计，确保系统在部分节点或服务失效时能够继续提供服务。

<a name="ilyo-1704756820772"></a>**8.监控和性能调优**

<a name="kpwq-1704757064566"></a>**.实时监控**

<a name="shf4-1704757066453"></a>**.性能测试**

·实时监控:使用监控系统实时监测系统性能，对系统进行及时调整。

<a name="lkos-1704757433031"></a>性能测试:定期进行性能测试，模拟高并发情况，找出系统的瓶颈并进行优化。

<a name="2pry-1704756830245"></a>**9.安全性设计**

<a name="pkiw-1704757078583"></a>**.防御性编程**

<a name="g4l1-1704757084924"></a>**.访问控制**

·防御性编程:编写安全的代码，防范SQL注入、XSS攻击等。

<a name="g9ef-1704757459182"></a>·访问控制:对系统的访问进行严格控制，避免未经授权的访问。

<a name="1tsd-1704756838192"></a>**10.水平扩展**

<a name="r1dd-1704757092061"></a>**.自动化部署**

<a name="7mhk-1704757104117"></a>**.云服务**

·自动化扩展:设计自动化扩展机制，根据系统负载自动增减节点。

<a name="g3qv-1704757477668"></a>·云服务:使用云服务提供商的弹性计算能力，根据需求调整计算资源。

<a name="rpxb-1677787447005"></a>**高并发性能指标**

<a name="klnv-1704761369323"></a>**QPS(每秒请求)**

<a name="zvlz-1704761369324"></a>**TPS(每秒事务)**

<a name="gvrn-1704761369325"></a>**RT(响应时间)**

我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。

公式：( 总PV数 \* 80% ) / ( 每天秒数 \* 20% ) = 峰值时间每秒请求数(QPS)

机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器

1、每天300w PV(网页浏览量) 的在单台机器上，这台机器需要多少QPS？ 

( 3000000 \* 0.8 ) / (86400 \* 0.2 ) = 139 (QPS)

2、如果一台机器的QPS是58，需要几台机器（cpu瓶颈）来支持？ ---得分析性能瓶颈，例如是CPU还是数据库。

<a name="02ut-1704761377369"></a>139 / 58 = 3 

<a name="ozkt-1704761368259"></a>**===系统架构设计师===**

<a name="mpwu-1704949756608"></a>**系统工程与信息系统基础**

<a name="2gzz-1704980837071"></a>**.系统工程方法**

|&emsp;<a name="ufly-1704951943937"></a>系统工程方法|&emsp;<a name="nxus-1704951943940"></a>关键点|
| :- | :- |
|<p>&emsp;<a name="1laj-1704951943944"></a>霍尔三维结构</p><p>&emsp;<a name="sxj8-1704951943946"></a>“硬科学”方法论</p>|<p>&emsp;<a name="lfis-1704951943949"></a>逻辑维:逻辑维即解决问题的逻辑过程。</p><p>&emsp;<a name="mbik-1704951943951"></a>时间维:时间维即是工作进程。</p><p>&emsp;<a name="6eif-1704951943953"></a>知识维:知识维即是专业科学知识。</p><p>&emsp;<a name="ujck-1704951943955"></a>应用场景:组织和管理大型工程建设项目</p>|
|<p>&emsp;<a name="jrym-1704951943959"></a>切克兰德方法</p><p>&emsp;<a name="q8lv-1704951943961"></a>“软科学”方法论</p>|<p>&emsp;<a name="iypv-1704951943964"></a>核心不是“最优化”，而是“比较”和“探寻”</p><p>&emsp;<a name="ovv5-1704951943966"></a>7步骤:认识问题、根底定义、建立概念模型、比较及探寻、选择、设计与实│</p><p>&emsp;<a name="nbrk-1704951943968"></a>施、评估与反馈</p>|
|&emsp;<a name="klwq-1704951943972"></a>并行工程方法|<p>&emsp;<a name="lys5-1704951943975"></a>“制造过程”与“支持过程”并行</p><p>&emsp;<a name="fst8-1704951943977"></a>强调三个方面:产品设计开发期间，最快速度按质完成;各项工作问题协调解决;适当的信息系统工具。</p>|
|&emsp;<a name="prt1-1704951943981"></a>综合集成法|<p>&emsp;<a name="khme-1704951943984"></a>钱学森命名【简单系统】和【巨系统】</p><p>&emsp;<a name="t5z1-1704951943986"></a>四原则:整体论原则、相互联系原则、有序性原则、动态原则</p>|
|&emsp;<a name="6lvr-1704951943990"></a>wSR系统方法|&emsp;<a name="1mrj-1704951943993"></a>实践准则:【懂物理】–【明事理】–【通人理】|

<a name="yvug-1704980841473"></a>时间维

1、规划阶段 调研，谋求活动的规划与战略    2、拟定方案    提出具体的计划方案    3、研制阶段 完成研制方案及生产计划      

4、生产阶段生    产零部件及提出安装计划    5、安装阶段 安装完毕，完成系统的运行计划    6、运行阶段    系统按照预期的用途开展服务

7、更新阶段    改进原有系统、或消亡原有系统

逻辑维    

1、明确问题    2、确定目标    建立价值体系或评价体系    3、系统综合    4、系统分析    

<a name="bf7c-1704980841472"></a>5、优化    系统方案的优化选择    6、系统决策    7、实施计划

<a name="mk93-1704952875199"></a>**.系统工程生命周期阶段**

系统工程生命周期阶段

<a name="lrmz-1704980944545"></a>探索性研究>概念阶段>开发阶段>生产阶段>使用阶段（5年）>保障阶段>退役阶段

<a name="ny2c-1704952893636"></a>**.系统工程生命周期方法**

系统工程生命周期方法

计划驱动方法:需求->设计->构建->测试->部署  ---瀑布模型

渐进迭代式开发:提供连续交付以达到期望的系统

精益开发:起源于丰田，是一个动态的、知识驱动的，以客户为中心的过程

<a name="0u7n-1704980953163"></a>敏捷开发:更好的灵活性

<a name="shmt-1704952904062"></a>**.信息系统建设原则**

信息系统建设原则

高层管理人员介入原则    如:CIO介入

用户参与开发原则    用户确定范围、核心用户全程参与、用户深度参与

自顶向下规划原则    以此减少信息不一致的现象

工程化原则    引入【软件工程】

<a name="wtaj-1704951817591"></a>其它原则    创新性原则、整体性原则、发展性原则、经济性原则

<a name="itje-1704951812273"></a>**.信息系统开发方法**

<a name="bnzq-1705819374009"></a>**原型法**

<a name="ujj3-1705819377863"></a>**结构化法-瀑布型**

<a name="8wek-1705819398251"></a>**形式化法-数模**

<a name="jeuk-1705819392097"></a>**敏捷方法**

原型法【需求阶段】  

按功能分：水平原型（界面） 垂直原型（复杂算法-抖音视频推送）

按最终结果分：抛弃式原型       演化式原型

结构化法：面向过程-瀑布型-自顶向下

面相对象方法：抽象-自底向上

面相服务方法： 粗粒度、松耦合、标准化和构件化

其他信息系统开发方式

形式化方法： 数学模型化  飞机，芯片等物理 模型化模拟

统一过程方法【up】

敏捷方法：scrum

<a name="kf2a-1704980979092"></a>基于架构的开发方法：ABSD

<a name="w8yd-1704980881013"></a>**.信息系统分类**

<a name="hlhq-1705819204285"></a>**业务处理系统TPS**

<a name="oksn-1705819204735"></a>**管理信息系统MIS**

<a name="lwm7-1705819204736"></a>**决策支持系统DSS**

<a name="bmeu-1705819204737"></a>**专家系统ES**

<a name="kffq-1705819204738"></a>**办公自动化系统OAS**

<a name="k2px-1705819204739"></a>**企业资源系统ERP**

业务处理系统TPS： OLTP、数据库、报表  -批处理数据

管理信息系统MIS：高度集成化的人机系统    -信息源、信息处理器、信息用户、信息处理者 donphi、pascal

【管理信息系统(Manage lnformation System,MIS)】是由业务处理系统发展而成的，

是在TPS基础上引进大量管理方法对企业整体信息进行处理，并利用信息进行预测、控制、计划、辅助企业全面管理的信息系统。

MIS系统四大部件:信息源、信息处理器、信息用户和信息管理者。十

决策支持系统DSS：语言系统，知识系统和问题处理系统组成，辅助决策

[DSS应具有的特征】

(1)数据和模型是DSS的主要资源。

(2)DSS用来支援用户作决策而不是代替用户作决策。

(3)DSS主要用于解决半结构化及非结构化问题。

(4)DSS的作用在于提高决策的有效性而不是提高决策的效率。

专家系统ES: 知识+推理 。人工智能的一个重要分支

知识库:存储求解实际问题的领域知识。

综合数据库∶存储问题的状态描述、中间结果、求解过程的记录等信息。

推理机:实质是【规则解释器】。

知识获取:两方面功能:知识的编辑求精及知识自学习。

解释程序:面向用户服务的。

办公自动化系统OAS: 

<a name="ct61-1704982049404"></a>企业资源系统ERP: 供应链

<a name="f98t-1704981918920"></a>**过程模型**

<a name="yk4j-1705841608124"></a>**瀑布模型**

严格区分阶段，每个阶段因果关系紧密相连

只适合需求明确的项目

缺点： 

软件需求完整性、正确性难确定

严格串行化，很长时间才能看到结果

<a name="3qne-1705842709255"></a>瀑布模型要求每个阶段一次性完全解决该阶段工作,这不现实。

<a name="oryp-1705841608705"></a>**V模型【瀑布变种-测试贯穿】**

测试贯穿于始终

测试分阶段(测试计划提前

<a name="p0k5-1705846375566"></a>编码后开始测试倒V成V字

<a name="b0cp-1705841621350"></a>**原型模型**

适合需求不明确的项目原型模型两个阶段:

1、原型开发阶段

2、目标软件开发阶段

<a name="cqhh-1705845876255"></a>[抛弃型原型)与【演化型原型】

<a name="sfqi-1705841608707"></a>**螺旋模型【原型+瀑布 风险】**

迭代型与增量型

以快速原型为基础+瀑布模型

<a name="b7wi-1705846464151"></a>考虑了风险问题

<a name="kbjw-1705841608709"></a>**构件组装模型/基于构件的开发方法**

【优点】易扩展、易重用、降低成本、安排任务更灵活。

【缺点】构件设计要求经验丰富的架构师、设计不好的构件难重用、强调重用可能牺牲其它指标(如性能)、第三方构件质量难控制。

【示例】

方舱医院

乐高积木

基于构件的软件工程(CBSE)

CBSE体现了【购买而不是重新构造】的哲学。

(CBSE的构件应该具备的特征】

1、可组装性:所有外部交互必须通过公开定义的接口进行。

2、可部署性:构件总是二进制形式的，能作为一个独立实体在平台上运行。

3、文档化:用户根据文档来判断构件是否满足需求。

4、独立性:可以在无其他特殊构件的情况下进行组装和部署。5、标准化:符合某种标准化的构件模型。

【构件的组装】

1、顺序组装:按顺序调用己经存在的构件，可以用两个已经存在的构件来创造一个新的构件。

2、层次组装:被调用构件的“提供”接口必须和调用构件的“请求”接口兼容。

<a name="zjcw-1705846978074"></a>3、叠加组装:多个构件合并形成新构件，新构件整合原构件的功能，对外提供新的接口。

<a name="mvze-1705841627436"></a>**快速应用开发RAD【瀑布+构件组装】**

业务建模

数据建模

过程建模

应用生成

<a name="nafe-1705930248825"></a>测试与交付

<a name="xici-1705841629815"></a>**统一过程/统一开发方法**

9个核心工作流：

业务建模

需求分析与设计

实现测试部署

配置与变更管理

项目管理

<a name="rsee-1705931291257"></a>环境

<a name="9jca-1705841608711"></a>**敏捷开发方法**

敏捷宣言

√个体和交互胜过过程和工具

√可工作的软件胜过大量的文档

√客户合作胜过合同谈判

√响应变化胜过遵循计划

传统软件开发方法: 预设性的 > 以开发过程为本 > 整体分阶段

<a name="flva-1705938097079"></a>敏捷方法: 适应性的 - 以人为本 - 增量迭代，小步快跑 - 适合小型项目

<a name="28va-1705841590197"></a>**XP**

敏捷方法- XP

4大价值观

沟通【加强面对面沟通】

简单【不过度设计】

反馈【及时反馈】

勇气【接受变更的勇气】

12条过程实践规则:

简单设计 测试驱动 代码重构 结对编程 持续集成 现场客户

发行版本 小型化 系统隐喻 代码集体所有 制规划策略 规范代码

<a name="mbtp-1705938236342"></a>40小时工作机制

<a name="fyfq-1705938223773"></a>**Scrum**

.极限编程\_(XP)∶价值观【交流、朴素、反馈、勇气】、近螺旋式的开发方法。

.水晶方法:提倡“机动性”的方法，拥有对不同类型项目非常有效的敏捷过程。

.SCRUM:侧重于项目管理。

.特征驱动开发方法（FDD)∶认为有效的软件开发需要3要素【人、过程、技术】。

.定义了6种关键的项目角色:项目经理、首席架构设计师、开发经理、主程序员、程序员和领域专家。

.开放式源码:程序开发人员在地域上分布很广【其他方法强调集中办公】。

.ASD方法:其核心是三个非线性的、重叠的开发阶段:猜测合作与学习。

<a name="elzb-1705938420182"></a>.动态系统开发方法(DSDM)︰倡导以业务为核心。

<a name="d5ko-1705938215067"></a>**逆向工程**

<a name="os3c-1706090901666"></a>**实现级**

<a name="irxb-1706090905276"></a>**结构级**

<a name="rk8d-1706090908958"></a>**功能级**

<a name="k3pt-1706090912460"></a>**领域级**

现有工程 - 再工程  -新系统   

逆向工程是设计的恢复过程。

\------

实现级:包括程序的抽象语法树、符号表、过程的设计表示

结构级:包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构

功能级:包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型

领域级∶包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型

与逆向工程相关的概念有重构、设计恢复、再工程和正向工程。

(1）重构/重组(Restructuring)。重构是指在【同一抽象级别】上【转换系统描述形式】。

(2）设计恢复(Design recovery)。设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。

(3)逆向工程(Reverse engineering):逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程。

(4）正向工程（Forward engineering)。正向工程是指不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，以改善其整体质量。

<a name="efxo-1705938813039"></a>(5）再工程/重构工程(Re-engineering)。再工程是对现有系统的重新开发过程，包括逆向工程、新需求的考虑过程和正向工程三个步骤。

<a name="tybd-1705938215235"></a>**净室软件工程**

√净室即无尘室、洁净室。也就是一个受控污染级别的环境。

√使用盒结构规约（或形式化方法)进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制。

√使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息。

-- 举例前端的 拖拽式功能框

【技术手段】

√统计过程控制下的增量式开发:控制迭代

√基于函数的规范和设计:盒子结构

`    `定义3种抽象层次:行为视图(黑盒)->有限状态机视图（状态盒)->过程视图（明盒/白盒)

√正确性验证:净室工程的核心

√统计测试和软件认证:使用统计学原理，总体太大时必须采用抽样方法

【缺点】

√太理论化，正确性验证的步骤比较困难且耗时。

√开发小组不进行传统的模块测试，这是不现实的。

<a name="iesl-1705939167964"></a>√脱胎于传统软件工程，不可避免带有传统软件工程的一些弊端。

<a name="ochn-1705940085547"></a>**需求工程**

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。  -需求开发

【需求工程主要活动的阶段划分】

需求获取

需求分析

形成需求规格【形成SRS】

需求确认与验证【形成需求基线(经过评审的SRS)】

需求管理【变更控制、版本控制、需求跟踪、需求状态跟踪】

<a name="nlvu-1705940085546"></a>需求管理是对【需求基线】进行管理

<a name="xdlf-1705940054108"></a>**.需求获取**

<a name="s1uq-1706090846730"></a>**用户面谈** 

<a name="vuil-1706090851858"></a>**联合需求计划(JRP)** 

<a name="gpxg-1706090851859"></a>**问卷调查** 

<a name="mg9n-1706090851860"></a>**现场观察**   

<a name="3ww6-1706090851861"></a>**原型化方法**        

<a name="0awr-1706090851863"></a>**头脑风暴法**

软件需求获取方法

用户面谈 - 需求专题讨论会(JRP) - 问卷调查 - 现场观察 - 原型化方法 - 头脑风暴法

分层

√业务需求()整体全局)

√用户需求用户视角

√系统需求(计算机化)   -功能需求  -性能需求(非功能)  -设计约束

项目管理维度QFD

√基本需求(明示，常规需求)

√期望需求（隐含)

√兴奋需求(多余)

`    `方法                                    特点

用户面谈                1对1-3，有代表性的用户，了解主观想法，交互好。成本高，要有领域知识支撑。

联合需求计划(JRP)        高度组织的群体会议，各方参与，了解想法，消除分歧，交互好，成本高。

问卷调查                用户多，无法一一访谈，成本低。

现场观察                针对较为复杂的流程和操作。

原型化方法               通过简易系统方式解决早期需求不确定问题。

<a name="jvim-1705940257086"></a>头脑风暴法               一群人围绕新业务，发散思维,不产生新的观点。

<a name="axny-1705940052332"></a>**.需求分析**

<a name="v8wz-1706090812929"></a>**1.功能模型(数据流图DFD)**

<a name="3uls-1706090814821"></a>**2.行为模型(状态转换图)**

<a name="69df-1706090816407"></a>**3.实体模型(E-R图)**

需求工程-需求开发-需求分析- SA(DFD)

数据字典 数据元素-数据结构-数据流-数据存储-加工逻辑-外部实体

功能模型(数据流图DFD):数据流-加工-数据存储-外部实体

行为模型(状态转换图)：  状态(初态、终态)-事件

<a name="ovab-1705940661004"></a>实体模型(E-R图):  实体-联系

<a name="loq2-1705940640473"></a>**UML**

UML(统一建模语言)︰平台无关、语言无关。

结构事物:最静态的部分，包括:类、接口、协作、用例、活动类、构件和节点。

\>行为事物:代表时间和空间上的动作。包括:消息、动作次序、连接。

\>分组事物:看成是个盒子，如:包、构件。

\>注释事物:UML模型的解释部分。描述、说明和标注模型的元素。

动态图(行为图)

用例图:系统与外部参与者的交互

顺序图:强调按时间顺序

通信图(协作图)

状态图:状态转换变迁

活动图:类似程序流程图，并行行为

定时图:强调实际时间

交互概览图

静态图(结构图)

类图:一组类、接口、协作和它们之间的

关系对象图:一组对象及它们之间的关系

构件图:一个封装的类和它的接口

部署图:软硬件之间映射

制品图:系统的物理结构

·包图:由模型本身分解而成的组织单元，以及它们之间的依赖关系

·组合结构图

系统分析、设计人员                        程序员

逻辑视图(logical view)            实现视图(implementation view)

类与对象                           物理代码文件和组件 

系统集成人员                                系统和网络工程师

进程视图(process view)                部署视图(deployment view)    

<a name="ygog-1706091052296"></a>线程、进程、并发                            软件到硬件的映射

<a name="4aeg-1706091062964"></a>**需求定义**

严格定义法：

√所有需求都能够被预先定义

√开发人员与用户之间能够准确而清晰地交流

√采用图形/文字可以充分体现最终系统

原型法：

√并非所有的需求都能在开发前被准确的说明

√项目参加者之间通常都存在交流上的困难

√需要实际的、可供用户参与的系统模型

√有合适的系统开发环境

<a name="xyp0-1706092631364"></a>√反复是完全需要和值得提倡的，需求一旦确定，就应遵从严格的方法

<a name="ud2s-1706090947930"></a>**需求验证**

SRS:

需求评审  正式评审>非正式评审

需求测试

<a name="yies-1706092882866"></a>用户签字>确认验收标准之一

<a name="l03x-1705940634470"></a>**需求跟踪**

<a name="muqf-1706093218719"></a>**需求变更管理**

识别出问题

`    `问题分析和变更描述

`        `变更分析和成本计算   CCB

<a name="g9hm-1706093512613"></a>             变更实现  > 修改后的需求

<a name="ilpb-1706093190683"></a>**软件系统建模**

<a name="j396-1706094675778"></a>**软件界面设计**

黄金三法则

★置于用户控制之下

·以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式

·提供灵活的交互

·允许用户交百可以被中断和撤销

.当技能级别增加时可以使交互流水化并允许定制交互

·使用户隔离内部技术细节

·设计应允许用户和出现在屏幕上的对象直接交互

★减少用户的记忆负担

.减少对短期记忆的要求

·建立有意义的缺省

·定义直觉性的捷径

·界面的视觉布局应该基于真实世界的隐喻

·以不断进展的方式揭示信息

★保持界面的一致性

·允许用户将当前任务放入有意义的语境

·在应用系列内保持一致性

<a name="zy6c-1706094832554"></a>·如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要改变它

<a name="vqsk-1706094478028"></a>**结构化设计**

概要设计【外部设计】︰功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图

详细设计【内部设计】︰为每个具体任务选择适当的技术手段和处理方法

结构化设计原则:

模块独立性原则(高内聚、低耦合)

·保持模块的大小适中

·多扇入，少扇出       模块A扇入3(高复用)，扇出2(高依赖)       1>A 2>A 3>A  A<4 A<5  -高扇入即A被多个函数调用，复用率高good; 高扇出A调用多个函数，系统复杂性不可预见性增加；

<a name="upqt-1706095030525"></a>·深度和宽度均不宜过高

<a name="jczo-1706095018132"></a>**内聚**

内聚类型(由高到低)                描述

功能内聚    完成一个单一功能,各个部分协同工作，缺一不可

顺序内聚    处理元素相关,而且必须顺序执行

通信内聚    所有处理元素集中在一个数据结构的区域上

过程内聚    处理元素相关，而且必须按特定的次序执行

时间内聚    所包含的任务必须在同一时间间隔内执行  (瞬时内聚)

逻辑内聚    完成逻辑上相关的一组任务

<a name="snap-1706095411069"></a>偶然内聚    完成一组没有关系或松散关系的任务  (巧合内聚)

<a name="qa8z-1706095402118"></a>**耦合**

耦合类型（由低到高）        描述

非直接耦合  两个模块之间没有直接关系，它们之间的联系完全是通过主

数据耦合    模块的控制和调用来实现的

标记耦合    一组模块借助参数表传递简单数据

控制耦合    一组模块通过参数表传递记录信息(数据结构

外部耦合    模块之间传递的信息中包含用于控制模块内部逻辑的信息一组模块都访问同一全局简单变量，而且不是通过参数表传递该全局变量的信息

公共耦合    多个模块都访问同一个公共数据环境

<a name="yov0-1706095508310"></a>内容耦合    一个模块直接访问另一个模块的内部数据;一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠;一个模块有多个入口

<a name="g1dc-1706095391028"></a>**模块四要素**

模块的四个要素

输入和输出:模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。

处理功能:指模块把输入转换成输出所做的工作。

内部数据:指仅供该模块本身引用的数据。

<a name="j80k-1706095890170"></a>程序代码:指用来实现模块功能的程序。

<a name="ydwa-1706095870710"></a>**面相对象设计**

<a name="fouz-1706095958643"></a>**类的分类**

边界类：机器接口-API接口、人机交互-用户界面

`    `例:显示屏、窗体、打印机接口、、通信协议、对话框、菜单、购物、车、报表、二维码

控制类: 应用逻辑、业务逻辑、数据访问逻辑

`    `例:身份验证器

实体类：数据

<a name="fa2r-1706096021041"></a>    例:学员类、课程类

<a name="9pd1-1706095996137"></a>**基本过程**

分析模型            设计师            设计模型

用例模型        设计用例实现方案    架构图(用包图表示)

`                `设计技术支撑实施    用例实现图(用交互图表示)

`                `设计用户界面        类图（完整、精确)

分析模型        细化设计模型            其他（状态图、活动图等)l

<a name="tdyn-1706096267080"></a>(领域模型)

<a name="k8lc-1706096001163"></a>**设计原则(同设计模式)**

★单一职责原则:设计目的单一的类

★开放-封闭原则:对扩展开放，对修改封闭

★李氏(Liskov)替换原则:子类可以替换父类    泛化/继承

★依赖倒置原则:要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程

★接口隔离原则:使用多个专门的接口比使用单一的总接口要好

★组合重用原则:要尽量使用组合，而不是继承关系达到重用目的

<a name="we2w-1706096471101"></a>★迪米特(Demeter)原则（最少知识原则)︰一个对象应当对其他对象有尽可能少的了解（信息隐蔽，避免绕过接口）

<a name="qvol-1706095952165"></a>**计算机**

<a name="ef1b-1706108352037"></a>**计算机结构(★)**

CPU

运算器

算术逻辑单元ALU:数据的算术运算和逻辑运算

累加寄存器AC:通用寄存器，为ALU提供一个工作区，用在暂存数据数据

缓冲寄存器DR:写内存时，暂存指令或数据

状态条件寄存器PSW:存状态标志与控制标志(争议:也有将其归为控制器的)

控制器

程序计数器PC:存储下一条要执行指令的地址

指令寄存器IR:存储即将执行的指令

指令译码器ID:对指令中的操作码字段进行分析解释

<a name="2tuf-1706108642011"></a>时序部件:提供时序控制信号

<a name="4kj7-1706108373776"></a>**存储系统(★★★★)**

<a name="ucta-1706109825295"></a>**层次化存储结构**

<a name="j9hn-1706109828962"></a>**Cache**

<a name="pv51-1706109847372"></a>**主存编址计算**

层次化存储结构

CPU:寄存器

Cache:按内容存取(相联存储器)

内存(主存):DRAM

外存(辅存):硬盘、光盘、U盘等

Cache  -高命中率+快速访问能力

√ Cache的功能:提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。

√在计算机的存储系统体系中，Cache是访问速度最快的层次。  

√Cache对程序员来说是透明的。  -硬件相关，与程序员无法操作

√使用Cache改善系统性能的依据是程序的局部性原理。

√时间局部性:指程序中的某条指令一旦执行，不久以后该指令可能再次执行，典型原因是由于程序中存在着大量的循环操作。 -循环

√空间局部性:指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，

其典型情况是程序顺序执行。                -索引局部性

√工作集理论:工作集是进程运行时被频繁访问的页面集合。

主存编址计算

存储单元：存储单个数=最大地址最小地址1 

编址内容：

按字编址存储体的存储单元是存储单元，即最小寻址单位是一个字

按字节编址存储体的存储单元是字节存储单元，即最小寻址单位是一个字节。

总容量=存储单元个数\*编址内容

根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出所需芯片的总数，即:

<a name="nfaa-1706109451658"></a>        总片数总容量/每片的容量

<a name="jcqv-1706108377026"></a>**磁盘基本结构与存储过程**

<a name="gnlm-1706111292670"></a>存取时间=寻道时间+等待时间，寻道时间是指磁头移动到磁道所需的时间;等待时间为等待读写的扇区转到磁头下方所用的时间。

<a name="puux-1706111215530"></a>**磁盘优化分布存储**

<a name="dvin-1706111222861"></a>**磁盘单缓冲区与双缓冲区读取**

<a name="jr2r-1706111239137"></a>**磁盘移臂调度算法**

先来先服务(FCFS)

最短寻意时间优先(SSIE)

扫描算法(SCAN) -电梯算法

<a name="eh8a-1706113646563"></a>循环扫描(CSCAN)算法

<a name="sz2k-1706111188014"></a>**数据传输控制方式（★)**

I/O

√程序控制(查询)方式:分为无条件传送和程序查询方式两种。方法简单，硬件开销小，但I/O能力不高，严重影响CPU的利用率。

√程序中断方式:与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度。

<a name="ox7i-1706114676724"></a>√DMA方式:DMA方式是为了在主存与外设之间实现高速、批量数据交换而设置的。DMA方式比程序控制方式与中断方式都高效。

<a name="cbul-1706108378755"></a>**总线（★★)**

√总线是一组能为多个部件分时共享的公共信息传送线路。

`    `·共享

`    `·分时:是指同一时刻仅允许一个部件向总线发送信息，但允许多个部件同时从总线上接收相同的信息。

√串行总线(适合长距离传输)与并行总线(适合近距离连接，不宜过长)√单工、半双工与全双工

√总线宽度与总线带宽

总线的分类:

数据总线(Data Bus,DB)︰在CPU与RAM之间来回传送需要处理或是需要储存的数据。

地址总线(Address Bus，AB)︰用来指定在RAM (Random AccessMemory)之中储存的数据的地址。

<a name="ohwy-1706118513285"></a>控制总线(Control Bus，CB)∶将微处理器控制单元(Control Unit)的信号，传送到周边设备。

<a name="0hb5-1706108373778"></a>**CISC与RISC(★)**

<a name="ernn-1706108380109"></a>**流水线(★★)**

相关参数计算:流水线执行时间计算、流水线吞吐率、流水线加速比等。

流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，

<a name="ssri-1706118953399"></a>它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度

<a name="grix-1706108381278"></a>**校验码(★)**

<a name="1p2v-1706108382511"></a>**嵌入式（★)**

<a name="8vmt-1706198382356"></a>**计算机网络**

网际互连协议(IP,Internet Protocol)

传输控制协议(TCP,Transmission Control Protocol)  长连接3次握手

<a name="mucg-1706198453540"></a>用户数据报协议(UDP，User Datagram Protocol)       扔数据包

<a name="a4es-1706106975412"></a>**TCP/IP协议族(7层/4层网络模型)**

OSI七层模型    TCP/IP模型

应用层            -                POP3：110 

表示层            应用层            FTP：20/21    HTTP:80    DHCP：67     TFTP：69

会话层            -                Telnet：23    SMTP：25 简单邮件    SNMP：161     DNS：53

传输层            传输层            TCP    UDP

网络层            网际层            IP  ICMP    IGMP    ARP    RARP

数据链路层        网络接口层

物理层            -                CSMA/CD    TokingRing

TCP/IP协议族

POP3: 110端口，邮件收取

SMTP:25端口，邮件发送

FTP:20数据端口/21控制端口，文件传输协议

HTTP:80端口，超文本传输协议，网页传输

DHCP:67端口，IP地址自动分配

SNMP: 161端口，简单网络管理协议

DNS:53端口，域名解析协议，记录域名与IP的映射关系

TCP:可靠的传输层协议

UDP:不可靠的传输层协议

ICMP:因特网控制协议，PING命令来自该协议IGMP:组播协议 - trace

ARP:地址解析协议，IP地址转换为MAC地址

<a name="cgyp-1706249614651"></a>RARP:反向地址解析协议，MAC地址转lP地址

<a name="vwim-1706198561289"></a>**.TCP与UDP (★★★)**

共同点：基于IP协议的传输层协议，可以端口寻址

不同点:             

TCP -面向连接（连接管理)、三次握手、流量控制-滑动窗口限流、差错校验和重传、IP数据报按序接收(不  丢失、不重复)、可靠性强、牺牲通信量、效率低                         

UDP -不可靠、无连接、错误检测功能弱，无拥塞控制、无流量控制， 有助于提高传输的高速率性。

`     `不对无序IP数据报重新排序、不负责重传、不消除重复IP数据报、不对已收到的数据报进行确认、不负责建立或终止连接，

`     `这些由UDP进行通信的应用程序进行处理。



相关协议:

TCP - HTTP、FTP、Telnet、POP3、SMTP

<a name="2nxi-1706256522084"></a>UDP - DNS、DHCP、TFTP、SNMP

<a name="imsh-1706198537828"></a>**.DHCP与DNS (★★★)**

主机向本地域名服务器的查询采用递归查询。

本地域名服务器向根域名服务器的查询通常采用迭代查询。

域名解析链路：

`    `域名  - 本地host-缓存-（递归查询）本地域名服务器 dns.xyz.com -    

`                `（迭代查询，全球仅几台）3根域名服务器 / 4顶级域名服务器  / 5权限域名服务器



递归查询:服务器必需回答自标IP与域名的映射关系

迭代查询:服务器收到一次迭代查询回复一次结果，这个结果不一定是目标IP与域名的映射关系,也可以是其它DNS服务器的地址。

浏览器输入域名 ： HOSTS→本地DNS缓存→本地DNS服务器→根域名服务器→顶级域名服务器→权限域名服务器。

主域名服务器接收到域名请求 ：   本地缓存记录→区域记录→转发域名服务器→根域名服务器。

动态主机配置协议(DHCP，Dynamic Host Configuration Protocol)

1、客户机/服务器模型2、租约默认为8天

3、当租约过半时，客户机需要向DHCP服务器申请续租;

4、当租约超过87.5%时，如果仍然没有和当初提供IP的DHCP服务器联系上则开始联系其他的DHCP服务器。

5、分配方式

固定分配(管理员分配静态绑定固定的IP地址)

动态分配（为客户端分配租期为无限长的IP地址)

自动分配（为客户端分配具有一定有效期限的IP地址)

<a name="oikq-1706256859327"></a>6、无效地址:169.254.X.X和0.0.0.0

<a name="u7sd-1706198559304"></a>**网络规划与设计**

<a name="nov8-1706198591905"></a>**1.逻辑设计与物理设计(★★★★）**

网络规划与设计-逻辑网络设计

逻辑网络设计是体现网络设计核心思想的关键阶段，在这一阶段根据需

求规范和通信规范，选择一种比较适宜的网络逻辑结构，并基于该逻辑结构实施后续的资源分配规划、安全规划等内容。利用需求分析和现有网络体系分析的

结果来设计逻辑网络结构，最后得到一份逻辑网络设计文档。

逻辑网络设计工作主要包括以下内容:

(1）网络结构的设计

(2）物理层技术的选择

3）局域网技术的选择与应用

(4)广域网技术的选择与应用

(5)地址设计和命名模型

(6）路由选择协议

(7)网络管理

(8）网络安全

(9)逻辑网络设计文档

输出内容包括以下几点:

.逻辑网络设计图

.IP地址方案

.安全管理方案

.具体的软/硬件、广域网连接设备和基本的网络服务

.招聘和培训网络员工的具体说明

.对软/硬件费用、服务提供费用、员王和培训的费用初步估计

网络规划与设计–物理网络设计

物理网络设计是对逻辑网络设计的物理实现，通过对设备的具体物理分布、运行环境等确定，确保网络的物理连接符合逻辑连接的要求。

在这一阶段，网络设计者需要确定具体的软/硬件、连接设备、布线和服务的部署方案，

输出如下内容:

.网络物理结构图和布线方案

.设备和部件的详细列表清单

.软硬件和安装费用的估算

.安装日程表，详细说明服务的时间以及期限

.安装后的测试计划

<a name="1jly-1706257567932"></a>.用户的培训计划

<a name="sy2g-1706198599196"></a>**2.层次化网络设计**

核心层:主要是高速数据交换，实现高速数据传输、出口路由，常用冗余机制。

汇聚层∶网络访问策略控制、数据包处理和过滤、策略路由、广播域定义、寻址。

<a name="notp-1706257986732"></a>接入层:主要是针对用户端，实现用户接入、计费管理、MAC地址认证、MAC地址过滤、收集用户信息,可以使用集线器代替交换机。

<a name="igl7-1706257923205"></a>**3.网络冗余设计**

在网络冗余设计中，对于通信线路常见的设计目标

主要有两个:

`    `备用路径

`    `负载分担。

备用路径，提高可用性,由路由器、交换机等设备之间的独立备用链路构成，一般情况下备用路径仅仅在主路径失效时投入使用。

设计时主要考虑:

(1）备用路径的带宽

(2)切换时间

(3）非对称

(4）自动切换

(5）测试

负载分担,是对备用路径方式的扩充,通过并行链路提供流量分担(冗余的形式)来提高性能，主要的实现方法是利用两个或多个网络接口和路径来同时传递流量，

设计时注意考虑:

.网络中存在备用路径、备用链路时,可以考虑加入负载分担设计

.对于主路径、备用路径都相同的情况,可以实施负载分担的特例—负载均衡

<a name="hmbb-1706259541284"></a>.对于主路径、备用路径不相同的情况,可以采用策略路由机制，让一部分应

<a name="zkxb-1706257899477"></a>**网络存储（★★)**

分类

直连式存储(DAS，Direct-Attached Storage)

网络附加存储(NAS，Network-Attached Storage)

存储区域网络(SAN，Storage Area Network)

Internet小型计算机系统接口（iSCSl，Internet Small Computer System Interface)

DAS/SAS: 通过SCSI连接到服务器，本身是硬件的堆叠，不带有任何操作系统。存储器必须被直接连接到应用服务器上，不能跨平台共享文件，

`        `各系统平台下文件分别存储。

NAS: 通过网络接口与网络直接连接，由用户通过网络访问(支持多种TCP/IP协议)。NAS设备有自己的OS，类似于一个专用的文件服务器，

`        `一般存储信息采用RAID进行管理。即插即用。

SAN: 通过专用高速网络将一个或多个网络存储设备和服务器连接起来的专用存储系统，采用数据块的方式进行数据和信息的存储。

`        `目前主要使用以太网(IP SAN)和光纤通道(FC SAN)两类环境。

<a name="e8rr-1706259655613"></a>IP-SAN/iSCSI : 基于IP网络实现,设备成本低，配置技术简单，可共享和使用大容量的存储空间。

<a name="fxma-1706198636789"></a>**磁盘阵列Raid**

磁盘阵列(RAID，Redundant Arrays of Independent Disk)

Raid0(条块化):性能最高，并行处理，无冗余，损坏无法恢复

Raidl(镜像结构):可用性，可修复性好，仅有50%利用率

RaidO+1(Raid10): Raid0与Raidl长处的结合，高效也可靠

Raid3(奇偶校验并行传送):N+1模式，有固定的校验盘，坏一个盘可恢复

Raid5(分布式奇偶校验的独立磁盘):N+1模式，无固定的校验盘，坏一个盘可恢复

<a name="zf39-1706259856625"></a>Raid6(两种存储的奇偶校验):N+2模式，无固定的校验盘，坏两个盘可恢复

<a name="vlem-1706259832461"></a>**lPv6 (★)**

IPv6是设计用于替代现行版本lP协议(IPv4)的下一代IP协议。

(1）寻址能力方面的扩展。IPv6地址长度为128位，地址空间增大了2的96次方倍;

(2）灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPv4中可变长度的选项字段。IPv6中选项部分的出现方式也有所变化，

使路由器可以简单路过选项而不做任何处理，加快了报文处理速度;

(3)IPv6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量;

(4）提高安全性。身份认证和隐私权是IPv6的关键特性;

(5）支持更多的服务类型;

(6)允许协议继续演变，增加新的功能，使之适应未来技术的发展;

IPv6地址由8个16进制字段构成。例如:

2001:0db8:85a3:0000:1319:8a2e:0370:7344

lPv6地址的省写，上面的IP地址等价于:

2001:0db8:85a3.:1319:8a2e:0370:7344。

遵守这些规则，如果因为省略而出现了两个以上的冒号，则可以压缩为一个，

但这种零压缩在地址中只能出现一次。因此:

2001:0DB8:0000:0000:0000:0000:1428:57ab2001:0DB8:0:0:0:0:1428:57ab

2001:0DB8::1428:57ab

2001:DB8::1428:57ab

以上都是合法的地址，并且它们是等价的。同时前导的零可以省略，因此:

2001:0DB8:02de::Oe13等价于2001:DB8:2de:e13。

·单播地址(Unicast):用于单个接口的标识符，传统的点对点通信。

·组播地址(Multicast):多播地址，一点对多点的通信，数据包交付到一组计算机中的每一个。IPv6没有广播的术语，而是将广播看做多播的一个特例。

.任播地址(Anycast):泛播地址，这是IPv6增加的一种类型。任播的目的站是一组计算机，但数据包在交付时只交付给其中一个，通常是距离最近的一个。

多播:前缀为11111111

任播:前缀固定，其余位置为0

单播

·可聚合全球单播地址:前缀001。

.本地单播地址:

`    `链路本地:前缀为1111111010 (一般以fe80开头)

`    `站点本地:前缀为1111111011

lPv6规定每个网卡最少有3个IPv6地址，分别是链路本地地址、全球单播地址和回送地址(站点本地地址)。

lPv6把自动IP地址配置作为标准功能，只要计算机连接上网络便可自动f分配IP地址。

√全状态自动配置(Stateful Auto-Configuration): IPv6继承了IPv4动态主机配置协议(DHCP）这种自动配置服务。

√无状态自动配置(Stateless Auto-Configuration):主机通过两个阶段分别获得链路本地地址和可聚合全球单播地址。

.首先主机将其网卡MAC地址附加在链路本地地址前缀11111111010之后，产生一个链路本

地地址，发出一个ICMPv6邻居发现请求，验证其地址唯一性。不唯一则便用随机接口ID组成一个新的链路本地地址。

.主机以链路本地地址为源地址，向本地链路中所有路由器的组播ICMPv6路由器请求报文并返回一个包含可聚合全球单播地址前缀的路由器公告报文响应。

该地址前缀加上自己的接口ID，自动配置一个全球单播地址。使用无状态自动配置，无须用户手工干预就可以改变主机的IPv6地址。

lPv4/ IPv6过渡技术有:

(1）双协议栈技术:双栈技术通过节点对IPv4和IPv6双协议栈的支持，从而支持两种业务的共存。

(2）隧道技术:隧道技术通过在IPv4网络中部署隧道，实现在IPv4网络上对IPv6业务的承载，保证业务的共存和过渡。

隧道技术包括:

6to4隧道；

6over4隧道;

ISATAP隧道。

<a name="cfbw-1706259967110"></a>(3)NAT-PT技术: NAT一PT使用网关设备连接IPv6和IPv4网络。当IPv4和IPv6节点互相访问时，NAT一PT网关实现两种协议的转换翻译和地址的映射。

<a name="g438-1706198637653"></a>**网络接入(有线/无线)**

有线接入：

公用交换电话网络(PSTN)

数宁数据网(DDN)

综合业务数字网(ISDN)

非对称数字用户线路(ADSL)

同轴光纤技术(HFC)

无线接入：

IEEE 802.11(WiFi)

IEEE 802.15(蓝牙Bluetooth)

红外(IrDA)

WAPI

<a name="wbb7-1706260463027"></a>1G~5G

<a name="lxli-1706198497856"></a>**综合布线(★)**

.工作区子系统由信息插座、插座盒、连接跳线和适配器组成。

.水平子系统由一个工作区的信息插座开始，经水平布置到管理区的内侧配线架的线缆所组成。

.管理子系统由交连、互连配线架组成。管理子系统为连接其它子系统提供连接手段。

.垂直干线子系统由建筑物内所有的垂直干线多对数电缆及相关支撑硬件组成，

`    `以提供设备间总配线架与干线接线间楼层配线架之间的干线路由。

.设备间子系统是由设备间中的电缆、连接器和有关的支撑硬件组成，

`    `作用是将计算机、PBX、摄像头、监视器等弱电设备互连起来并连接到主配线架上。

.建筑群子系统将一个建筑物的电缆延伸到建筑群的另外一些建筑物中的通信设备和装置上，是结构化布线系统的一部分，

<a name="3phi-1706275430215"></a>    支持提供楼群之间通信所需的硬件。它由电缆、光缆和入楼处的过流过压电气保护设备等相关硬件组成，常用介质是光缆。

<a name="5dlt-1706198650540"></a>**网络技术扩展**

<a name="jgll-1706198586849"></a>**物联网(IOT)**

物联网(The Internet of Things）是实现物物相连的互联网络 IOT

其内涵包含两个方面:

.物联网的核心和基础仍然是互联网，是在互联网基础上延伸和扩展的网络;

.其用户端延伸和扩展到了任何物体与物体之间，使其进行信息交换和通信

.感知层:识别物体、采集信息。如:二维码、RFID、摄像头、传感器(温度、湿度)

.网络层:传递信息和处理信息。通信网与互联网的融合网络、网络管理中心、信息中心和智能处理中心等

.应用层:解决信息处理和人机交互的问题

关键技术--RFID QRcode

射频识别技术\_(Radio Frequency ldentification，RFID),又称电子标签，是一种通信技术，可通过无线电讯号识别特定目标并读写相关数据，

而无需识别系统与特定目标之间建立机械或光学接触。该技术是物联网的一项核心技术,很多物联网应用都离不开它

RFID的基本组成部分通常包括:标签、阅读器、天线。

二维码是用某种特定的几何图形按一定规律在平面(二维方向上）分布的黑白相间的图形记录数据符号信息的。在代码编制上巧妙地利用构成计算机

内部逻辑基础的“O”、 “1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信

息自动处理.

二维条码中，常用的码制有:Data Matrix，Maxi Code，Aztec,QR Code，Vericode,PDF417,Ultracode，Code 49，Code 16K

.若采用扩展的字母数字压缩格式,可容纳1850个字符

.若采用二进制/ASCII格式,可容纳1108个字节

<a name="xro7-1706275865320"></a>.若采用数字压缩格式，可容纳>710个数字

<a name="pr8x-1706198586851"></a>**云计算(Saas/Paas/Iaas)**

云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需提供给计算机和其他设备。云其实是网络、互联网的一种比喻说法。

云计算的核心思想，是将大量用网络连接的计算资源统一管理和调度，构成一个计算资源池向用户按需服务。提供资源的网络被称为“云”。

狭义云计算指IT基础设施的交付和使用模式，指通过网络以按需、易扩展的方式获得所需资源;广义云计算指服务的交付和使用模式，指通过网络以按需、

易扩展的方式获得所需服务。这种服务可以是IT和软件、互联网相关，也可是其他服务

特点:

.集合了大量计算机，规模达到成千上万

.多种软硬件技术相结合

.对客户端设备的要求低

.规模化效应

√软件即服务(SaaS)    -软件

√平台即服务(PaaS)       -二次开发

<a name="824i-1706275570096"></a>√基础设施即服务(laaS)   -硬件

<a name="1rnn-1706941312871"></a>**===系统架构设计case===**

<a name="nm5q-1706969255961"></a>**google L5设计一个分布式数据库架构**

DESIGN-A DISTRIBUTED DATABASE

RESOURCES:

-taken ·from-somebody's real -google system-design-interview

REQUIREMENTS:

--distributed database

-specify stuff like isolation- level, transactions support,consistency-level

variations:

\1) Read-heavy

\2) write-heavy

\3) Total ordering and heavy writes for ticketmaster/"flashsale"

Most use cases are read-heavy

\------

snapshot isolation

multi-version concurrency control 

use-some- "version-vectors"?

Does it·make sense to have a separate coordinator for all of the shards?-(Like ZooKeeper)

or-does the: request - router - handle coordinating the-shards?

\==========================

write-heavy or read-heavy

read-heavy

B-tree

single-leader

DynamoDB/spanner style 

snapshot isolation

multi-version concurrency control

use some "version vectors""?

aim for sequential consistency

write-heavy

LSM-tree 

leaderless

cassandra/riak/scylla styled

cosmos DB is also some inspiration  here

probably still-snapshot isolation & multi-version concurrencycontrol

( requestrouter stuff might be -different)

just-aim for causal-consistency,

and do risk & cosmos DB's write conflict resolution specifying thing

ticketmaster/distributed linked list/"flash sale" oriented DBwrite-heavy and total ordering is important)

meaning aim for sequential consistency

BUT,we're super write-heavy

single-leader

LSM-tree


<a name="fug2-1707454709063"></a>request router is likely going to stay looking like theread-heavy approach

<a name="g7yu-1707229908505"></a>**.what is total ordering(ordering first 100 custormer)**

Can- you explain -whats total ordering use case briefly?

ordering all the records of the database, for example: flashsales on amazon.com  - first 100 customers will be luckers to get free iphone;  

fairness"

I am going to be using  "weak fairness"

which is the difference between"sequential consistency" and"linearizability - seattle to your IDC 100km, be later 5 sec than others which approach your IDC;

there's actually multiple there.jepsen.io/consistency

------by the way----

distributed system node serizability rank

https://jepsen.io/consistency  

when network down

Total Available

Sticky Available

<a name="qzxn-1707454693080"></a>Unavailable

<a name="ebxf-1707230056989"></a>**.why single leader()**

why single-leader?

simplifies write conflicts

concurrent-writes are imposssible when PostgreSQL is set to serializable-isolation-level

zookeeper -and- etcd or-strongly consistent- KV storesetcd is used by kubernetes internally

<a name="llq0-1707455190492"></a>aim for sequential consistency

<a name="ttmg-1707230034624"></a>**.request router**

\- my opinion is that it is likely mycat;

"request router"

`             `strong consistent kv store(cassadra)

`                             `|

client   -        "request router"    -    (partion1) postgreSQL shard(leader node)  -  sychronus read raplica(follower) -gossinping  read raplic

`                                                `|

`                                           `(partion2) postreSQL shard(leader)     



Strong Read Consistency  :  do request to leader, leader will expi

<a name="tuet-1707455232935"></a>Eventual Consistyency  : do request to  raplica

<a name="aftd-1707229925082"></a>**.variations**

<a name="uk2k-1707457488655"></a>**1.Failover handing**

<a name="btbd-1707457496651"></a>**2.Reblancing after new node added**

<a name="moaq-1707457524278"></a>**3.Leaderless for heavy write-shard**

<a name="wyvq-1707458882987"></a>**4.TicketMasler (and total ordering is necessary**

variations 1-Failover handling

1\.detect the failur

`    `From "Database leader->"phi accruar

2\.do the leader election and switch over to the new leader

1\.detect the failur

2\.prmote The syrchronous read replica(this is our leader election we're doing the 'ring') in the kv store

variation 1 reblancing after new node added

1\.start gossiping data over to the new machines

2\.the machines become sychronuse read replica 

`    `for the partition that they should be promoted to 'leader' of

3\.promotes one of the machines to 'leader' (in kv store)

4\.it is now being router write request;

variation 2 leaderless for heavy write (No total ordering support only causal consistency)

write scenario: wirte to machine 1 ,machine 2

`    `gossiping -> concurrent write is detected!! now we have to do a write conflict resolution

`    `under Last-Write-Win. you just take the write from machine 2 . and that becomes the value on both machines(cassandre dose this)

`    `with  cosmosDB and (IIRC) Riak, you can specify the conflict resolution strategy instead of the defualt of LWW



FOR-THIS-SCENARIO,

basically just follow Variation· 1, but-shard the hell out of.it( fewer read: replicas necessary)

and use· LSM-trees

and - use the serializable isolation level on each leader node

Variation 3-TicketMasler (and total ordering is necessary)->just copy variation 1 but with tollowing changes

-use LSMM-trees

\- fewer read replicas necessary- shard the hell out of it

<a name="m8yp-1706969251706"></a>- seriazation isolation level

<a name="sswx-1706094478181"></a>**===数据密集型应用===**

<a name="ef5t-1644230945318"></a>数据系统基础

<a name="unbe-1677787447006"></a>**设计数据密集型应用**

<a name="kwfx-1677787447007"></a>**1.可靠性、可拓展性、可维护性能**

<a name="zrzj-1642646974315"></a>小结：一个应用必须满足各种需求才称得上有用

<a name="lykw-1644227240038"></a>**-功能性需求：CRUD**

<a name="b2tu-1644227249556"></a>**-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性**

<a name="qqm5-1644227303238"></a>**.可靠性：**

<a name="vdpc-1699843965882"></a>以为着即使发生故障，系统也能正常工作。

<a name="mk9e-1644227360160"></a>故障可能发生在硬件（通常是随机和不相关的）

<a name="w7by-1644227387308"></a>软件（通常是系统性的bug,很难处理）

<a name="dozl-1644227415061"></a>人类（不可避免的时不时出错）

<a name="fvz4-1644227444254"></a>**容错技术**可以对终端用户隐藏某些类型的故障。

<a name="7xms-1644228225080"></a>**.可扩展性：** 

<a name="t59j-1699843967201"></a>意味着即使在增加负载的情况下也能保持性能的策略。

<a name="gqfn-1644228379215"></a>为了讨论可拓展性，首先要定量描述负载和性能的方法。

<a name="krij-1644228405843"></a>推特主页时间线的例子，介绍描述负载参数，并将响应时间百分点作为衡量性能的一种方式。头部阻塞、尾部延迟。(有很多人通过将工作负载迁移到低延迟、自适应的GC来控制尾部延迟-infoQ java趋势)

<a name="bynr-1644228470161"></a>在可扩展的系统中可以添加**处理容量** 以在高负载下保持可靠。

推特2012年11月发布的数据，主要两个业务：

发布推文：

`    `用户可以向粉丝发布新消息（平均4.6k 请求/秒 ， 峰值超12k 请求/ 秒） TPS

主页时间线：

<a name="mnug-1708269817280"></a>    用户可以查阅他们关注的人发布的推文（300K 请求每秒） 

<a name="elzq-1644228563046"></a>**.可维护性：**   

<a name="vg1v-1699843968229"></a>可维护性实质上是关于工程师和运维团队生活质量的。

<a name="mq1x-1644231096441"></a>良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。

<a name="qj5f-1644228656997"></a>良好的可操作性意味这对系统的健康状态具有良好的可见性，并拥有有效的管理手段。

<a name="gwsd-1644231020558"></a><a name="jufm-1677787447008"></a>**2.数据模型与查询语言**

<a name="guby-1644404619396"></a>本章小结：数据模型时一个巨大的课题，在本章中，我们快速浏览了各种不同的模型。以便激起兴趣，更多的了解**最适合你的应用的需求模型**。（数据库选型）

<a name="o6we-1644404838474"></a>在历史上，**数据最开始被表示为一颗大树（层次型结构**），但是这不利于表示多对多的关系，所以发明了

<a name="pgu6-1699844351041"></a>**-关系模型**

<a name="jayo-1699844352979"></a>来解决这个问题。

<a name="kfpd-1644410618294"></a>**-NoSql (es,redis)**

<a name="uzbw-1699844301003"></a>**通常**不会为存储的数据强制一个模式，这可以使应用程序更容易适应不断变化的需求。

<a name="0p23-1644410807294"></a>**1.文档数据库:MongoDB**

<a name="9rlb-1699844336493"></a>数据通常是自我包含的，而且文档之间的关系非常稀少

<a name="09bl-1644410666587"></a>  **2.图形数据库 ：**

<a name="imif-1699844337670"></a>与文档数据库相反的场景-任意事务都可能与任何事务相关联

<a name="6fxw-1644410924417"></a>**-其它模型(基因序列)**

<a name="he0m-1699844309707"></a>** 基因组 通常需要 **序列相似性搜索，意味着一**个很长的字符串，并在一个拥有类似但不完全相同的字符串的大型数据库中寻找匹配。这里所描述的数据库都不能处理这种用法。研究人员编写了想GenBank专门的基因组数据库软件。

<a name="opsf-1644411138194"></a>                 粒子物理学家进行大数据类型的大规模数据分析。粒子对撞机（LHC）这样的项目可以工作在数百亿兆字节的范围内。这样的规模下，需要指定解决方案来阻止硬件成本的失控。

<a name="pnul-1644935322505"></a><a name="sm0u-1677787447009"></a>**3.存储与检索**

<a name="ycte-1644935336049"></a>本章小结：数据库如何处理存储何检索。将数据存储在数据库中会发生什么，再次查询数据库会发生什么？

<a name="bivs-1644935398311"></a>在高层次上，存储引擎分两大类：

<a name="bhcv-1644935436804"></a>**-优化事务处理（OLTP）transaction** 

<a name="tbhw-1699844517372"></a>**1.OLTP系统通常面向用户，大量的请求。**

<a name="fnev-1644935714127"></a>**2.磁盘寻道时间往往是这里的瓶颈。**

<a name="cjwp-1644935609899"></a>**3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。**

<a name="jg7s-1699844443567"></a>**-优化分析（OLAP）analys**

<a name="n8me-1644935726822"></a>    OLTP数据 copy and translatin 转换为适合业务分析的数据副本 to 数据仓库（OLAP）

<a name="3cwp-1644935731444"></a>OLAP**数据仓库**和类似的分析系统不太知名，因为只要由业务分析人员使用，而不是由最终用户使用

<a name="s6pt-1644935799372"></a>处理比OLTP系统少得多得查询量，但是每个查询通常要求很高，短时间内扫描百万条记录。

<a name="cyhe-1644935862917"></a>磁盘带宽（不是查找时间）往往是瓶颈，列式存储是这种工作负载的流行解决方案。

<a name="pjd1-1703887811615"></a>**1.列式储存(投影操作，压缩技术，聚合过滤)**

OLAP TB,PB级别的数据(几百列)情况下，索引的相关性就会下降很多，磁盘带宽往往是瓶颈

解决方案-列式存储

1\.将表头设置为列文件名，文件存储单列内容、

2\.如需第23行，则将需要的列文件的第23项形成表的第23行

优势：

.投影操作：仅需检索所需的列，大大减少读取的数据量。

.压缩技术：通常采取高度优化的压缩技术。-相邻的数据通常具有相似的值。减少存储空间，提高查询性能

.向量化处理：通常采用向量化处理，意味着可以一次操作整个数据向量，而不是逐个处理行。-并行处理和SIMD指令集优化非常有利

.聚合操作：在SUM、AVG等聚合操作上表现良好

.过滤操作：特定列过滤更快

.分析查询：部分查询而不是全部

<a name="kg2a-1703885936042"></a>Apache: Cassandra、 HBase

<a name="8sgm-1644935924013"></a>**-OLTP两大主流学派的存储引擎：**

<a name="i55y-1644935943748"></a>**1.日志结构学派**

<a name="4nm8-1644935988277"></a>只允许附加到文件和删除过时文件，但不会更新已经写入的文件。（高效，顺序IO?）

<a name="6ymo-1644936029696"></a>Bitcask, SSTables, LSM树，LevelDB, Cassandra, HBase, Lucene等都属于这个组。

<a name="h3il-1644935977285"></a>**2.就地更新学派**

<a name="2w0c-1644936091115"></a>将磁盘视为一组可以覆盖的固定大小页面。（随机IO?）

<a name="hpzs-1644936142472"></a>B树是这种哲学的最大例子，被用在所有主要的关系数据库中，还有许多非关系数据库。

<a name="fil5-1644936170765"></a><a name="vypn-1644936170925"></a>日志结构的存储引擎是相对较新的发展，他们的主要想法是，系统地将随机访问写入顺序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短的介绍。

<a name="a5tj-1644936526197"></a>然后我们从存储引擎的内部绕开，看看典型的数据仓库的高级架构。这一背景说明了为什么分析工作负载和OLTP差别很大：

<a name="nyml-1644936619727"></a>当您的查询需要在大量（几百列）的行中顺序扫描时，索引的相关性就会下降很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读取的数据量。我们讨论了列式存储如何帮助实现这一目标。

<a name="2akd-1644935679338"></a>作为一名应用开发人员，如果您掌握了有关存储引擎内部知识，那么就能更好地那种工具最适合您的特定应用程序。如果需要调整库的参数，这种理解可以让您设想一个更高或者更低的参数可能会产生什么效果。

<a name="ohao-1644936963029"></a>尽管本章不能让你成为一个特定存储引擎的调参专拣，但它至少有大概率使你有了足够的概念与词汇储备去读懂数据库的文档，从而选择合适的数据库。

<a name="en4q-1644936942676"></a><a name="lbs1-1677787447010"></a>**4.编码（序列化）与演化(XML,JSON,CSV)**

<a name="18rw-1644940257792"></a>在本章中，我们研究了将数据结构转换为网络中的字节或磁盘上的字节的几种方法。编码的细节影响其效率，更重要的是应用程序的体系结构和部署它们的选项。

<a name="bfvx-1644940365841"></a>特别是，许多服务需要支持滚动升级（灰度发布），其中新版本的服务逐步部署到少数节点，而不是同时部署到所有节点。滚动升级允许在不停机的情况下发布新版本的服务（从而鼓励在罕见的大型版本上频繁发布小型版本），并使部署风险降低（允许在影响大量用户之前检测并回滚有故障的版本）。这些属性对于可演化性，以及对应用程序进行更改的容易性都是非常有利的。

<a name="w4qv-1644940598057"></a>在滚动升级期间，或出于其它原因，我们必须假设不同的节点正在运行我们的应用程序代码的不同版本。因此，在系统周围流动的所有数据都是以提供向后兼容性（新代码可以读取旧数据-服务端）和向前兼容性（旧代码可以读取新数据-客户端）的方式进行编码是重要的。我们讨论了几种数据编码格式极其兼容性：

<a name="zw4l-1644940805237"></a>编程语言特定编码仅限于单一编程语言，并且往往无法提供向前和向后兼容性。

<a name="1zx9-1644940881501"></a>JSON, XML和CSV等文本格式非常普遍，其兼容性取决于如何使用它们。他们有可选模式语言，这有时是有用的，有时是一个障碍。这些数据格式对于数据类型有些模糊，所以你必须小心数字和二进制字符串。

<a name="q8m7-1644942050475"></a>像Thrift, Protocol Buffers和Avro这样的二进制模式驱动格式允许使用清晰定义的向前和向后兼容性语义进行紧凑，搞笑的编码。这些模式可以用于静态类型语言的文档和代码生成。但是，他们有一个去缺点，就是在数据可读之前需要对数据进行解码。

<a name="hqvm-1644942192088"></a>我们还讨论了几种数据流的几种模式，说明了数据编码是重要的不同场景：

<a name="c94y-1644942236778"></a>数据库，写入数据库的进程对数据进行编码，并从数据库读取进程对其进行解码

<a name="kcmv-1644942289426"></a>RPC 和 REST API, 客户端对请求进行编码，服务器对请求进行解码并对相应进行编码，客户端最终对相应进行解码。

<a name="nvcq-1644942366178"></a>异步消息传递（使用消息代理或参与者），其中节点之间通过发送消息进行通信，消息由发送者编码并由接收者解码。

<a name="oxsf-1644942481249"></a>我们可以小心地得出这样的结论：向前兼容性和滚动升级在某种成都上是可以实现的。愿您的应用程序的演变迅速，敏捷部署。

<a name="rmsh-1646310193756"></a><a name="d4ge-1677787447011"></a>**分布式系统**

<a name="4p9n-1677787447012"></a>**4.分布式数据**

<a name="gr0m-1646310278506"></a>本章考察了复制的问题，复制可以用于几个目的：

<a name="o4ag-1646310813851"></a>**1.高可用性**

<a name="r7ua-1646310833943"></a>即使在一台机器（或多台机器，或整个数据中心）停机的情况下也能保持系统正常运行

<a name="snwm-1646310894841"></a>**2.断开连接的操作**

<a name="x2dq-1646310900787"></a>允许应用程序在网络中断时继续工作

<a name="evly-1646310918322"></a>**3.减少延迟(节点近)**

<a name="iz8f-1646310928916"></a>将数据放置在距离用户较近的地方，以便用户能够更快地与其交互

<a name="itsh-1646310968967"></a>**4.可拓展性**

<a name="ncek-1646310974776"></a>能够处理比单个机器更高的读取量可以通过对副本进行读取来处理

<a name="ybmg-1646311013702"></a><a name="a6ti-1646311014184"></a>尽管是一个简单的目标-在几台机器上保留相同数据的副本，但复制确实一个非常棘手的一个问题。它需要仔细考虑并发和所有可能出错的事情，并处理这些故障的后果。

<a name="cpjg-1646311086181"></a>至少，我们需要处理不可用的节点和网络中断（甚至不考虑更隐蔽的故障，例如由软件错误导致的无提示数据损坏）。

<a name="gbgq-1646311175182"></a>**-复制的三种主要方法：**

<a name="wg6v-1646311185918"></a>**1.单主复制**

<a name="ehug-1646311426407"></a>客户端将所有写入操作发送到单个节点（领导者），该结点将数据更改事件流发送到其它副本（追随者）。

<a name="wgge-1646311567456"></a>读取可以再任何副本中执行，但从追随者读取可能是陈旧的 （最终一致性问题）

<a name="ftqb-1646311200843"></a>**2.多主复制**

<a name="ak8v-1646311613462"></a>客户端发送每个写入到几个领导节点之一，其中任何一个都可以接受写入。领导者将数据更改事件流发送给彼此以及任何跟随着节点。

<a name="4xbf-1646311410600"></a>**3.无主复制**

<a name="b6zn-1646311685371"></a>客户端发送每个写入到几个节点，并从多个节点并行多去，以检测和纠正具有陈旧数据的节点。

<a name="tyus-1646311850435"></a><a name="dzsw-1646311850942"></a>单主复制是非常流行的。多领导和无领导复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。

<a name="sgmj-1646311002454"></a>我们讨论了一些有助于决定应用程序在复制滞后时的行为的

<a name="nlnz-1699845075606"></a>**-一致性模型：<https://jepsen.io/consistency>**

<a name="anqq-1646312272172"></a>**1.写后读**

<a name="jvwc-1646312310729"></a>用户应该总是看到自己提交的数据。

<a name="hedn-1646312288296"></a>**2.单调读**

<a name="wxgc-1646312331720"></a>用户在一个时间点看到数据后，他们不应该在某个早期时间点看到数据

<a name="fizh-1646312291911"></a>**3.一致前缀读**

<a name="5okd-1646312382954"></a>用户应该将数据视为具有因果意义的状态：例如，按照正确的顺序查看问题及其答复

<a name="drau-1646310922027"></a><a name="eumz-1646312681469"></a>多领导者和无领导者复制方法所固有的并发问题：允许多个写入并发发生冲突。研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者他们是否同时发生。

<a name="xukg-1646312787143"></a>还谈到了通过合并并发更新来解决冲突的方法。

<a name="cbey-1646310922523"></a><a name="j5o0-1704983008475"></a>**7.事务**

<a name="du4g-1704983767151"></a>**.简化故障失败的机制**

<a name="rfev-1704983016027"></a>数据库软件、硬件可能在任意时刻发⽣故障（包括写操作进⾏到⼀半时）。

<a name="hfad-1704983671342"></a>应⽤程序可能在任意时刻崩溃（包括⼀系列操作的中间）。

<a name="3lnd-1704983671344"></a>⽹络中断可能会意外切断数据库与应⽤的连接，或数据库之间的连接。

<a name="av8h-1704983671346"></a>多个客户端可能会同时写⼊数据库，覆盖彼此的更改。

<a name="emwl-1704983671348"></a>客户端可能读取到⽆意义的数据，因为数据只更新了⼀部分。

<a name="nhvj-1704983671350"></a>客户之间的竞争条件可能导致令⼈惊讶的错误。

<a name="5xk9-1646310922755"></a><a name="vo8p-1704983742288"></a>**事务（transaction）** ⼀直是简化这些问题的⾸选机制。整个事务要么成功（**提交（commit）**）要么失败（**中⽌（abort）**，**回滚（rollback）**）

<a name="pnng-1646310922957"></a>**简化应⽤编程模型  安全保证（safety guarantees）**

<a name="lyog-1646310871301"></a>深⼊**并发控制**的领域   如何实现**读已提交**，**快照隔离**和**可串⾏化**等隔离级别

<a name="k9de-1704984009883"></a>**.事务的棘手问题**

<a name="65nh-1704984028565"></a>**原⼦性（Atomicity）**

<a name="cfkv-1704984213641"></a>**能够在错误时中⽌事务，丢弃该事务进⾏的所有写⼊变更的能⼒。** 或许 **可中⽌性（abortability）是更好的术语**

<a name="6b47-1705118743952"></a>**要么全部成功，要么全部失败，简化系统复杂度， 避免“部分成功失败”等中间态复杂逻辑的修正。**

<a name="qeub-1646310871673"></a>**⼀致性（Consistency）**

<a name="nj8u-1704984284264"></a>**对数据的⼀组特定陈述必须始终成⽴**。即**不变量（invariants）**

<a name="rpju-1646310871817"></a>**隔离性（Isolation）**

<a name="wbo9-1704984301328"></a>**同时执⾏的事务是相互隔离的，快照隔离（snapshot isolation）** 的功能，**这是⼀种⽐可序列化更弱的保证**【8,11】-MVCC

<a name="aq1q-1646310872064"></a>**持久性（Durability）**

<a name="ix2r-1704984436018"></a>硬件故障或数据库崩溃，写⼊的任何数据也不会丢失。

<a name="sesd-1646310817481"></a><a name="yi8z-1704985578742"></a>参考mysql的事务、MVCC及锁

<a name="rlxa-1705080720222"></a>**弱隔离级别**：读已提交，可重复读，序列化

<a name="2jhg-1705080777447"></a>并行事务非阻塞态，MVCC快照读

<a name="avnt-1705080821368"></a>比较并设置(CAS)

<a name="enui-1704985776096"></a>**分布式系统的麻烦**

<a name="rp9s-1705080859004"></a>**一致性共识**

<a name="ssaq-1705080889744"></a> CAP理论-参考微服务架构篇章

<a name="cys8-1705080619829"></a>**分布式事务**

<a name="bjec-1705081008345"></a>**2PC提交**

<a name="vaax-1705118249954"></a>coodinator协调子事务，子事务单独执行完，在准备阶段询问是否可提交

<a name="7zwc-1705118288968"></a>.全部为是，则分别提交。

<a name="3b8s-1705118337513"></a>.其中有否，则中断回滚。

<a name="dyd0-1705118358884"></a>**3PC提交**

<a name="stoe-1705118368214"></a>在提交阶段，如果子事务进程crash,或者协调者崩溃的时的解决方案，弱原子性，最终一致性。

<a name="nlrk-1705118500709"></a>许多coodinator不支持高可用或者只支持基本的复制

<a name="pudp-1705080909535"></a>**实践中的分布式事务**

<a name="hu69-1705081074207"></a>**数据库内部的分布式事务**

<a name="jhqw-1705080950920"></a>VoltDB 与mysql Cluster 的NDB引擎就有这样的内部事务支持。

<a name="mzcr-1705118236321"></a><a name="ozc0-1705080997483"></a>**XA事务(扩展架构（eXtended Architecture)**

<a name="ngse-1705081186469"></a>跨异构技术实现两阶段提交的标准，：许多传统关系数据库（包括PostgreSQL，MySQL，DB2，SQL Server和Oracle）和消息代理（包括ActiveMQ，HornetQ，MSMQ和IBM MQ）都⽀持XA。

<a name="otul-1705081462777"></a>XA事务是使⽤**Java事务API（**JTA, Java Transaction API）实现的，⽽许

<a name="wfx9-1705081463074"></a>多使⽤Java数据库连接（**JDBC**, Java Database Connectivity）的数据库驱动，以及许多使⽤Java消息服务（JMS）API的消息代理**都⽀持Java事务API**（JTA）。

<a name="0dfj-1705081511181"></a>Spring事务基于JDBC事务。

<a name="ssso-1705081563263"></a>**怀疑时持有锁**

<a name="rehq-1705081588086"></a>读已提交，数据库事务通常获取待修改的⾏上的⾏级排他锁，以防⽌脏写(值为NULL，事务A先写，事务B写后提交，A回滚，值变NULL)。

<a name="ue7i-1705118474108"></a>在协调者崩溃时，这些锁将会被coodinator永久持有，如果管理员不手动释放。


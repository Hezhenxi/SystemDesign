# 系统设计与优化&amp;DDIA :see_no_evil:
## 目录


<a name="3060-1621846615933"></a><a name="eflu-1726766098294"></a>[一.数据库设计](#jeyl-1677787446995)

<a name="cpfq-1726766098296"></a>[1. 关系型数据库](#5hya-1677787446996)

<a name="sxyl-1726766098298"></a>[.E-R图，由台湾工程师提出的设计概念](#ohc5-1621692571287)

<a name="3wxe-1726766098300"></a>[.流程图-业务逻辑相关，系统用户动作。抽象出E-R图](#5ocb-1645598528868)

<a name="rqzq-1726766098302"></a>[1.1 E-R图 ](#gzqe-1677787446997)

<a name="ffxv-1726766098304"></a>[1.根据名词抽象出实体](#r1ac-1621692724628)

<a name="ppre-1726766098306"></a>[2.名词找属性](#d2fl-1621692745600)

<a name="u3z3-1726766098308"></a>[3.实体间联系](#dwkp-1621692752824)

<a name="fqcb-1726766098310"></a>[.状态图](#53bo-1621692829033)

<a name="ly4k-1726766098312"></a>[1.2 转化成数据库设计（公式）](#c2cy-1677787446998)

<a name="frhm-1726766098314"></a>[.1 对1 关系 往记录少的乙方加主键](#xmox-1621692858500)

<a name="exiz-1726766098316"></a>[.1对n 关系 ，往 n 实体加关联主键 ](#mdr8-1621692924289)

<a name="j1nn-1726766098318"></a>[. n对 m 关系，需要一个关联表作映射关联](#hd3i-1621692960576)

<a name="qzrp-1726766098320"></a>[2.数据类型选择](#szqu-1715100194538)

<a name="epvf-1726766098322"></a>[整数类型（Integer Types）](#0rub-1715100184335)

<a name="lriv-1726766098324"></a>[浮点数类型（Floating-Point Types）](#j4ut-1715100184343)

<a name="vrf9-1726766098326"></a>[日期和时间类型（Date and Time Types）](#fjm4-1715100184359)

<a name="lb04-1726766098328"></a>[其他类型](#tofd-1715100184367)

<a name="6yhv-1726766098330"></a>[二.系统优化](#cdso-1677787447000)

<a name="y8sd-1726766098332"></a>[应用整体的优化](#3qep-1642647362896)

<a name="xgp2-1726766098334"></a>[-cpu -> 纳秒级别](#knge-1642647371136)

<a name="jqry-1726766098336"></a>[1.多线程和并发编程](#ovup-1704437622969)

<a name="jitl-1726766098338"></a>[2.JNI ](#ufpl-1704437634986)

<a name="xf0g-1726766098340"></a>[3.JIT/AOT编译](#ixb5-1704437634987)

<a name="rnzp-1726766098342"></a>[4.算法优化](#kr1f-1704437634988)

<a name="ta2x-1726766098344"></a>[-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)](#1xur-1642647384168)

<a name="kfly-1726766098346"></a>[1.JVM内存管理](#7hi9-1704437851514)

<a name="qwjk-1726766098348"></a>[2.缓存](#te7c-1704437851799)

<a name="qbww-1726766098350"></a>[3.消息中间件](#bqty-1704437851800)

<a name="gupg-1726766098352"></a>[-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)](#ziti-1642647439005)

<a name="mxpt-1726766098354"></a>[1.减少磁盘io](#zups-1704437900079)

<a name="7uuh-1726766098356"></a>[2.数据压缩   ](#u3ok-1704438035018)

<a name="z0nv-1726766098358"></a>[-网络传输/系统交互 -> 秒级 (减少io，连接池化) ](#irbp-1642647458856)

<a name="clnx-1726766098360"></a>[1.减少网络请求   ](#6qil-1704438276193)

<a name="jfe9-1726766098362"></a>[2.使用CDN](#p5dt-1704438283633)

<a name="k70c-1726766098364"></a>[3.Sockets异步通信                                      ](#zhp8-1704438283634)

<a name="g0gr-1726766098366"></a>[项目架构层面的优化](#3l0l-1704424353262)

<a name="d2ny-1726766098368"></a>[-多级缓存](#8o8s-1704424396933)

<a name="caeo-1726766098370"></a>[-应用层](#trcg-1704438366333)

<a name="rqyp-1726766098372"></a>[.代码优化](#68oa-1704438530062)

<a name="7rxn-1726766098374"></a>[.数据库优化](#clmf-1704438530257)

<a name="idml-1726766098376"></a>[.日志优化](#md03-1704438530259)

<a name="sgei-1726766098378"></a>[-监控与调优](#ocux-1704438477879)

<a name="qqyc-1726766098380"></a>[.性能监控：](#vdq2-1704438556836)

<a name="k7fy-1726766098382"></a>[.分析和调优](#t29d-1704438557094)

<a name="mguj-1726766098384"></a>[-分布式系统架构](#ukjf-1704424419442)

<a name="v3sw-1726766098386"></a>[ .负载均衡](#a0bx-1704438677201)

<a name="zzme-1726766098388"></a>[.分布式缓存](#xn9x-1704438687994)

<a name="klca-1726766098390"></a>[.服务降级和容错](#zcdp-1704438687996)

<a name="db2i-1726766098392"></a>[读写层面](#six7-1642647372926)

<a name="sncp-1726766098394"></a>[.读优化](#g4uv-1704732583614)

<a name="kzws-1726766098396"></a>[1.缓存](#uuzh-1704732602620)

<a name="ktzw-1726766098398"></a>[2.索引](#qobc-1704732605892)

<a name="2dbd-1726766098400"></a>[3.减少io/批量读/非阻塞io](#zlg9-1704732609048)

<a name="mvd3-1726766098402"></a>[4.减少多余数据加载/列式存储读](#fpjd-1704732631316)

<a name="ih5k-1726766098404"></a>[.写优化](#oyob-1704732598377)

<a name="ouym-1726766098406"></a>[1.异步写](#6jmb-1704732509150)

<a name="dak4-1726766098408"></a>[2.并发写](#tkwp-1704732723564)

<a name="plx2-1726766098410"></a>[3.批量写](#hewz-1704732862030)

<a name="gzlh-1726766098412"></a>[4.优化算法和数据结构](#ccd8-1704732727854)

<a name="yf67-1726766098414"></a>[5.缓存写](#eqd9-1704732736281)

<a name="upgn-1726766098416"></a>[6.非阻塞io](#hyq8-1704732768916)

<a name="lpej-1726766098418"></a>[1.分控系统优化复盘](#tncv-1677787447001)

<a name="vr7s-1726766098420"></a>[1.1 数据库系统](#ydq7-1677787447002)

<a name="b4ct-1726766098422"></a>[1.2 sql慢](#wxdd-1677787447003)

<a name="bbes-1726766098424"></a>[1.3 接口慢](#olpb-1677787447004)

<a name="hycz-1726766098426"></a>[高并发系统设计](#wrwk-1642647280506)

<a name="oeub-1726766098428"></a>[1.满足大规模用户同时访问，提供良好响应时间和性能](#8ien-1704757782146)

<a name="ntbu-1726766098430"></a>[2.设计之初就要考虑伸缩性和容错性是非常重要的](#xy0g-1704757785190)

<a name="vckp-1726766098432"></a>[.垂直伸缩 ](#wr12-1704947861599)

<a name="wn2r-1726766098434"></a>[.水平伸缩](#bizh-1704947959744)

<a name="zsai-1726766098436"></a>[1.分布式架构](#fvzi-1704756770858)

<a name="pyq4-1726766098438"></a>[.微服务架构](#ywzr-1704756872033)

<a name="0fmj-1726766098440"></a>[.分布式计算](#xgna-1704756877646)

<a name="o4sq-1726766098442"></a>[2.负载均衡](#wnfy-1704756775272)

<a name="nwgr-1726766098444"></a>[.负载均衡](#h6nf-1704756891918)

<a name="0tec-1726766098446"></a>[.水平扩展](#c8zr-1704756894402)

<a name="zra7-1726766098448"></a>[3.数据库设计](#wxjk-1704756782840)

<a name="dxd7-1726766098450"></a>[.读写分离](#lxca-1704756910837)

<a name="i9d9-1726766098452"></a>[.数据库分片](#p7d2-1704756922362)

<a name="qnf5-1726766098454"></a>[.缓存](#hxjt-1704756963988)

<a name="e3ew-1726766098456"></a>[4.缓存优化](#iivs-1704756788012)

<a name="fzf2-1726766098458"></a>[.分布式缓存](#cvui-1704756971791)

<a name="k28v-1726766098460"></a>[.本地缓存](#ysly-1704756979122)

<a name="2mme-1726766098462"></a>[.缓存预热](#rqwj-1704756986363)

<a name="fvw7-1726766098464"></a>[5.消息队列](#so9h-1704756800253)

<a name="50s5-1726766098466"></a>[.异步处理](#sxlo-1704756996000)

<a name="k6hg-1726766098468"></a>[.削峰填谷](#llm2-1704757002994)

<a name="jqwq-1726766098470"></a>[6.分布式事务](#n39o-1704756805232)

<a name="xayu-1726766098472"></a>[.两阶段提交](#5bhj-1704757017700)

<a name="epvm-1726766098474"></a>[.补偿事务](#becc-1704757028036)

<a name="a850-1726766098476"></a>[7.高可用和容错](#wgkk-1704756813448)

<a name="xglg-1726766098478"></a>[.多地域部署](#akwz-1704757035393)

<a name="at5d-1726766098480"></a>[.设计容错](#3nxv-1704757055271)

<a name="hvvk-1726766098482"></a>[1. 熔断限流](#g3xx-1704757371028)

<a name="xwj3-1726766098484"></a>[2. 多节点服务](#jafy-1704757374368)

<a name="i1wg-1726766098486"></a>[8.监控和性能调优](#ilyo-1704756820772)

<a name="pkk5-1726766098488"></a>[.实时监控](#kpwq-1704757064566)

<a name="pppk-1726766098490"></a>[.性能测试](#shf4-1704757066453)

<a name="pxlk-1726766098492"></a>[9.安全性设计](#2pry-1704756830245)

<a name="cl2u-1726766098494"></a>[.防御性编程](#pkiw-1704757078583)

<a name="wwd0-1726766098496"></a>[.访问控制](#g4l1-1704757084924)

<a name="xa5i-1726766098498"></a>[10.水平扩展](#1tsd-1704756838192)

<a name="dbqt-1726766098500"></a>[.自动化部署](#r1dd-1704757092061)

<a name="ljvw-1726766098502"></a>[.云服务](#7mhk-1704757104117)

<a name="oewt-1726766098504"></a>[高并发性能指标](#rpxb-1677787447005)

<a name="3plp-1726766098506"></a>[QPS(每秒请求)](#klnv-1704761369323)

<a name="1zax-1726766098508"></a>[TPS(每秒事务)](#zvlz-1704761369324)

<a name="tvb6-1726766098510"></a>[RT(响应时间)](#gvrn-1704761369325)

<a name="ghmv-1726766098512"></a>[(原子操作)并发编程中保证数据一致性/安全的方法](#ysmj-1709309531982)

<a name="3a12-1726766098514"></a>[原子性+悲观锁：各种锁机制](#fdxy-1709308630108)

<a name="qbv6-1726766098516"></a>[.（锁+事务/ 分布式锁+分布式事务）](#v06l-1709312268021)

<a name="s7me-1726766098518"></a>[.  CASmysql版本号实现 (前提是数据库的update已经是原子写：mysql update排它锁）](#k0op-1709312304164)

<a name="slno-1726766098520"></a>[原子性+乐观锁/不加锁: CAS原子操作(java原子类)，](#qth5-1709308703202)

<a name="prwl-1726766098522"></a>[CAS底层实现原理](#g3uo-1709309147469)

<a name="dpai-1726766098524"></a>[总线锁定（Bus Locking）：](#qpbw-1709308842021)

<a name="fv4z-1726766098526"></a>[缓存一致性协议（Cache Coherence Protocol）：](#ikm2-1709308842025)

<a name="wyoi-1726766098528"></a>[指令序列化（Instruction Serialization）：](#wpeu-1709308842029)

<a name="wb8x-1726766098530"></a>[不同的场景适用哪种锁](#olfu-1709309769107)

<a name="qdkj-1726766098532"></a>[.共享数据的读写操作：](#y60t-1709309615585)

<a name="c1qr-1726766098534"></a>[适用措施：读写锁（ReadWrite Lock）、互斥锁（Mutex）、原子操作、无锁算法。Copy on Write优化读写锁](#lqad-1709309615587)

<a name="x4de-1726766098536"></a>[.并发容器的操作：](#fsfa-1709309615591)

<a name="zitw-1726766098538"></a>[适用措施：线程安全的容器类（如ConcurrentHashMap、ConcurrentLinkedQueue）、原子操作。](#rs2n-1709309615593)

<a name="ml6h-1726766098540"></a>[.多个线程协作的场景：](#xdpv-1709309615597)

<a name="f6wj-1726766098542"></a>[适用措施：信号量（Semaphore）、条件变量（Condition Variable）。](#uzlr-1709309615599)

<a name="rsdh-1726766098544"></a>[.分布式系统的并发操作：](#0aah-1709309615603)

<a name="e1et-1726766098546"></a>[适用措施：分布式锁、分布式事务。](#wlhe-1709309615605)

<a name="sfkt-1726766098548"></a>[.不可变数据的并发访问：](#angi-1709309615609)

<a name="km86-1726766098550"></a>[适用措施：不可变数据结构、原子操作。](#pga0-1709309615611)

<a name="splf-1726766098552"></a>[.高性能要求的并发操作：](#pw5v-1709309615615)

<a name="cvtm-1726766098554"></a>[适用措施：无锁算法、并发数据结构。 -CAS乐观锁](#plv6-1709309615617)

<a name="pmj1-1726766098556"></a>[互斥访问：](#62mg-1709309976431)

<a name="lopt-1726766098558"></a>[.互斥锁（Mutex）：](#0qt3-1709307350160)

<a name="dztq-1726766098560"></a>[.原子操作：](#7xva-1709307350164)

<a name="nljl-1726766098562"></a>[.临界区（Critical Section）：](#r8cl-1709307350168)

<a name="wtm7-1726766098564"></a>[.读写锁（ReadWrite Lock）：主要用于避免脏读](#occj-1709307350172)

<a name="7oy6-1726766098566"></a>[.信号量（Semaphore）：](#vej9-1709307350176)

<a name="tabf-1726766098568"></a>[.条件变量（Condition Variable）：](#ssge-1709307350180)

<a name="4dc8-1726766098570"></a>[.无锁算法（Lock-Free Algorithms）：](#zk0j-1709307350184)

<a name="tzpy-1726766098572"></a>[.数据拷贝-写时复制（Copy-on-Write）：优化读写锁，写时复制且串行执行(锁)，读不加锁](#tiqo-1709307350188)

<a name="xqar-1726766098574"></a>[.线程安全的数据结构：](#b8ca-1709307350192)

<a name="xmvf-1726766098576"></a>[===系统架构设计师===](#nyrv-1709307688718)

<a name="0oqz-1726766098578"></a>[系统工程与信息系统基础](#mpwu-1704949756608)

<a name="ixod-1726766098580"></a>[.系统工程方法](#2gzz-1704980837071)

<a name="fc3g-1726766098582"></a>[.系统工程生命周期阶段](#mk93-1704952875199)

<a name="imxg-1726766098584"></a>[.系统工程生命周期方法](#ny2c-1704952893636)

<a name="bmxb-1726766098586"></a>[.信息系统建设原则](#shmt-1704952904062)

<a name="muma-1726766098588"></a>[.信息系统开发方法](#itje-1704951812273)

<a name="4tl6-1726766098590"></a>[原型法](#bnzq-1705819374009)

<a name="ocsj-1726766098592"></a>[结构化法-瀑布型](#ujj3-1705819377863)

<a name="fvay-1726766098594"></a>[形式化法-数模](#8wek-1705819398251)

<a name="bzk5-1726766098596"></a>[敏捷方法](#jeuk-1705819392097)

<a name="n8ok-1726766098598"></a>[.信息系统分类](#w8yd-1704980881013)

<a name="sz8r-1726766098600"></a>[业务处理系统TPS](#hlhq-1705819204285)

<a name="azxq-1726766098602"></a>[管理信息系统MIS](#oksn-1705819204735)

<a name="izhf-1726766098604"></a>[决策支持系统DSS](#lwm7-1705819204736)

<a name="mk7v-1726766098606"></a>[专家系统ES](#bmeu-1705819204737)

<a name="gciy-1726766098608"></a>[办公自动化系统OAS](#kffq-1705819204738)

<a name="rnzp-1726766098610"></a>[企业资源系统ERP](#k2px-1705819204739)

<a name="a45s-1726766098612"></a>[过程模型](#f98t-1704981918920)

<a name="uzhb-1726766098614"></a>[瀑布模型](#yk4j-1705841608124)

<a name="b4yc-1726766098616"></a>[V模型【瀑布变种-测试贯穿】](#oryp-1705841608705)

<a name="vpqy-1726766098618"></a>[原型模型](#b0cp-1705841621350)

<a name="i3rg-1726766098620"></a>[螺旋模型【原型+瀑布 风险】](#sfqi-1705841608707)

<a name="0e6m-1726766098622"></a>[构件组装模型/基于构件的开发方法](#kbjw-1705841608709)

<a name="e4xi-1726766098624"></a>[快速应用开发RAD【瀑布+构件组装】](#mvze-1705841627436)

<a name="zydz-1726766098626"></a>[统一过程/统一开发方法](#xici-1705841629815)

<a name="e09a-1726766098628"></a>[敏捷开发方法](#9jca-1705841608711)

<a name="i1lf-1726766098630"></a>[XP](#28va-1705841590197)

<a name="wfgm-1726766098632"></a>[Scrum](#fyfq-1705938223773)

<a name="tvuq-1726766098634"></a>[逆向工程](#d5ko-1705938215067)

<a name="ervv-1726766098636"></a>[实现级](#os3c-1706090901666)

<a name="wirx-1726766098638"></a>[结构级](#irxb-1706090905276)

<a name="do1m-1726766098640"></a>[功能级](#rk8d-1706090908958)

<a name="vngq-1726766098642"></a>[领域级](#k3pt-1706090912460)

<a name="bulz-1726766098644"></a>[净室软件工程](#tybd-1705938215235)

<a name="bjgm-1726766098646"></a>[需求工程](#ochn-1705940085547)

<a name="y2ph-1726766098648"></a>[.需求获取](#xdlf-1705940054108)

<a name="1wnf-1726766098650"></a>[用户面谈 ](#s1uq-1706090846730)

<a name="0q1m-1726766098652"></a>[联合需求计划(JRP) ](#vuil-1706090851858)

<a name="qm8e-1726766098654"></a>[问卷调查 ](#gpxg-1706090851859)

<a name="mbly-1726766098656"></a>[现场观察   ](#mg9n-1706090851860)

<a name="avdf-1726766098658"></a>[原型化方法        ](#3ww6-1706090851861)

<a name="t6wv-1726766098660"></a>[头脑风暴法](#0awr-1706090851863)

<a name="ig65-1726766098662"></a>[.需求分析](#axny-1705940052332)

<a name="v4pc-1726766098664"></a>[1.功能模型(数据流图DFD)](#v8wz-1706090812929)

<a name="fue3-1726766098666"></a>[2.行为模型(状态转换图)](#3uls-1706090814821)

<a name="2bjp-1726766098668"></a>[3.实体模型(E-R图)](#69df-1706090816407)

<a name="xmso-1726766098670"></a>[UML](#loq2-1705940640473)

<a name="vkn2-1726766098672"></a>[需求定义](#4aeg-1706091062964)

<a name="lisi-1726766098674"></a>[需求验证](#ud2s-1706090947930)

<a name="zrjc-1726766098676"></a>[需求跟踪](#l03x-1705940634470)

<a name="gb1e-1726766098678"></a>[需求变更管理](#muqf-1706093218719)

<a name="48pt-1726766098680"></a>[软件系统建模](#ilpb-1706093190683)

<a name="vnh7-1726766098682"></a>[软件界面设计](#j396-1706094675778)

<a name="nqjq-1726766098684"></a>[结构化设计](#vqsk-1706094478028)

<a name="9cxe-1726766098687"></a>[内聚](#jczo-1706095018132)

<a name="pcio-1726766098689"></a>[耦合](#qa8z-1706095402118)

<a name="intw-1726766098691"></a>[模块四要素](#g1dc-1706095391028)

<a name="8pcp-1726766098693"></a>[面相对象设计](#ydwa-1706095870710)

<a name="buf2-1726766098695"></a>[类的分类](#fouz-1706095958643)

<a name="36yd-1726766098697"></a>[基本过程](#9pd1-1706095996137)

<a name="bnov-1726766098699"></a>[设计原则(同设计模式)](#k8lc-1706096001163)

<a name="gtbe-1726766098701"></a>[计算机](#qvol-1706095952165)

<a name="nm90-1726766098703"></a>[计算机结构(★)](#ef1b-1706108352037)

<a name="izax-1726766098705"></a>[存储系统(★★★★)](#4kj7-1706108373776)

<a name="9guf-1726766098707"></a>[层次化存储结构](#ucta-1706109825295)

<a name="ihrr-1726766098709"></a>[Cache](#j9hn-1706109828962)

<a name="p5hn-1726766098711"></a>[主存编址计算](#pv51-1706109847372)

<a name="obqz-1726766098713"></a>[磁盘基本结构与存储过程](#jcqv-1706108377026)

<a name="zmty-1726766098715"></a>[磁盘优化分布存储](#puux-1706111215530)

<a name="iwf7-1726766098717"></a>[磁盘单缓冲区与双缓冲区读取](#dvin-1706111222861)

<a name="ngxk-1726766098719"></a>[磁盘移臂调度算法](#jr2r-1706111239137)

<a name="rig1-1726766098721"></a>[数据传输控制方式（★)](#sz2k-1706111188014)

<a name="e8ct-1726766098723"></a>[总线（★★)](#cbul-1706108378755)

<a name="h8q1-1726766098725"></a>[CISC与RISC(★)](#0hb5-1706108373778)

<a name="m5mi-1726766098727"></a>[流水线(★★)](#ernn-1706108380109)

<a name="glys-1726766098729"></a>[校验码(★)](#grix-1706108381278)

<a name="u8bc-1726766098731"></a>[嵌入式（★)](#1p2v-1706108382511)

<a name="n3bw-1726766098733"></a>[计算机网络](#8vmt-1706198382356)

<a name="8beu-1726766098735"></a>[TCP/IP协议族(7层/4层网络模型)](#a4es-1706106975412)

<a name="mxoo-1726766098737"></a>[.TCP与UDP (★★★)](#vwim-1706198561289)

<a name="g8xs-1726766098739"></a>[.DHCP与DNS (★★★)](#imsh-1706198537828)

<a name="ybdh-1726766098741"></a>[网络规划与设计](#u7sd-1706198559304)

<a name="zinp-1726766098743"></a>[1.逻辑设计与物理设计(★★★★）](#nov8-1706198591905)

<a name="jhw1-1726766098745"></a>[2.层次化网络设计](#sy2g-1706198599196)

<a name="yojm-1726766098747"></a>[3.网络冗余设计](#igl7-1706257923205)

<a name="e7t3-1726766098749"></a>[网络存储（★★)](#zkxb-1706257899477)

<a name="of0j-1726766098751"></a>[磁盘阵列Raid](#fxma-1706198636789)

<a name="itpl-1726766098753"></a>[lPv6 (★)](#vlem-1706259832461)

<a name="ztex-1726766098755"></a>[网络接入(有线/无线)](#g438-1706198637653)

<a name="y2k2-1726766098757"></a>[综合布线(★)](#lxli-1706198497856)

<a name="j2g0-1726766098759"></a>[网络技术扩展](#5dlt-1706198650540)

<a name="105g-1726766098761"></a>[物联网(IOT)](#jgll-1706198586849)

<a name="kcbv-1726766098763"></a>[云计算(Saas/Paas/Iaas)](#pr8x-1706198586851)

<a name="glps-1726766098765"></a>[===系统架构设计case===](#1rnn-1706941312871)

<a name="wkbt-1726766098767"></a>[google L5设计一个分布式数据库架构](#nm5q-1706969255961)

<a name="2des-1726766098769"></a>[.what is total ordering(ordering first 100 custormer)](#g7yu-1707229908505)

<a name="36lj-1726766098771"></a>[.why single leader()](#ebxf-1707230056989)

<a name="dnlp-1726766098773"></a>[.request router](#ttmg-1707230034624)

<a name="ndrh-1726766098775"></a>[.variations](#aftd-1707229925082)

<a name="zyf2-1726766098777"></a>[1.Failover handing](#uk2k-1707457488655)

<a name="pqqo-1726766098779"></a>[2.Reblancing after new node added](#btbd-1707457496651)

<a name="qew2-1726766098781"></a>[3.Leaderless for heavy write-shard](#moaq-1707457524278)

<a name="iovu-1726766098783"></a>[4.TicketMasler (and total ordering is necessary](#wyvq-1707458882987)

<a name="8ptb-1726766098785"></a>[===数据密集型应用===](#sswx-1706094478181)

<a name="g6bc-1726766098787"></a>[第一部分 数据系统的基石](#unbe-1677787447006)

<a name="umhl-1726766098789"></a>[1.可靠性、可拓展性、可维护性能](#kwfx-1677787447007)

<a name="dmdv-1726766098791"></a>[-功能性需求：CRUD](#lykw-1644227240038)

<a name="hbik-1726766098793"></a>[-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性](#b2tu-1644227249556)

<a name="nadi-1726766098795"></a>[.可靠性：](#qqm5-1644227303238)

<a name="dxla-1726766098797"></a>[硬件故障](#7xms-1644228225080)

<a name="nle8-1726766098799"></a>[软件错误](#dfpv-1708357497902)

<a name="kbwh-1726766098801"></a>[人为错误(如何让系统变得可靠)](#drpl-1708357507365)

<a name="rva5-1726766098803"></a>[如何让系统变得可靠：](#pqmh-1708523552230)

<a name="zx4h-1726766098805"></a>[。最小化犯错机会的方式设计系统,  但如果限制太多，人们可能会忽略它们的好处而绕开，很难把握其中微妙的平衡](#i4we-1708358144376)

<a name="ojkq-1726766098807"></a>[。在易错地方和可能导致失效的地方解耦decouple,提供非生产环境沙箱sandbox-虚拟化环境，隔离真实系统进行安全测试](#xzfa-1708358243121)

<a name="nwpw-1726766098809"></a>[。彻底的测试，单元测试，集成测试，手动测试，自动化测试覆盖边缘场景corner case.](#9jaa-1708358634289)

<a name="p4mo-1726766098811"></a>[。滚动发布，快速回滚](#zlp4-1708358698137)

<a name="lvmc-1726766098813"></a>[。配置详细和明确的监控](#40us-1708358954660)

<a name="evcf-1726766098815"></a>[。良好的管理和充分的培训。一个复杂而重要的方面，但超出本书的范围](#o66x-1708358967000)

<a name="yvhr-1726766098817"></a>[可靠性有多重要](#x7co-1708357515795)

<a name="xyte-1726766098819"></a>[造成客户巨大损失-阿里云宕机造成的用户损失](#nc0w-1708358745350)

<a name="adam-1726766098821"></a>[家长将孩子照片存储在你的应用李，数据库损坏，客户有何体验，他们可能会知道如何从备份恢复吗？](#qopp-1708358856827)

<a name="4rgq-1726766098823"></a>[.可扩展性： ](#dsae-1708357483848)

<a name="whqf-1726766098825"></a>[描述负载(tps-推特主页时间线扇出-查询性能优化)](#vja4-1708356470840)

<a name="oele-1726766098827"></a>[描述性能](#s6un-1708356581594)

<a name="m1zi-1726766098829"></a>[吞吐量throughput](#fcez-1708523606684)

<a name="itkb-1726766098831"></a>[响应时间 response time.](#k30f-1708523620292)

<a name="p6by-1726766098833"></a>[响应时间的高位百分点（也称为尾部延迟tail latencies](#bogk-1708523658968)

<a name="ludx-1726766098835"></a>[.可维护性：](#k1dg-1708355783343)

<a name="3cwz-1726766098837"></a>[2.数据模型与查询语言](#jufm-1677787447008)

<a name="vgiv-1726766098839"></a>[-关系模型](#pgu6-1699844351041)

<a name="tcpg-1726766098841"></a>[-NoSql (es,redis)](#kfpd-1644410618294)

<a name="exwp-1726766098843"></a>[1.文档数据库:MongoDB](#0p23-1644410807294)

<a name="46qp-1726766098845"></a>[  2.图形数据库 ：](#09bl-1644410666587)

<a name="gw0w-1726766098847"></a>[-其它模型(基因序列)](#6fxw-1644410924417)

<a name="hoez-1726766098849"></a>[3.存储与检索](#sm0u-1677787447009)

<a name="cu5t-1726766098851"></a>[-优化事务处理（OLTP）transaction ](#bhcv-1644935436804)

<a name="tu5k-1726766098853"></a>[1.OLTP系统通常面向用户，大量的请求。](#tbhw-1699844517372)

<a name="cprb-1726766098855"></a>[2.磁盘寻道时间往往是这里的瓶颈。](#fnev-1644935714127)

<a name="8zll-1726766098857"></a>[3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。](#cjwp-1644935609899)

<a name="xtaf-1726766098859"></a>[-优化分析（OLAP）analys](#jg7s-1699844443567)

<a name="eeot-1726766098861"></a>[1.列式储存(投影操作，压缩技术，聚合过滤)](#pjd1-1703887811615)

<a name="k0fs-1726766098863"></a>[-OLTP两大主流学派的存储引擎：](#8sgm-1644935924013)

<a name="w9nr-1726766098865"></a>[1.日志结构学派](#i55y-1644935943748)

<a name="nimh-1726766098867"></a>[2.就地更新学派](#h3il-1644935977285)

<a name="f6gg-1726766098869"></a>[4.编码（序列化）与演化(XML,JSON,CSV)](#lbs1-1677787447010)

<a name="dofx-1726766098871"></a>[第二部分 分布式数据](#4p9n-1677787447012)

<a name="uhgq-1726766098873"></a>[1.高可用性/容错](#o4ag-1646310813851)

<a name="rmop-1726766098875"></a>[2.断开连接的操作](#snwm-1646310894841)

<a name="hgpl-1726766098877"></a>[3.减少延迟(节点近)](#evly-1646310918322)

<a name="xnsl-1726766098879"></a>[4.可拓展性](#itsh-1646310968967)

<a name="cjod-1726766098881"></a>[.拓展至更高的载荷](#gjis-1708362947856)

<a name="icay-1726766098883"></a>[垂直扩展scale up ：购买更强大的机器 cpu](#mgia-1708362999715)

<a name="arbt-1726766098885"></a>[共享内存架构shared-memory architecture：许多处理器、内存和磁盘再同一操作系统下相互连接，共享内存和磁盘](#pdo8-1708363038596)

<a name="twto-1726766098887"></a>[共享磁盘share-disk architecture：独立处理器和内存，数据存储在机器之间共享的磁盘阵列上，磁盘通过快速网络连接。数仓](#wgwl-1708363065800)

<a name="rd6e-1726766098889"></a>[无共享架构](#klw2-1708363340866)

<a name="dxve-1726766098891"></a>[.复制VS分区](#gbgq-1646311175182)

<a name="kxnz-1726766098893"></a>[5.复制](#gd4q-1708363438406)

<a name="t1ja-1726766098895"></a>[.领导者与追随者-单主复制](#9hbs-1708441077626)

<a name="mirj-1726766098897"></a>[客户端将所有写入操作发送到单个节点（领导者），该结点将数据更改事件流发送到其它副本（追随者）。](#aucb-1708528116000)

<a name="ndss-1726766098899"></a>[读取可以再任何副本中执行，但从追随者读取可能是陈旧的 （最终一致性问题）](#wgge-1646311567456)

<a name="qtyj-1726766098901"></a>[.同步复制与异步复制](#cbey-1646310922523)

<a name="j7jc-1726766098903"></a>[.设置新从库(快照复制+caught up binlog)](#j5o0-1704983008475)

<a name="rlzq-1726766098905"></a>[.处理宕机节点](#bcod-1708442233018)

<a name="fzkw-1726766098907"></a>[从库失效：追赶恢复](#5ufz-1708443850274)

<a name="lszo-1726766098909"></a>[主库失效：故障切换failover](#udix-1708443860752)

<a name="yunf-1726766098911"></a>[自动切换步骤：1.确认主库失效](#w3sj-1708523445192)

<a name="wouf-1726766098913"></a>[2.选举新主库：共识](#y3qn-1708523480847)

<a name="sxk5-1726766098915"></a>[3.配置系统启用新主库](#wua6-1708523497956)

<a name="ya6i-1726766098917"></a>[failover的麻烦：1.异步复制数据丢失](#z7mn-1708523814309)

<a name="jysz-1726766098919"></a>[2.自增主键冲突](#mnjx-1708523836932)

<a name="sq4e-1726766098921"></a>[3.脑裂split brain](#dbhg-1708523873194)

<a name="j4kd-1726766098923"></a>[4.如何设置超时](#561v-1708523878338)

<a name="8eif-1726766098925"></a>[.复制日志的实现](#8mem-1708442228760)

<a name="fgiv-1726766098927"></a>[基于语句的复制(每个写入请求语句statment)](#k8yo-1708524004340)

<a name="oicu-1726766098929"></a>[记录每个写入请求语句statment，语句日志传输给从库](#hcqe-1708524155632)

<a name="bpoo-1726766098931"></a>[问题：非确定函数nondeterministic, NOW()  RAND()](#9xml-1708524182083)

<a name="sfvq-1726766098933"></a>[    自增列- 造成差异](#il4a-1708524271564)

<a name="jt1s-1726766098935"></a>[副作用的语句：用户自定义函数，触发器，存储过程](#azmh-1708524331636)

<a name="0vwt-1726766098937"></a>[解决: 用固定值替换](#rcfb-1708524371120)

<a name="pa8q-1726766098939"></a>[  如语句存在任何不确定性，切换到基于行的数据](#6uy2-1708524426849)

<a name="aohn-1726766098941"></a>[传输预写式日志(WAL)](#rnmz-1708524013585)

<a name="y6oc-1726766098943"></a>[日志存储引擎SSTables LSM树](#hze4-1708524498278)

<a name="eglk-1726766098945"></a>[磁盘块的B树  WAL, 崩溃恢复](#qzop-1708524541132)

<a name="mjyz-1726766098947"></a>[逻辑日志复制(基于行)](#a3ng-1708524040960)

<a name="jhed-1726766098949"></a>[binlog](#jiiu-1708524648209)

<a name="obgm-1726766098951"></a>[基于触发器的复制](#ezoi-1708524083973)

<a name="aitf-1726766098956"></a>[.复制延迟问题(解决方法都是反分布式，或者趋于单机一致性。数据一致性模型：https://jepsen.io/consistency)](#https://jepsen.io/consistency)

<a name="m8ud-1726766098958"></a>[读己之写(读主库或带写时间戳查询)](#w5nz-1708525244967)

<a name="7ril-1726766098960"></a>[写后从旧副本读取数据-未同步  ](#25nj-1708526407050)

<a name="y6nx-1726766098962"></a>[解决：写后读read after write 一致性 或叫做 read your write consistency 防止这种异常](#4st1-1708525569674)

<a name="4zou-1726766098964"></a>[1.都从主库读。适用仅由用户本人编辑的数据，如个人信息。大部分内容从主库读不适用，扩容读无效果](#v4r0-1708525736897)

<a name="apsp-1726766098966"></a>[2. 扩容读需要保证更新时间，监控复制延迟，防止滞后超过一分钟从从库发出查询](#vqjs-1708525818133)

<a name="i9yk-1726766098968"></a>[3. 客户端记录写入时间戳，系统确保从库提供查询时，版本时间已覆盖，否则从另一个从库读，或者等待caught up-  等待不就相当弱可用状态，且时钟不可靠](#nmrh-1708525971734)

<a name="fcto-1726766098970"></a>[4. 副本在多个数据中心，复杂度高，都需经过主库IDC](#wmu9-1708526095856)

<a name="8ywb-1726766098972"></a>[单调读(基于id散列路由同一副本)](#kwrd-1708525264596)

<a name="yojj-1726766098974"></a>[先读到最新副本，后读到旧副本感觉数据消失](#npwe-1708527802311)

<a name="k2vc-1726766098976"></a>[A看到B评论后消失，时光倒流moving backward in time ](#4cn0-1708526272081)

<a name="86h1-1726766098978"></a>[解决：单调读monotonic reads总是从同一个副本进行读取(基于用户散列id，如果副本失效则重新路由)](#drqk-1708526396300)

<a name="elfc-1726766098980"></a>[  比强一致性(同步复制/类比单机)弱，比最终一致性更强](#s6u3-1708526566643)

<a name="vhil-1726766098982"></a>[一致前缀读(因果关系写到相同分区)](#bfps-1708525268614)

<a name="qiwx-1726766098984"></a>[consistent prefix reads](#q7p0-1711363121071)

<a name="0z1p-1726766098986"></a>[不同分片副本同步先后问题导致读顺序错误](#rqcm-1708527879976)

<a name="cfmf-1726766098988"></a>[分区partition/分片sharded数据库中的一个特殊问题，全局写入顺序](#bwov-1708526677620)

<a name="dwpn-1726766098990"></a>[分区主库1写入 A:你吃饭了吗？ 分区主库2写入B:没有。 分区1副本同步主库1落后分区2副本同步主库2    C读取1副本: 没有，后读取2副本。你吃饭了吗？](#7e9o-1708526727984)

<a name="xzbu-1726766098992"></a>[解决：确保因果关系都写入到相同分区](#turn-1708527108521)

<a name="gy2a-1726766098994"></a>[复制延迟解决方案](#a2la-1708525420248)

<a name="qmbo-1726766098996"></a>[趋于反分布式，局部或者部分看做一个单机，做到强一致性](#x8ng-1708527233293)

<a name="4eky-1726766098998"></a>[写后读。](#gecf-1708527304184)

<a name="vx94-1726766099000"></a>[数据库通过事务提供强大保证。](#zsq6-1708527307246)

<a name="f5gv-1726766099002"></a>[.多主复制(主主复制，互为副本-写冲突。多主复制被认为是危险的领域)](#pbfd-1708528009698)

<a name="w2mk-1726766099004"></a>[多主复制的应用场景](#kxkx-1708441627686)

<a name="vz4y-1726766099006"></a>[运维多个数据中心(IDC-主主间复制需要处理写冲突）](#xrso-1708700002291)

<a name="za5e-1726766099008"></a>[性能(多活配置，写操作在本地IDC处理，其他IDC异步复制，性能更好)](#06t6-1708700132681)

<a name="hb3e-1726766099010"></a>[容忍IDC停机](#9sww-1708700267631)

<a name="uhuc-1726766099012"></a>[容忍网络问题(临时的网络中断不会妨碍正在写入的处理)](#dtkl-1708700295371)

<a name="2dwu-1726766099014"></a>[需要离线操作的客户端(支持多个终端离线操作couchDB)](#knxa-1708700020273)

<a name="de7u-1726766099016"></a>[协同编辑](#hvwb-1708700115895)

<a name="eam0-1726766099018"></a>[处理写冲突(A将标题从1改2,B将1改3)](#fdot-1708700612321)

<a name="dimb-1726766099020"></a>[同步于异步冲突检测](#u8bc-1708700824251)

<a name="xlpy-1726766099022"></a>[同步：单主程序复制 - 不允许每个副本独立接受写入](#wfgd-1708700957597)

<a name="r1np-1726766099024"></a>[异步：独立接受写入- 异步检测，但为时已晚](#x6is-1708701017804)

<a name="xvwt-1726766099026"></a>[避免冲突(特定记录写入都通过同一个领导者，主库切换或者用户迁移至更近的主库时会有同时写入的可能性)](#xg2a-1708700840681)

<a name="xadf-1726766099028"></a>[收敛convergent至一致的状态(副本主库和其副本在复制完成时收敛至一个相同的最终值)](#ucfn-1708700844474)

<a name="wfoh-1726766099030"></a>[最后写入胜利LWW,last write wins- 给每个写入一个唯一id, 挑选最高ID的写入作为胜利者，并丢弃其他写入-数据丢失](#cbla-1708701376316)

<a name="qxqf-1726766099032"></a>[为每个副本分配一个唯一ID,ID编号更高的具有高优先级。数据丢失](#40po-1708701481447)

<a name="u7no-1726766099034"></a>[将值合并在一起](#p4m4-1708701593939)

<a name="cgd0-1726766099036"></a>[记录冲突，并编写解决逻辑代码。如通过提醒用户方式](#8fcs-1708701611999)

<a name="bjjs-1726766099038"></a>[自定义冲突解决逻辑](#yrdi-1708700860148)

<a name="kule-1726766099041"></a>[自定义冲突解决逻辑(complex)](#t4i7-1708702160004)

<a name="sxkl-1726766099043"></a>[写时执行-后台处理](#pdql-1708702370625)

<a name="wg8m-1726766099045"></a>[读时执行-提供多版本用户选择，回写数据库](#sksk-1708702376293)

<a name="4qq3-1726766099047"></a>[亚马逊购物车移除的商品重新出现](#4bqp-1708702425059)

<a name="ezci-1726766099049"></a>[什么是冲突(两个领导者预订同一个会议室，7章看冲突实例12章看检测解决)](#6x4i-1708700867996)

<a name="tmi1-1726766099051"></a>[多主复制拓扑](#o41a-1708702111509)

<a name="oldx-1726766099053"></a>[环形，星型，all to all -mysql仅支持环形](#5feh-1708702903239)

<a name="9uoe-1726766099055"></a>[问题：多主复制时，可能在某些副本中写入错误的顺序。like A写主库1，B写主库2，主库3先同步2，再同步1。类似一致前缀读。](#ddyu-1708702949257)

<a name="xs5i-1726766099057"></a>[解决：时间戳是不够的-不可靠时钟，使用一种称为版本向量(version vectors)的技术-检测并发写入](#ghp3-1708703247102)

<a name="zvj1-1726766099059"></a>[无主复制leaderless](#bfz8-1708759285067)

<a name="yoju-1726766099061"></a>[Amazon的Dynomo系统。](#cvru-1708759359537)

<a name="dsv0-1726766099063"></a>[Riak, Cassandra，Voldmort 也称为Dynamo风格。](#wf6o-1708759707666)

<a name="apuu-1726766099065"></a>[类型1：客户端直接将写入发送到几个副本中](#xpqf-1708760120711)

<a name="vitc-1726766099067"></a>[类型2：coordinator协调者节点代表客户端写入。](#pl2z-1708760121090)

<a name="py4d-1726766099069"></a>[当节点故障时写入数据库(仲裁写⼊，法定读取，并在节点中断后读修复。)](#qgpe-1708760989905)

<a name="m6uv-1726766099071"></a>[如果主从复制，主故障/重启系统更新 则需进行故障切换](#zfuz-1708760396929)

<a name="xqy5-1726766099073"></a>[无主复制： userA set piture_url   -> replica1 ok    Then version=7](#3soj-1708760452090)

<a name="zsyl-1726766099075"></a>[           user set piture_url   -> replica2 ok  Then version=7](#4f05-1708760543198)

<a name="jihg-1726766099077"></a>[user set piture_url   -> replica3 offline  fail   version= 6](#ynls-1708759898772)

<a name="g13g-1726766099079"></a>[    userB get piture  :  rp3(version6) rp1(version7)  rp2(version7)  Than fix rp3 value to version7](#e1ur-1708760618873)

<a name="jxyi-1726766099081"></a>[ 读修复和反熵(失效节点重新连机后如何caught up)](#tyv3-1708760780373)

<a name="syi7-1726766099083"></a>[读修复like userB get piture fixed rp3](#wjho-1708761214792)

<a name="njm0-1726766099085"></a>[反熵 后台进程不断查找副本之间的数据差异。Voldmort无反熵过程，副本可能丢失数据](#xblj-1708761286988)

<a name="vprz-1726766099087"></a>[ 读写的法定人数（仲裁）](#w3ia-1708761120623)

<a name="cpbi-1726766099089"></a>[仲裁一致性的局限性-最终一致，更强的保证需要事务或共识](#oj1i-1708759830121)

<a name="snys-1726766099091"></a>[松散法定人数与带提示的接力](#cu5q-1708759841416)

<a name="7usw-1726766099093"></a>[运维多个数据中心-将写入发送到所有副本，仅需本地IDC内法定节点确认](#kzki-1708761744887)

<a name="wmct-1726766099095"></a>[检测并发写入](#pt1k-1708759856530)

<a name="g5d1-1726766099097"></a>[Dynamo风格的数据存储，没有明确定义的顺序。](#mu89-1708761978075)

<a name="7ost-1726766099099"></a>[userA set x=A   get x](#dbni-1708763823783)

<a name="whyx-1726766099101"></a>[rp 1 A ok    B unresponsive   A](#auce-1708763993783)

<a name="ezfn-1726766099103"></a>[rp2 A ok   B OK  B](#kteo-1708764011894)

<a name="gjyh-1726766099105"></a>[rp3 B ok A ok A](#9xyy-1708764019308)

<a name="an7o-1726766099107"></a>[userB set x=B ](#esiv-1708702764305)

<a name="nfrl-1726766099109"></a>[最后写入胜利(丢弃并发写入)](#wd1i-1708764197180)

<a name="zrpu-1726766099111"></a>[LLW 无法确定真实排序，强制排序，选择最新的最大时间戳，并丢弃较早的任何写入.Cassandra唯一支持的方式，Riak可选](#uzhw-1708874432788)

<a name="ljzc-1726766099113"></a>[缺点：数据丢失 ](#henp-1708874594301)

<a name="t61o-1726766099115"></a>[此前发生的关系和并发](#hzwp-1708764215825)

<a name="xtwh-1726766099117"></a>[因果依赖(causally dependent)  如果B后发与A, 则B因果依赖A, ](#3wp0-1708874672763)

<a name="b8tm-1726766099119"></a>[如果是并发，则存在需要解决的冲突](#1wzv-1708875051673)

<a name="udoq-1726766099121"></a>[捕获此前发生的关系](#j2r6-1708764228505)

<a name="wyjr-1726766099123"></a>[捕获两个客户端间的因果关系，同时编辑购物车(示例为单副本)](#vv7q-1708875756229)

<a name="r3n9-1726766099125"></a>[合并同时写入的值](#zp0i-1708874374616)

<a name="vhsq-1726766099127"></a>[客户端需额外工作，合并并发写入的值来擦屁股。Riak称这些并发值兄弟(sibings)](#wawo-1708876272614)

<a name="tmvk-1726766099129"></a>[版本向量](#arlv-1708874381589)

<a name="bcly-1726766099131"></a>[所有副本的版本号集合称为版本向量(version vector)](#b1ov-1708700703636)

<a name="gfv5-1726766099133"></a>[6.分区](#dyz5-1709800112532)

<a name="cw1r-1726766099135"></a>[.分区与复制(分区与复制方案是独立的)](#twd1-1709800204792)

<a name="y6go-1726766099137"></a>[.键值数据的分区](#fbqg-1709800263679)

<a name="ybep-1726766099139"></a>[偏斜skew：分区过多数据或过多查询](#s7ju-1709801062977)

<a name="jbwf-1726766099141"></a>[热点hot spot:高负载的分区](#u0d3-1709801107270)

<a name="tyni-1726766099143"></a>[根据键的范围分区](#lqbu-1709800332210)

<a name="xtaj-1726766099145"></a>[Bigtable, HBase, RethinkDB 和 MongoDB2.4](#i2ju-1709801151406)

<a name="m7q3-1726766099147"></a>[按照一定的顺序保存键（SSTbale和LSM-树）](#np00-1709801582805)

<a name="eega-1726766099149"></a>[按时间分区当日写过载（需加传感器保证日期+传感主键均匀分布）](#evhb-1709801683166)

<a name="j1x2-1726766099151"></a>[根据键的散列分区(可将偏斜数据均匀分布)](#a1yy-1709800347130)

<a name="y3pm-1726766099153"></a>[不适合分区的简单哈希函数：java .hashCode-同键不同进程不同哈希值](#mdg4-1709801628016)

<a name="zsee-1726766099155"></a>[一致性哈希consistent hashing:哈希键分区边界均匀间隔，也可伪随机选择（CDN均匀分配负载）。](#7rkg-1709802019859)

<a name="j9dj-1726766099157"></a>[缺点：无序，低效范围查询(需发送到所有分区)](#iktb-1709802309508)

<a name="lh0k-1726766099159"></a>[折中方案：复合主键/组合索引。(uid,time).不同用户在不同分区，每个用户按时间搓顺序存储在单个分区上。](#zznq-1709802490074)

<a name="xtyb-1726766099161"></a>[负载倾斜与消除热点](#ed70-1709800357523)

<a name="xofp-1726766099163"></a>[数百万追随者做某事-大量写入同一个键](#403a-1709802593546)

<a name="rbw5-1726766099165"></a>[解决：火爆主键+随机数即可将主键分散为100个分区](#wx5s-1709802730512)

<a name="p0ny-1726766099167"></a>[缺点：数据合并，跟踪火爆主键。需权衡利弊。](#h0b7-1709802773377)

<a name="gehp-1726766099169"></a>[.分片与次级索引](#ekdv-1709800287975)

<a name="g5ga-1726766099171"></a>[次级索引通常并不能唯一标识记录。](#n3vk-1709803239471)

<a name="j1bc-1726766099173"></a>[HBase Volde-mort为了减少实现复杂度放弃了次级索引。](#q1u5-1709803293988)

<a name="ct0i-1726766099175"></a>[Riak开始添加， 次索是Solr Elasticesearch 搜索的基石](#fhpr-1709803333585)

<a name="m0z7-1726766099177"></a>[按文档的二级索引](#mwm0-1709800370635)

<a name="olcr-1726766099179"></a>[文档分区索引/本地索引](#ud7o-1709803718409)

<a name="e5ru-1726766099181"></a>[每个分区独立维护自己的二级索引。](#zlhf-1709803740582)

<a name="miyn-1726766099183"></a>[查询发送所有分区，并合并所有返回结果，分散/聚集scatter/gather-容易导致尾部延迟放大。](#bkj3-1709803789802)

<a name="cogc-1726766099185"></a>[缺点：可能使二级索引读取查询相当昂贵。](#ghpm-1709803878421)

<a name="xv0z-1726766099187"></a>[根据关键词(Term)的二级索引](#itl0-1709800380617)

<a name="srmz-1726766099189"></a>[全局索引：覆盖所有分区数据的索引，也须分区。](#8bw4-1709804016790)

<a name="ygqe-1726766099191"></a>[关键词分区：关键词本身或它的散列进行分区。](#qc2d-1709913637902)

<a name="vczz-1726766099193"></a>[优点：只需请求包含关键词的分区，读取更有效率](#jmj8-1709913775261)

<a name="dnfh-1726766099195"></a>[缺点：写入慢且复杂。需支持分布式事务。](#i7kp-1709913825503)

<a name="jzaz-1726766099197"></a>[理想下总是最新，实践中更新通常为异步。Amazon DynamoDB声称全局次级索引不到1s内更新。](#mv7j-1709913923874)

<a name="xir5-1726766099199"></a>[.分区再平衡(reblancing)](#hpnd-1709800294747)

<a name="xg2a-1726766099201"></a>[吞吐量增加：加cpu](#1f0n-1709914101899)

<a name="krlq-1726766099203"></a>[数据集大小增加：加磁盘和RAM](#vjb0-1709914129763)

<a name="ciqf-1726766099205"></a>[机器故障：其他机器接管](#smcd-1709914153882)

<a name="vwaf-1726766099207"></a>[----------再平衡应满足--------------](#2efu-1709916803909)

<a name="fzwa-1726766099209"></a>[发生时：数据库应该继续接受读取和写入](#20wj-1709916807951)

<a name="806n-1726766099211"></a>[节点之间只移动必须数据(分区)，以便快速再平衡，减少网络和磁盘io负载。](#cxoi-1709916893371)

<a name="ogrx-1726766099213"></a>[平衡后：存储，读取和写入公平共享](#cj8j-1709916938075)

<a name="t7av-1726766099215"></a>[平衡策略](#cavd-1709800402611)

<a name="wwov-1726766099217"></a>[反面教材：hash mod N](#6f6z-1709800409866)

<a name="4vyg-1726766099219"></a>[$hash(key)=22  22mod10..2  22mod 11...0  22 mod 9 ...4 ](#anib-1709916997775)

<a name="nhhb-1726766099221"></a>[节点需要转移秘钥及次数过多，过于昂贵。](#anz7-1709917243580)

<a name="xrum-1726766099223"></a>[解决：更换为只移动必须数据的方法。](#7ytl-1709917334275)

<a name="bwpq-1726766099225"></a>[固定数量的分区(加节点时分配分区)](#8l9j-1709800420954)

<a name="po9t-1726766099227"></a>[新增/减少节点时，将现存部分数据转移到节点新增/现存节点(Riak,es,couchbase Voldemort使用这种再平衡）](#vmsm-1709917322722)

<a name="4kk7-1726766099229"></a>[适用：分区数量第一次建立时确定。](#ktrd-1709917648400)

<a name="gnmo-1726766099231"></a>[缺点：数据集总量大小难以预估时；分区大再平衡代价昂贵，分区小产生额外开销。](#vw7j-1709917692466)

<a name="mtzs-1726766099233"></a>[分区大小与集群数据总量成比例增长](#eszc-1709921747523)

<a name="wgim-1726766099235"></a>[动态分区(适用键范围的分区)](#tkjw-1709800428033)

<a name="sqwj-1726766099237"></a>[解决：使用键范围分区，固定边界的固定数量的分区不便。出现边界错误，手动重新去配分区边界将非常繁琐。](#itsg-1709917825657)

<a name="kwlf-1726766099239"></a>[动态分区：与B树类似，分区数据增长超过配置时将分成两区，大量数据删除分区缩小低于阈值则合并(HBase RethinkDB)](#05rm-1709917996703)

<a name="qbgx-1726766099241"></a>[优点：分区数量适应总数据量-动态划分分区数量。](#v8uv-1709918235496)

<a name="uakj-1726766099243"></a>[注意：空库分区开始，未绘制边界先验信息。所有写操作都必须由单个节点处理。其它节点空闲](#cdjv-1709918375629)

<a name="xqhb-1726766099245"></a>[解决：配置一组初始分区-预分割 Hbase MongoDb。配需提前知道键分配方式。](#3uee-1709918458100)

<a name="g2e7-1726766099247"></a>[MongoDB同时支持范围和哈希分区且动态分割分区。](#tlmq-1709918504615)

<a name="hifx-1726766099249"></a>[分区数量与数据集大小成正比](#xqee-1709921516740)

<a name="3z2o-1726766099251"></a>[按节点比列分区](#kcsr-1709800432396)

<a name="nw9h-1726766099253"></a>[新增节点，分区将变小。随机选择固定数量的现有分区进行拆分,最终获得公平的负载份额。cassandre ketama.](#xscz-1709920011051)

<a name="x6kq-1726766099255"></a>[随机选择分区边界要求使用基于散列的分区-一致性哈希。](#pmpc-1709920187661)

<a name="mqgc-1726766099257"></a>[分区数量与节点数量无关](#a0l0-1709923420226)

<a name="azsk-1726766099259"></a>[ 运维：手动还是自动平衡](#w6ob-1709800443454)

<a name="ymti-1726766099261"></a>[自动：与故障检测结合将十分危险，高负载节点响应慢被视为死亡被踢掉，重新平衡集群时其他超负荷节点可能级联失败](#qobk-1709920292898)

<a name="0mmr-1726766099263"></a>[手动人为监控+自动](#a05n-1709920414620)

<a name="jupo-1726766099265"></a>[.请求路由](#qxk3-1709800301840)

<a name="prux-1726766099267"></a>[分区再平衡后的服务发现(IP 端口)](#sd2e-1709921854453)

<a name="xpyk-1726766099269"></a>[-------方案-------](#gliq-1709921964410)

<a name="zqaq-1726766099271"></a>[1.循环策略：Round-Robin load balancer，轮询节点看是否有请求的分区。](#ibln-1709921978507)

<a name="qgbz-1726766099273"></a>[2.路由层：有中间层的路由决定请求的节点，由路由层负载均衡](#gjxa-1709922094115)

<a name="cvfu-1726766099275"></a>[3.要求客户端知道分区和节点的分配。客户端可直连节点。](#ukz9-1709922149547)

<a name="dpej-1726766099277"></a>[具有挑战性的问题。重要的是所有参与者都同意-否则将被发送到错误的节点，而不是正确处理。分布式中的共识协议-但很难正确实现。](#1c54-1709922244119)

<a name="1dny-1726766099279"></a>[Zookeper分区分配改变时通知路由层保持最新信息。](#c7dc-1709922373821)

<a name="tyor-1726766099281"></a>[LinkedIn的Espressor使用Heix进行集群管理(依靠Zookeeper）](#ne7u-1709922442881)

<a name="2jkz-1726766099283"></a>[Hbase,SolrCloud 和kafka也是用Zookeeper来跟踪分区分配。](#41cr-1709922584212)

<a name="pfve-1726766099285"></a>[Cassandra  Riaks节点间使用留言协议gossip protocol来传播群集状态变化。请求发送任意节点，该节点转发到含有请求分区的节点。模型增加数据库节点的复杂性。但避免对Zookeeper这类外部协调服务的依赖](#kg5k-1709922347652)

<a name="llfv-1726766099287"></a>[Couchbash不会自动再平衡，简化了设计。moxi路由层。](#uohs-1709922928889)

<a name="indx-1726766099289"></a>[执行并行查询](#h26t-1709800460759)

<a name="z2x8-1726766099291"></a>[大规模并行处理(MPP,massively parallel processing)-数仓](#oj8k-1709923010027)

<a name="kgrb-1726766099293"></a>[7.事务](#7qvp-1708523954496)

<a name="4b8n-1726766099295"></a>[简化故障失败的机制-强大的事务！！](#wk3n-1710172857428)

<a name="3xex-1726766099297"></a>[故障](#pzui-1710172844274)

<a name="ig0x-1726766099299"></a>[崩溃](#znoj-1710172848152)

<a name="gybf-1726766099301"></a>[网络中断](#vovu-1710172885568)

<a name="9szd-1726766099303"></a>[多线程/客户端写入覆盖](#sxty-1710172894683)

<a name="nddh-1726766099305"></a>[读取无意义中间态数据](#hbqy-1710172933218)

<a name="ycyu-1726766099307"></a>[多线程/客户端竞争](#jlng-1710172974900)

<a name="gzu6-1726766099309"></a>[.事务的棘手概念](#58hv-1710167822460)

<a name="or0u-1726766099311"></a>[ACID的含义](#yxrp-1710167867782)

<a name="3jzw-1726766099313"></a>[原子性atomicity](#hryj-1710167943276)

<a name="xfg6-1726766099315"></a>[一致性consistency](#9aal-1710167983379)

<a name="utzl-1726766099317"></a>[—致性这个词重载的很厉害:](#jkse-1710173130714)

<a name="bohm-1726766099319"></a>[隔离性isolation](#gfkv-1710171645686)

<a name="6f3o-1726766099321"></a>[持久性durability](#7kja-1710171663168)

<a name="rbng-1726766099323"></a>[单对象与多对象操作](#pblh-1710167919896)

<a name="0bfz-1726766099325"></a>[违反隔离性：一个事务读取另一个事务未被执行的写入（脏读）](#42qx-1710250188446)

<a name="j5wo-1726766099327"></a>[ 原⼦性确保发⽣错误时，事务先前的任何写⼊都会被撤消，以避免状态不⼀致（all or nothing）](#daxd-1710250201202)

<a name="jaiy-1726766099329"></a>[单对象写入](#7ymn-1710171710772)

<a name="lpmx-1726766099331"></a>[单对象写入崩溃，原子性通过日志实现恢复](#h5aa-1710250215106)

<a name="4tqy-1726766099333"></a>[原子操作：CAS也是流行的操作](#ihdr-1710250368749)

<a name="7ubx-1726766099335"></a>[事务通常被理解为：将多个对象上的多个操作合并为一个执行单元的机制](#a1qj-1710250481310)

<a name="09yi-1726766099337"></a>[多对象事务的需求](#afyc-1710171718578)

<a name="ad3p-1726766099339"></a>[是否需要多对象事务？ ](#t9gh-1710251706186)

<a name="6xwp-1726766099341"></a>[是否有可能只用键值模型和单对象来实现应用程序？](#9b6e-1710251739137)

<a name="dav6-1726766099343"></a>[ 关系型数据库：多表关联插入操作](#ormg-1710250533532)

<a name="2tbc-1726766099345"></a>[ 文档数据模型：多个字段常在同一个文档(被视为单个对象），缺乏连接功能的文档DB会鼓励非规范化(操作非规范化信息需要更新多个文档)。事务可防止非规范化数据不同步。](#opfe-1710250566216)

<a name="tsm0-1726766099347"></a>[ 二级索引的数据库中：一二级索引的同步更新](#syt6-1710251863622)

<a name="ho1s-1726766099349"></a>[无原子性:复杂的错误处理](#ymgi-1710251891615)

<a name="qy9z-1726766099351"></a>[无隔离性：并发问题](#ovhl-1710251918119)

<a name="smd7-1726766099353"></a>[处理错误和中止](#g5o1-1710171723084)

<a name="9byu-1726766099355"></a>[···   ACID哲学：违反规则宁可放弃，不留半成品。](#ygfp-1710251941752)

<a name="wwuw-1726766099357"></a>[无主复制则是尽力而为：数据库将做尽可能多的事。错误时不会撤销已经完成的事。-错误恢复是应用程序的责任。](#0hze-1710252188073)

<a name="nrow-1726766099359"></a>[Rails的ActiveRecord、Django这样的orm框架不会重试中断的事务。丢弃用户输入。](#7mbo-1710252298563)

<a name="f0rf-1726766099361"></a>[中止的重点应该是允许安全的重试。但它并不完美：](#p2mf-1710253466041)

<a name="pujw-1726766099363"></a>[事务成功，网络故障可能导致执行两次。除非有额外应用级除重机制。](#lmfw-1710253530673)

<a name="thzi-1726766099365"></a>[负载过大，重试将更槽糕。限制重试次数，指数退避算法。并单独处理和过载相关的错误](#nxyx-1710253675080)

<a name="7uqz-1726766099367"></a>[仅在临时性错误才值得重试（死锁，异常，网络中断和切换）。发生永久性错误的重试是无意义的](#njy9-1710253740189)

<a name="tsci-1726766099369"></a>[数据库外的副作用：重试每次重发电子邮件。不同系统事务。两阶段提交2PC.](#auy9-1710253799114)

<a name="hbvp-1726766099371"></a>[ 客户端重试失效则丢失数据。](#mtpo-1710253936214)

<a name="vjoy-1726766099373"></a>[.弱隔离级别](#jngf-1710167840980)

<a name="1075-1726766099375"></a>[安全并行parallel：事务不触及相同数据](#wdhp-1710263089880)

<a name="l07x-1726766099377"></a>[竞争条件：](#ykgs-1710263216103)

<a name="pm2n-1726766099379"></a>[读：事务读取另一个事务同时修改的数据](#er05-1710263177909)

<a name="illc-1726766099381"></a>[写：事务同时修改相同的数据](#pypw-1710263203957)

<a name="7p7u-1726766099383"></a>[事务隔离：](#xps5-1710263234506)

<a name="9enr-1726766099385"></a>[可序列化(一次一个执行，没有任何并发)](#ghkk-1710263260640)

<a name="7gn8-1726766099387"></a>[性能损失](#a876-1710263299289)

<a name="oqt6-1726766099389"></a>[弱隔离级别(非串行化nonserializable)](#nqm3-1710263313752)

<a name="jxot-1726766099391"></a>[较弱的隔离级别防止一部分，而非全部的并发问题](#e7nl-1710263334073)

<a name="jg3n-1726766099393"></a>[资金损失，耗费财务调查，财务数据请使用ACID数据库(注意：流行的数据库也使用弱隔离级别，不一定能防止并发错误)](#2xxd-1710331395046)

<a name="l1ho-1726766099395"></a>[读已提交](#pjqb-1710171742279)

<a name="ep30-1726766099397"></a>[没有脏读](#7h42-1710171796899)

<a name="lkod-1726766099399"></a>[dirty reads：事务看到另一个事务未提交的值](#lyju-1710332135761)

<a name="1fuy-1726766099401"></a>[为什么要防止dirty reads：](#x8ch-1710333899846)

<a name="50zh-1726766099403"></a>[更新多对象：脏读以为只看到部分数据](#pwpa-1710333902582)

<a name="adj8-1726766099405"></a>[事务中止：回滚后，看到的是未提交的数据](#jcj0-1710333902583)

<a name="w3qg-1726766099407"></a>[解决：只能读取提交后的数据，且不会阻塞，并行时保存已提交的旧值 -mvcc](#3mi1-1710332238978)

<a name="ew4y-1726766099409"></a>[没有脏写](#vmfl-1710171803833)

<a name="jkgx-1726766099412"></a>[dirty write: 事务同时更新相同对象。后面的写入覆盖尚未提交的值。](#hvah-1710332040048)

<a name="rxpu-1726766099414"></a>[避免的问题：](#chr0-1710333916523)

<a name="lgb8-1726766099416"></a>[混乱写入，导致bob后买车先更新发票commit而alic先买车后更新发票commit(buyer=bob but recipient=alice)](#14wx-1710333919188)

<a name="kj2f-1726766099418"></a>[解决：延迟/阻塞第二次的写入，直到第一次写入事务提交或终止。](#g1sw-1710332222649)

<a name="cfj6-1726766099420"></a>[但不能防止计数器增量的竞争状态。(读写非原子性，写依赖读的副本)](#ujzx-1710333397576)

<a name="lwbl-1726766099422"></a>[计数器增量安全：防止更新丢失 -版本号](#ugiq-1710333641028)

<a name="mle9-1726766099424"></a>[实现读已提交](#z96g-1710171821987)

<a name="vclf-1726766099426"></a>[默认的隔离级别：oracle,postgreSQL,sql server ,memSql](#tays-1710333754461)

<a name="glz2-1726766099428"></a>[行锁row-level lock](#svaf-1710333809593)

<a name="uilb-1726766099430"></a>[读写锁防止脏读：读写锁互斥，只有读锁拥有者可持有写锁。](#fsbu-1710334081090)

<a name="fe5k-1726766099432"></a>[缺点：阻塞，性能损失。](#xj1j-1710334321006)

<a name="pxdh-1726766099434"></a>[优化：所以一般用mvcc的模式。-或者copy on write](#7klj-1710334353854)

<a name="ypvs-1726766099436"></a>[快照隔离和可重复读](#bww4-1710171760070)

<a name="tjuf-1726766099438"></a>[不可重复读nonrepeatable read/读取偏差read skew](#wjut-1710343195467)

<a name="g6hh-1726766099440"></a>[skew重载：在热点指的是不平衡，这里指异常时机  alice两个账号各500，alice先读acount1=500,转账员将acount1+100,acount2-100后commit，alice读acount2=400.commit.导致Alice看起来少了100。-暂时不一致。](#jmuu-1710343248537)

<a name="h7cb-1726766099442"></a>[提交后，刷新网页即可。有些情况不能容忍暂时不一致：](#gwgf-1710343469620)

<a name="s06t-1726766099444"></a>[备份：数据库备份需要几小时，期间接收写入包含新老数据。如果备份用于恢复，不一致就变成永久的了。-解决：全局锁/快照备份](#m0km-1710345572560)

<a name="hgyw-1726766099446"></a>[分析查询和完整性检查：扫描大部分数据库，查询在不同时间点观察数据库产生不同，可能返回无意义的结果。](#i5pt-1710345666724)

<a name="ewod-1726766099448"></a>[ 快照隔离snapshot isolation 对长时间运行的只读查询非常有用（备份和分析）。](#p7tm-1710345899708)

<a name="xutt-1726766099450"></a>[ 即 一致快照consistent snapshot,即使被另一个事务更改，每个事务只能看到该特定时间的旧数据（特定时间点冻结的一致快照）。](#q8oz-1710345935366)

<a name="5sdz-1726766099452"></a>[PostgerSQL, mysql innoDB, Oracle, sqlServer](#mo1i-1710346175801)

<a name="budv-1726766099454"></a>[实现快照隔离](#2hpt-1710171981487)

<a name="ekrh-1726766099456"></a>[关键原则：读不阻塞写，写不阻塞读。两者没有任何锁定争用。](#49s0-1710346236063)

<a name="xyax-1726766099458"></a>[多版本并发控制mvcc,multi-version concurrentcy contorl](#w8v8-1710346319154)

<a name="8kjs-1726766099460"></a>[读已提交不提供快照隔离，保留对象的一两个版本就足够。通常支持快照隔离也是用mvcc来实现读已提交隔离级别：](#fh82-1710346453757)

<a name="cmzl-1726766099462"></a>[读已提交为每个查询使用单独的快照-每个select单独生成。](#3xbw-1710346540026)

<a name="jgsi-1726766099464"></a>[快照隔离对整个事务使用相同的快照-复用第一个select生成的快照](#xqhm-1710346554737)

<a name="k8hx-1726766099466"></a>[update操作在内部翻译为Delete 和 insert](#pmk8-1710351883488)

<a name="riu7-1726766099468"></a>[-innoDB实际上delete将旧数据版本移到undolog版本链中。垃圾收集会删除任何事务不可见的就对象版本。](#vnfd-1710351911457)

<a name="vxng-1726766099470"></a>[观察一致性快照的可见性规则](#box0-1710171988275)

<a name="omv6-1726766099472"></a>[从来不更新值，而是每次值改变时创建一个新版本。使得数据库提供一致快照产生的开销很小。](#yapf-1710408915465)

<a name="c3fe-1726766099474"></a>[事务id决定它可以看到哪些对象，规则如下：](#ecrk-1710408160769)

<a name="pbia-1726766099476"></a>[事务开始时列出当时所有事务清单，即使之后提交，这些事务的写入也都会被忽略。](#ogtp-1710408539120)

<a name="bmqz-1726766099478"></a>[忽略被中止事务任何写入](#unjc-1710408595672)

<a name="7ndu-1726766099480"></a>[较晚(当前事务之后开始)的写入都被忽略，不管是否提交](#ofbz-1710408626209)

<a name="3kv0-1726766099482"></a>[所有其他写入，对应用都是可见的。](#hgwi-1710408682423)

<a name="pgfp-1726766099484"></a>[对象可见的两条规则](#rg1c-1710408738736)

<a name="vhwa-1726766099486"></a>[读事务开始时，创建该对象的事务已提交。](#weyp-1710408754844)

<a name="a5pu-1726766099488"></a>[请求删除的事务在读事务开始时未提交。](#xqky-1710408773006)

<a name="dmji-1726766099490"></a>[索引和快照隔离(索引如何在多版本数据库中工作)](#ai77-1710171999516)

<a name="xqbs-1726766099492"></a>[同一对象不同版本放在同一个页面中，PostgreSQL的优化可以避免更新索引](#kanl-1710410047690)

<a name="4sjs-1726766099494"></a>[仅追加/写时拷贝apeend-only/copy-on-wirte的变体B树：更新不覆盖树的页面，为每个修改页创建副本。](#yv2q-1710410120895)

<a name="gldl-1726766099496"></a>[每个写入事务/一批事务都会创建一个新的B树，当创建时，从该特定树根生长的树就是数据库的一个一致性快照。](#etza-1710410471666)

<a name="birs-1726766099498"></a>[需要负责压缩和垃圾收集的后台进程。](#79xv-1710410561061)

<a name="5url-1726766099500"></a>[可重复读与命名混淆](#xr4f-1710172004472)

<a name="orzw-1726766099502"></a>[原因：System R定义隔离级别时并未有快照隔离](#nohd-1710417835613)

<a name="vkcs-1726766099504"></a>[oracle DB2 称为序列化](#uwdp-1710417928621)

<a name="jjno-1726766099506"></a>[postgreSql mySql称为可重复读](#f5te-1710417946615)

<a name="ajfz-1726766099508"></a>[防止丢失更新](#e9wg-1710171770800)

<a name="uv3j-1726766099510"></a>[脏写导致丢失更新lost update](#ajmt-1710418075399)

<a name="kvb5-1726766099512"></a>[读取-修改-写入序列的狠揍clobber：第二个事务并没有包括第一个事务的修改: -写依赖读](#c7rv-1710418271703)

<a name="rgc5-1726766099514"></a>[增加计数器或更新账户余额(需读取当前值，计算新值并写回更新后的值)](#uvoq-1710418375497)

<a name="rxyi-1726766099516"></a>[进行本地修改： 解析文档，更改后回写修改的文档](#ro12-1710418458493)

<a name="shov-1726766099518"></a>[同时编辑wiki页面：整个页面覆盖当前内容。](#9n83-1710418515773)

<a name="u14v-1726766099520"></a>[原子写(x排它锁)](#lftw-1710172034957)

<a name="awto-1726766099522"></a>[数据库原子更新操作保证并发安全](#6jim-1710418574114)

<a name="fxvh-1726766099524"></a>[mysql: 行级写锁](#dxgy-1710419672127)

<a name="f44c-1726766099526"></a>[MongoDB：对JSON文档一部分进行本地修改的原子操作](#bqxj-1710419591972)

<a name="yqsw-1726766099528"></a>[redis提供了优先队列等修改数据的原子操作。](#wxju-1710419646040)

<a name="6c5u-1726766099530"></a>[原子操作/游标稳定性cursor stability：通常在读取对象时获取其上的排它锁，以便提交前没有事务可以读取它。另一个选择是将所有原子操作在单一线程上执行。-redis](#h0ip-1710421887552)

<a name="wih6-1726766099532"></a>[unfortunately,ORM框架易执行读取-修改-写入序列，而不是使用数据库提供的原子操作。如果你知道自己在做什么那当然不是问题](#6hwo-1710422121598)

<a name="s6tt-1726766099534"></a>[显式锁定(for update：读-改-写序列)](#vysa-1710172041914)

<a name="8asj-1726766099536"></a>[让应用程序显示锁定更新的对象，直到一个读取-修改-写入序列完成](#oknq-1710422501689)

<a name="q5oj-1726766099538"></a>[select ..... for update;](#89ij-1710422624973)

<a name="p2o5-1726766099540"></a>[--更新先前select 返回棋子的位置。](#50q1-1710422845671)

<a name="ljfq-1726766099542"></a>[ update](#rmgw-1710422637550)

<a name="6xkr-1726766099544"></a>[for update-对返回的所有行加锁，忘记加锁很容易引入竞争条件(同时修改)](#euv5-1710422671170)

<a name="vhit-1726766099546"></a>[自动检测丢失的更新(管理器检测处理并发问题)](#jpu5-1710172058032)

<a name="cwvs-1726766099548"></a>[允许并行执行，事务管理器检测到丢失更新，中止事务并强制重试读-改-写序列。](#8ytj-1710423161566)

<a name="ifq1-1726766099550"></a>[Oracle可串行化(快照隔离)和sqlServer的快照隔离级别会自动检测到丢失更新，中止惹麻烦的事务。一些作者认为能防止丢失更新才算提供快照隔离。这个定义下，mysql不算提供快照隔离](#w9el-1710423029153)

<a name="y0nj-1726766099552"></a>[优点：是一个很好的功能，不需要应用代码使用任何特殊数据库功能。允许你忘记加锁或原子操作，由管理器检测丢失更新。](#qg6e-1710423330067)

<a name="pubg-1726766099554"></a>[比较并设置(CAS)](#ftwe-1710172063360)

<a name="hn4y-1726766099556"></a>[不提供事务的数据库中的原子操作：比较并设置（CAS compare and set）](#os3h-1710424617661)

<a name="ismx-1726766099558"></a>[update table set content='new content' where id=123 and content = 'old content'  必要时重试](#hlfh-1710425612756)

<a name="lqz1-1726766099560"></a>[问题：数据库允许where子句从旧快照读取，此语句无法防止丢失更新。即另一个并发写入，where条件也为真。-非当前读或非原子写。](#rxcv-1710425806449)

<a name="rg7y-1726766099562"></a>[解决：检查数据库的CAS是否安全。保证比较交换为当前读且写是否加锁/原子写](#zss4-1710425865867)

<a name="vaqq-1726766099564"></a>[冲突解决与复制(多个数据库副本的并发)](#bvrp-1710172079412)

<a name="dlx0-1726766099566"></a>[基于锁和cas操作不适用于多个数据库副本](#ewf7-1710434904534)

<a name="3aeb-1726766099568"></a>[如检测并发写入：允许并发吸入创建多个冲突版本(也称兄弟），应用代码或特殊数据结构在发生之后解决合并这些版本。](#8dx4-1710434970886)

<a name="wiob-1726766099570"></a>[原子操作可在复制的上下文中很好工作，尤其具有可交换性时。Riak2.0不同客户端同时更新一个值是，Riak将自动更新合并在一起，以免丢失更新。防止复制副本丢失更新。](#gl8j-1710435048968)

<a name="ypej-1726766099572"></a>[最后写入LWW解决冲突很容易丢失更新。unfortunately,许多复制数据库默认LWW。](#gdtn-1710435259414)

<a name="z94y-1726766099574"></a>[写入偏差与幻读（两个事务更新两个不同的对象）](#rkev-1710172453385)

<a name="ptsm-1726766099576"></a>[select count(*) where oncall=true....alice 和 bob分别查在职医生人数](#itfd-1710436127298)

<a name="2dey-1726766099578"></a>[update...set oncall=false 然后将自己的记录更新为请假，违反至少一医生在职。](#leam-1710436160580)

<a name="xw5y-1726766099580"></a>[写偏差的特征](#ovid-1710172462835)

<a name="jf9i-1726766099582"></a>[特征：涉及多个对象，单对象的原子操作不起作用](#iedp-1710437034438)

<a name="umx3-1726766099584"></a>[快照隔离实现中，自动检测丢失更新对此无帮助。postgred,innodb的可重复读，oracle序列化或sql server的快照隔离级别中，都不会自动检测写入偏差。写入偏差需要真正的可序列隔离-业务上的问题。](#wszw-1710437034814)

<a name="yqxd-1726766099586"></a>[数据库配置约束，指定至少一个值为true.大多数不支持这种配置，可以使用触发器或者物化视图实现。](#hn04-1710437034815)

<a name="8oln-1726766099588"></a>[显示锁定。 select ...fro update -锁定返回的所有行，锁定两个医生](#crrt-1710437034816)

<a name="ui7i-1726766099590"></a>[写偏差的更多例子](#4jr1-1710172470885)

<a name="8to6-1726766099592"></a>[读数据为空，分别插入一条数据的会议室预定系统：select count(*) from bookings where roomid=123 and time...，insert into bookings....不能防止另一个用户插入冲突会议。解决：又需要串行化执行。](#0hyt-1710437389755)

<a name="g2ho-1726766099594"></a>[多人游戏：棋盘用锁防止丢失更新，但锁定不能妨碍将不同的棋子放在相同位置。产生写入偏差 。解决：使用唯一约束。](#pgcb-1710437636980)

<a name="isyn-1726766099596"></a>[抢注用户名：和会议系统一样。不过唯一性约束可以解决该问题。](#bwel-1710437042998)

<a name="0sqf-1726766099598"></a>[防止双重开支；用户花钱和积分服务，检查支付数不超过余额，有了写入偏差，可能会发生两个支出项目同时插入，导致余额变为负值，两个事务都不会注意到另一个。](#ogt8-1710438166946)

<a name="0ik6-1726766099600"></a>[导致写入偏差的幻读](#8gty-1710172478550)

<a name="xv5h-1726766099602"></a>[所有以上例子都遵循类似的模式](#tw0y-1710438423955)

<a name="kyjx-1726766099604"></a>[Select查询符合条件的行，至少两名医生值班；不存在该会议室同一时段的预定；棋盘位置未被占据；用户未被抢注；账户还有足够余额](#bngi-1710438445792)

<a name="xpc9-1726766099606"></a>[按照第一个查询的结果，应用代码决定是否继续](#l6p0-1710438590471)

<a name="24vo-1726766099608"></a>[应用决定继续操作，执行写入(插入更新删除），并提交事务](#qt10-1710438739456)

<a name="zbln-1726766099610"></a>[步骤3修改的行，是步骤1中返回的行之一，可以使用select for update来使事务安全避免写入偏差.](#cdmo-1710438899441)

<a name="qc91-1726766099612"></a>[但检查是否不存在满足条件行，写入添加一个匹配相同条件的行。select for update 锁不了任何东西。](#caet-1710439501945)

<a name="degv-1726766099614"></a>[       这种效应：一个事务中的写入改变另一个事务的搜索查询结果，被称为幻读。快照隔离避免了只读查询中的幻读。以上的读写事务中，幻影会导致特别棘手的写歪斜情况。](#cwgh-1710440241091)

<a name="wty0-1726766099616"></a>[物化冲突](#1cjy-1710172485201)

<a name="j6jn-1726766099618"></a>[物化冲突：将幻读变为数据库中一组具体行上的锁冲突。](#fv3x-1710440426895)

<a name="ec2f-1726766099620"></a>[通过创建时间槽和房间的表，提前出入房间和时间的所有可能组合。创建预定的事务可以select for update锁定房间和时间段对应的行，在获得锁定后，可以检查重叠的预定并插入新的预定。该表不是存储预定相关的信息，它完全就是一组锁，用于防止同时修改同一房间和时间范围内的预定。](#laff-1710440634993)

<a name="yya0-1726766099622"></a>[缺点：弄清除如何物化冲突可能很难，也很容易出错，而让并发控制机制泄露到应用数据模型是很丑陋的做法。](#dngy-1710441936216)

<a name="1nxg-1726766099624"></a>[物化重入应为最后的手段。可序列化Serializeble级别是更可取的。](#i0he-1710441997817)

<a name="egdh-1726766099626"></a>[.可序列化](#di29-1710167844061)

<a name="7noe-1726766099628"></a>[弱隔离级别读已提交和快照隔离不能解决写入偏差幻读：](#ztac-1710587737356)

<a name="luwo-1726766099630"></a>[隔离级别难以理解，且不同数据库中实现不一致，可重复读概念不一样](#ky3h-1710588699885)

<a name="vi5w-1726766099632"></a>[光检查应用代码很难判定在特定隔离界别是否安全](#tpbs-1710588738858)

<a name="aku3-1726766099634"></a>[无检测竞争条件的好工具，往往倒霉时才会出现问题。](#jp98-1710588779920)

<a name="rtmg-1726766099636"></a>[20世纪70年代system R就已经是这样，研究人员的答案都很简单：可序列化（serializeble）级别（但非人见人爱），都使用三种技术之一。](#sqvc-1710588820273)

<a name="su6l-1726766099638"></a>[字面意义上的串行顺序执行事务](#mqa4-1710589545518)

<a name="ywvs-1726766099640"></a>[两相锁定2PL two-phase locking,几十年来唯一的可行选择](#neot-1710589568078)

<a name="rmg8-1726766099642"></a>[乐观并发控制，可序列话的快照隔离serializable snapshot isolation](#pizj-1710589721553)

<a name="mru8-1726766099644"></a>[真的串行执行(单线程执行事务)](#2oi3-1710172506817)

<a name="lfau-1726766099646"></a>[数据库设计人员07年才确定，单线程循环执行事务时可行的。（多线程过去30年中被认为是获得良好性能的关键所在）](#o5af-1710589822067)

<a name="n0ho-1726766099648"></a>[两个进展引发了这个反思：](#phuh-1710609564138)

<a name="5i4l-1726766099650"></a>[RAM足够便宜，许多场景可以将完整的活跃数据保存在内存中。-redis](#owi7-1710609747624)

<a name="fuun-1726766099652"></a>[数据库设计人员意识到OLTP事务很短，只进行少量的读写操作。长时间的分析查询通常是只读的，可以用一致快照（快照隔离）上运行。](#vhy4-1710609817752)

<a name="rm0v-1726766099654"></a>[VoltDB/H-Store, Redis 和 Datomic中实现。避免锁的协调开销。吞吐量仅限单个cpu](#xcax-1710609934885)

<a name="zkvx-1726766099656"></a>[在存储过程中封装事务(优化交互式单线程事务)](#xh4n-1710172519134)

<a name="srpr-1726766099658"></a>[数据库设计者认为，机票全流程是一个事务，可以被原子化执行。缺点：交互式会使流程性能直接下降。](#xthc-1710757083497)

<a name="hku5-1726766099660"></a>[解决：单线程串行执行事务的系统不允许交互式的多语句事务。提前将整个事务作为存储过程提交数据库：](#oo8b-1710757291600)

<a name="ljgu-1726766099662"></a>[Interactive transaction :bob医生请假 1.select count  2.if count>=2 3.update false](#9fzd-1710757436562)

<a name="gfib-1726766099664"></a>[stored procedure: execute stored take doctor of call](#gegl-1710763202697)

<a name="tuux-1726766099666"></a>[事务所需的数据都在内存中，快速执行，无需等待网络和磁盘IO](#t47s-1710763179337)

<a name="xfko-1726766099668"></a>[存储过程的优点和缺点](#7ksv-1710172529258)

<a name="k0ta-1726766099670"></a>[名声不好：](#jfoa-1710763413471)

<a name="opi4-1726766099672"></a>[陈旧丑陋无库生态，数据库存储过程各自的语言没跟上通用编程语言的发展](#4qhf-1710763421594)

<a name="ekwg-1726766099674"></a>[管理困难，调试困难，版本控制测试部署困难，和监控指标的系统集成困难](#96la-1710763483936)

<a name="s8wq-1726766099676"></a>[单个数据库通常由多个应用共享，写得不好的存储过程（占用大量内存和cpu）会比代码造成更大麻烦](#idii-1710763602399)

<a name="hgc7-1726766099678"></a>[ 这些问题都可以克服。现代存储过程放弃了PL/SQL,使用现有通用编程语言：VoltDB使用java或Groovy, Datomic使用Java或Clojure, Redis使用Lua.](#1w0a-1710763899035)

<a name="mqjx-1726766099680"></a>[存储过程与内存存储，使得单线程执行事务可行，](#bp68-1710767504595)

<a name="ejg0-1726766099682"></a>[无需等待I/O,](#ahfz-1710767568244)

<a name="iozd-1726766099684"></a>[避免并发控制机制的开销，可以在单线程实现相当好吞吐量](#mfvt-1710767570930)

<a name="83jr-1726766099686"></a>[VoltDB还用存储过程进行复制，在每个节点上执行相同的存储过程，所以要求存储过程是确定性的。比如使用当前日期，需要通过特殊的确定性API实现。](#7m1p-1710767621202)

<a name="2a57-1726766099688"></a>[分区](#xxtp-1710172539181)

<a name="zg6k-1726766099690"></a>[顺序执行事务使并发控制简单多，但吞吐限制为单机单核。吞吐量高的应用，单线程将可能成为严重瓶颈。](#rqu5-1710767939361)

<a name="rkmz-1726766099692"></a>[扩展多核多节点，可以对数据进行分区，每个事务只需在单个分区中读写数据，事务吞度量就可以与cpu保持现行扩展。](#puih-1710768082742)

<a name="y6cv-1726766099694"></a>[对于需要访问多个分区的任务事务，需要进行协调，存储过程跨所有分区锁定执行，保证串行。](#jpiw-1710768164695)

<a name="ddp0-1726766099696"></a>[缺点：协调开销性能比单区事务慢得多。VoltDB吞吐量每秒1000个跨分区写入，比单分区低几个数量级，且通过增加机器来提高](#fgu3-1710768218238)

<a name="wzah-1726766099698"></a>[事务是否可划分-应用的数据结构，键值数据，多个二级索的数据引需要大量跨分区协调。](#8lf4-1710768407791)

<a name="ox8w-1726766099700"></a>[串行执行小结](#zyih-1710172540516)

<a name="ui1x-1726766099702"></a>[需每个事务小而快，一个缓慢的事务拖慢所有事务。](#dibg-1710768638498)

<a name="ioum-1726766099704"></a>[可放入内存仅限活跃数据集，少量数据会移动到磁盘。但需要访问执行中的事务，系统会变慢。](#22nq-1710768681244)

<a name="4jem-1726766099706"></a>[写入吞吐量必须低到能在单个cpu运行，否则事务能划分至但分区，且无需分区协调](#jmsk-1710768781527)

<a name="ruix-1726766099708"></a>[跨分区事务使用程度受限。](#wlnd-1710769060180)

<a name="i4qx-1726766099710"></a>[两阶段锁定（2PL）](#uhxa-1710172558745)

<a name="vijv-1726766099712"></a>[30年高使用的序列化算法：两阶段锁定2PL two phase locking ,独占访问exclusive access:](#nhdj-1710769248115)

<a name="q9yc-1726766099714"></a>[事务A读取对象，阻塞B写入，直至A提交；](#khdp-1710769659952)

<a name="vejm-1726766099716"></a>[事务A写入对象，阻塞B读取,直至A提交；](#elpw-1710769685611)

<a name="jkw2-1726766099718"></a>[快照隔离使得不会阻塞读，2PL提高序列化性质，解决丢失更新和写入偏差。](#6ja2-1710769959539)

<a name="fcew-1726766099720"></a>[实现两阶段锁](#lfuv-1710172605096)

<a name="mxwv-1726766099722"></a>[2PL即innoDB可序列化级别及DB2可重复读隔离级别。](#8oif-1710770052594)

<a name="bkoh-1726766099724"></a>[读写阻塞为每个对象添加锁。共享模式shared mode 与独占模式exclusive mode:](#6wad-1710770158675)

<a name="f72x-1726766099726"></a>[读取对象需以共享模式获取锁。读共享](#1dyc-1710770195788)

<a name="pbun-1726766099728"></a>[写入需独占模式取锁。写互斥。](#bshw-1710770251530)

<a name="d7k8-1726766099730"></a>[事务获得锁必须持有锁知道事务结束(提交或中止)。即一阶段获取锁，二阶段释放所有锁。](#r0b0-1711207524774)

<a name="u5qd-1726766099732"></a>[死锁deadlock, 数据库会自动检测死锁，并中止其中一个。被中止的事务充实需应用程序实现。](#iuyh-1710770211133)

<a name="p2uf-1726766099734"></a>[两阶段锁定的性能](#qi7j-1710172616303)

<a name="imhc-1726766099736"></a>[比弱隔离差得多](#vz0p-1711207837446)

<a name="9bsa-1726766099738"></a>[锁开销、串行并发性降低](#ienx-1711207878742)

<a name="viyv-1726766099740"></a>[交互式事务形成等待队列、高百分位响应慢](#z85f-1711207913718)

<a name="e834-1726766099742"></a>[死锁频繁时重试造成浪费](#kmkr-1711207799940)

<a name="uvwl-1726766099744"></a>[谓词锁predicate lock](#ccq8-1710172621528)

<a name="vqar-1726766099746"></a>[谓词锁：属于符合搜索条件的对象，解决幻读phantoms](#kfpi-1711208306292)

<a name="8dfi-1726766099748"></a>[事务A获取共享谓词锁shared-mode predicate lock读取匹配对象，与排它互斥](#6dqd-1711208459688)

<a name="gy2y-1726766099750"></a>[事务A写入需等待其他事务谓词锁释放。](#p3er-1711208588906)

<a name="0rw3-1726766099752"></a>[适用于尚不存在，将可能添加的对象（幻象），如果两阶段包含谓词锁，可实现串行化。](#bdwj-1711208433268)

<a name="1hev-1726766099754"></a>[索引范围锁next-key lock](#zv5c-1710172626404)

<a name="6yoh-1726766099756"></a>[谓词锁性能不佳：活跃事务持锁多，检查匹配非常耗时](#a3ce-1711208973949)

<a name="crah-1726766099758"></a>[2PL采用索引范围锁-简化版谓词锁：](#ayfb-1711209059199)

<a name="uusa-1726766099760"></a>[索引位于roomid, 指示room123用于预定](#qmbu-1711212311152)

<a name="ybka-1726766099762"></a>[或者索引位于时间上，指示12:00~13:00用于预定。](#ajbo-1711212362665)

<a name="fdei-1726766099764"></a>[以上任何一条件，当另一个事务想写入时，需要更新索引-叶子节点，会收到共享锁。解决幻读和写入偏差](#k1ie-1711212755816)

<a name="fejl-1726766099766"></a>[索引范围锁不如谓词锁精确，但开销低](#6lzs-1711212829915)

<a name="6pia-1726766099768"></a>[无可挂载索引，将退化为表锁，性能不利，但这是回退到一个安全位置。](#bofb-1711212877091)

<a name="yyyh-1726766099770"></a>[序列化快照隔离SSI（高性能序列化算法）](#slwa-1710172573367)

<a name="cba7-1726766099772"></a>[新算法：可序列化快照隔离SSI serializeble snapshot isolation 仅与快照隔离有很小性能损失. 08年 micheal cahill博士论文。](#lnci-1711213123166)

<a name="d7mw-1726766099774"></a>[用于单节点PostgreSQL9.1后序列化和分布式数据库](#weo0-1711213307841)

<a name="wmbc-1726766099776"></a>[处于实践证明阶段](#ue1s-1711213377985)

<a name="paqa-1726766099778"></a>[悲观pessimistic与乐观optimistic的并发控制](#yq9i-1710172639651)

<a name="zdpn-1726766099780"></a>[极致悲观：串行排它锁](#54jr-1711213690005)

<a name="wkxk-1726766099782"></a>[序列化快照隔离SSI是乐观技术： ](#bjxf-1711213769533)

<a name="vtok-1726766099784"></a>[缺点：多事务争用contention时性能不佳，大部分事务中止，吞吐量极限下有重试机制将使性能变差。](#mefw-1711213819265)

<a name="vmo1-1726766099786"></a>[优点：有备用容量，竞争不高场景比悲观好，可交换的原子操作可减少争用。](#nk1s-1711213915330)

<a name="bfgk-1726766099788"></a>[SSI在快照隔离基础上添加算法检测写入的序列化冲突，并决定中止哪些事务。](#snvf-1711214019984)

<a name="hilf-1726766099790"></a>[基于过时前提的决策](#9lgw-1710172651041)

<a name="fbfl-1726766099792"></a>[医生值班读取-修改-写入。数据库检测过时并终止：](#td4m-1711214184809)

<a name="yltw-1726766099794"></a>[检测对旧MVCC对象版本的读取(读之前存在未提交的写入)](#t08a-1711215992016)

<a name="zylg-1726766099796"></a>[检测影响先前读取的写入（读之后发生写入）](#aego-1711216030637)

<a name="do14-1726766099798"></a>[检测旧MVCC读取](#5smj-1710172660675)

<a name="dism-1726766099800"></a>[事务提交时，检测是否有被忽略的写入已被提交。](#z7u2-1711216050316)

<a name="c9fz-1726766099802"></a>[SSI支持一致快照中长时间运行的读取-仅在提交时中止检测的陈旧读取。因为只读不产生幻读和写入偏差风险](#afqq-1711216243096)

<a name="70ue-1726766099804"></a>[检测影响之前读取的写入](#mvok-1710172671381)

<a name="vkrz-1726766099806"></a>[事务写入提交时，在索引中查找最近读取受影响的其他事务，通知读取的事务非最新。并中止未提交写入的其他事务。](#mo5j-1711216452745)

<a name="am0u-1726766099808"></a>[可序列化的快照隔离的性能](#0sq6-1710172685702)

<a name="x9ol-1726766099811"></a>[粒度granularity，精准哪些事务需要中止，但簿记开销显著。](#g2eg-1711216636788)

<a name="jjwz-1726766099813"></a>[简略的跟踪速度快（粗粒度），但导致不必要的事务中止。](#ux2m-1711216812849)

<a name="dcjp-1726766099815"></a>[相比2PL, 不需要锁定阻塞，读性能高](#jzqb-1711216700614)

<a name="n4sr-1726766099817"></a>[相比串行化，可扩展多台机器提高吞吐量，可跨分区读。](#qm51-1710756953994)

<a name="8l0h-1726766099819"></a>[SSI要求事务尽量短，避免长事务发生冲突中止。慢事务SSI比2PL或串行执行更不敏感](#wvsk-1711216911828)

<a name="dmct-1726766099821"></a>[8.分布式系统的麻烦](#enui-1704985776096)

<a name="xgly-1726766099823"></a>[前几章failover故障切换, 复制延迟 与事务控制 处理各种可能发生的边缘情况，本章则是彻底的悲观总结。](#e2bp-1711387736669)

<a name="qype-1726766099825"></a>[故障与部分失效](#4yaw-1711386647072)

<a name="mxkq-1726766099827"></a>[部分失效partial failure  不确定性的nondeterministic: IDC配电单元故障](#9d0g-1711387883443)

<a name="obrr-1726766099829"></a>[云计算与超级计算机](#w7ln-1711386736921)

<a name="kxi9-1726766099831"></a>[不可靠的网络(Timeout)](#ynhs-1711386665148)

<a name="zeqc-1726766099833"></a>[请求丢失： 拔网线](#fav6-1711388032544)

<a name="cq1h-1726766099835"></a>[请求排队：](#znsf-1711388048086)

<a name="hwqx-1726766099837"></a>[请求失效：](#gmdu-1711388084834)

<a name="jkix-1726766099839"></a>[.....](#dssu-1711388054944)

<a name="tnnk-1726766099841"></a>[真实世界的网络故障](#y933-1711387087536)

<a name="veza-1726766099843"></a>[检测故障](#aywv-1711387099045)

<a name="y7jk-1726766099845"></a>[超时与无穷的延迟](#z4hi-1711387103669)

<a name="vkni-1726766099847"></a>[级联失效cascading failure](#qs2e-1711388153448)

<a name="symc-1726766099849"></a>[网络拥塞和排队](#gttn-1711387323883)

<a name="2emp-1726766099851"></a>[TCP执行流量控制flow control](#v9f2-1711388199023)

<a name="v81w-1726766099853"></a>[视频、语音会议使用UDP，折中丢包与流畅](#up7k-1711389082773)

<a name="rwpa-1726766099855"></a>[同步网络vs异步网络](#t56p-1711387113980)

<a name="smsr-1726766099857"></a>[有限延迟bounded delay：同步网络，不收排队影响](#fmrl-1711389283437)

<a name="fpmu-1726766099859"></a>[我们不能简单地使用网络延迟可预测吗](#bwvp-1711387335617)

<a name="zxh8-1726766099861"></a>[不可靠的时钟](#l3p1-1711386676597)

<a name="eejp-1726766099863"></a>[机器的时钟：硬件设备，石英振荡器，](#faqp-1711469591901)

<a name="fffl-1726766099865"></a>[不是完全准确的。](#xtjc-1711469629964)

<a name="xin6-1726766099867"></a>[同步时钟：网络时间协议NTP](#knwp-1711469656643)

<a name="tfpn-1726766099869"></a>[服务器从精确时间源获取时间-GPS接收器](#pfpq-1711469689783)

<a name="9kf3-1726766099871"></a>[单调钟与时钟](#qoxv-1711387218692)

<a name="4oqh-1726766099873"></a>[时钟](#wu2k-1711387376627)

<a name="gs3t-1726766099875"></a>[Linux: clock_gettime(CLOCK_REALTIME)](#obwb-1711469781129)

<a name="83sh-1726766099877"></a>[java:system.currentTimeMilis](#uxdp-1711469821742)

<a name="9gz3-1726766099879"></a>[通常与NTP同步，但举例NTP服务器太远，则可能被强制重置(及时跳回）](#gwyx-1711469840905)

<a name="j8mu-1726766099881"></a>[单调钟](#hl1a-1711387385739)

<a name="vxnp-1726766099883"></a>[保证总是前进](#uzaz-1711470052827)

<a name="t5pf-1726766099885"></a>[Linux:CLOCK_MONOTONIC](#tbmn-1711469988760)

<a name="icst-1726766099887"></a>[java:System.nanoTime](#fb70-1711470014393)

<a name="wspc-1726766099889"></a>[调整频率：NTP检测到计算机石英钟更快或更慢，则调整单调钟频率（偏移skewing时钟）.](#sn42-1711470028035)

<a name="3irc-1726766099891"></a>[不假定不同节点时钟存在同步：分布式系统用单调钟效果好，对测量的不准确不敏感](#ct3v-1711470667953)

<a name="ftrt-1726766099893"></a>[时钟同步与准确性](#a7gy-1711387238026)

<a name="ikhk-1726766099895"></a>[漂移drifts: 计算机石英钟不准确原因,取决机器温度。](#pbyu-1711470750697)

<a name="dxom-1726766099897"></a>[实现精确度：GPS接收机，精确时间协议PTP](#kgdy-1711470917769)

<a name="n8br-1726766099899"></a>[同步错误的原因：NTP守护进程配置错误，防火墙阻止NTP通信。](#kgez-1711470944635)

<a name="sdzt-1726766099901"></a>[依赖同步时钟](#vo0i-1711387245745)

<a name="tmxa-1726766099903"></a>[使用需要同步时钟的软件需监测所有机器间的时钟偏移](#zm2f-1711471000801)

<a name="fsfv-1726766099905"></a>[有序事件的时间戳](#fnxq-1711387475761)

<a name="u6de-1726766099907"></a>[写入排序问题：B客户端写入比A晚但具有更早的时间戳。 ](#n1pp-1711471283186)

<a name="wdkn-1726766099909"></a>[ 最后写入为准LWW](#50kp-1711471399605)

<a name="3hnc-1726766099911"></a>[ 版本向量](#axgx-1711471482711)

<a name="rhrt-1726766099913"></a>[时钟读数存在置信区间](#ofpq-1711387431462)

<a name="sxk4-1726766099915"></a>[ 置信区间的不确定性：NTP服务器的不去定性，加上服务器网络往返时间](#aihs-1711471513794)

<a name="yzsa-1726766099917"></a>[当clock_gettime()返回值不会告诉你预期错误，不知道置信区间是5毫秒还是5年](#aave-1711471693187)

<a name="3f3s-1726766099919"></a>[例外：Spanner Google TureTime API明确报告本地时钟置信区间（最早，最晚）。](#znqm-1711471741654)

<a name="myif-1726766099921"></a>[全局快照的同步时钟](#bfz6-1711387449885)

<a name="v1wq-1726766099923"></a>[分布式的事务快照隔离，分布式事务ID时序成为站不住脚瓶颈](#dpco-1711471815493)

<a name="ia6u-1726766099925"></a>[Spanner通过置信区间来比较A,B发生的时序。](#2ihe-1711471939317)

<a name="6wdi-1726766099927"></a>[分布式事务语义使用时钟同步是一个活跃的研究领域，没有在谷歌之外的主流数据库中实现。](#9qfk-1711471991096)

<a name="ssez-1726766099929"></a>[暂停进程](#3mnj-1711387250438)

<a name="jzi2-1726766099931"></a>[如何确保分布式主节点仍未领导者](#ui0e-1711472636558)

<a name="oftn-1726766099933"></a>[方式一：从其他节点获得租约lease, 类似一个带超时的锁，周期性过期前续约。-和redison续约类似](#yh9a-1711472775035)

<a name="aprn-1726766099935"></a>[过期时，由另一个节点接管。](#kqwv-1711472837428)

<a name="wqql-1726766099937"></a>[缺点：依赖同步时钟](#gi5a-1711473874947)

<a name="qoc9-1726766099939"></a>[意外的时间停顿：](#93uw-1711473992955)

<a name="lsch-1726766099941"></a>[stop-the-world  HotSpot GC](#7kp7-1711474017909)

<a name="qp8j-1726766099943"></a>[suspend虚拟机](#6ejp-1711474059672)

<a name="k3wp-1726766099945"></a>[随意暂停恢复：关闭笔记本盖子](#92se-1711474080346)

<a name="koww-1726766099947"></a>[窃取时间steal time:虚拟机切换或cpu上下文切换，在其他机器中花费的时间.](#tfxw-1711474128862)

<a name="q9qu-1726766099949"></a>[同步时的阻塞io：java惰性加载类文件；磁盘为网络文件系统或网络块设备-亚马逊EBS](#7jwg-1711474280466)

<a name="5m0w-1726766099951"></a>[磁盘交换内存抖动thrashing: 允许交换到磁盘（分页），内存访问可能导致页面错误page fault .话费大量时间将页面交换到内存，实际完成的工作很少thrashing。 服务器机器禁用页面调度，干掉进程释放内存。](#kvsa-1711474441136)

<a name="2j1e-1726766099953"></a>[SIGSTOP暂停unix进程:Ctrl-Z立即阻止进程的CPU周期](#ocvk-1711474648160)

<a name="nvjt-1726766099955"></a>[这些都可以随时抢占preempt正在运行的线程。](#t1w7-1711474768157)

<a name="dd4o-1726766099957"></a>[响应时间保证](#cirf-1711473855327)

<a name="uezr-1726766099959"></a>[硬实时hard real-time系统: 不满足特定截止时间deadline可能会导致整个系统故障。](#r1ji-1711474887529)

<a name="7iko-1726766099961"></a>[嵌入式系统精心设计和测试：安全气囊不会因系统GC暂停弹出。](#pgjw-1711475001376)

<a name="wvnq-1726766099963"></a>[大量的额外工作，昂贵。](#urp5-1711475089330)

<a name="v306-1726766099965"></a>[限制垃圾收集的影响](#i1wt-1711387521748)

<a name="yjcv-1726766099967"></a>[通知GC暂停，停止接收新请求-对延迟敏感的金融系统](#oxal-1711475134772)

<a name="qjnc-1726766099969"></a>[变种：GC只收集新生代，积累老年代，一次重启一个节点，类似滚动升级。](#ho3v-1711475217820)

<a name="u7qa-1726766099971"></a>[知识、真相与谎言](#ujyf-1711386681865)

<a name="kp0i-1726766099973"></a>[真理由多数所定义](#hdwi-1711387268312)

<a name="dqst-1726766099975"></a>[stop the world 一分钟，被其他节点宣告死亡，重新选举。](#rxcy-1711561420884)

<a name="ym0x-1726766099977"></a>[领导者与锁定](#3zea-1711387542106)

<a name="o20r-1726766099979"></a>[数据库分区领导者只能有一个节点：避免脑裂](#b6am-1711561462773)

<a name="ssg3-1726766099981"></a>[特定资源的锁和对象只允许一个事务/客户端持有](#3ynw-1711561525662)

<a name="l87e-1726766099983"></a>[用户唯一标识](#hqa3-1711561556083)

<a name="tqpb-1726766099985"></a>[节点认为它是天选者the choosen one](#rv2w-1711561875596)

<a name="f9vb-1726766099987"></a>[HBase例子：分布式锁的实现不正确，客户端1持有锁stop the world导致lease超时,客户端2获得锁进行处理，客户端1仍认为它具有有效的租约，即使它已经过期，从而破坏了存储的文件。](#gu25-1711561617808)

<a name="pddv-1726766099989"></a>[防护令牌](#mhlf-1711387550649)

<a name="hubn-1726766099991"></a>[解决天选者问题：防护fencing](#gw5w-1711561950975)

<a name="bt3g-1726766099993"></a>[fencing token :只允许增加屏蔽令牌的顺序进行写操作。](#vi5w-1711562021406)

<a name="n3gw-1726766099995"></a>[服务器端检查token,获取锁时token增加33+1，存储服务器记录更高令牌34的写入，拒绝令牌33的请求。-一般是redisson续期，这个更像乐观锁。](#2yxl-1711562140276)

<a name="f6xr-1726766099997"></a>[ZooKeeper将事务标识zxid和节点版本conersion用作屏蔽令牌。保证了单调递增](#e6n2-1711562077138)

<a name="u2jh-1726766099999"></a>[如文件存储服务器可将令牌卸载文件命中](#uujk-1711564755459)

<a name="ypu8-1726766100001"></a>[拜占庭故障](#bsay-1711387279845)

<a name="qeei-1726766100003"></a>[拜占庭故障Byzantine fault: 在不信任的环境中达成共识的问题称为拜占庭将军问题。](#id0b-1711628556885)

<a name="t5zp-1726766100005"></a>[拜占庭将军问题：n位将军需要同意，一些叛徒通过发送虚假或不真实信息来混淆欺骗他人。](#lxw6-1711628612728)

<a name="1opb-1726766100007"></a>[拜占庭容错：系统在部分节点发生故障、不遵守协议，恶意攻击，扰乱网络时仍能继续正确工作：](#lpn6-1711628716132)

<a name="xc9q-1726766100009"></a>[航空航天环境计算机被辐射破坏，不可预知方式响应其他节点](#py6z-1711638469892)

<a name="ubtj-1726766100011"></a>[多个参与组织系统中，参与者试图欺骗他人。比特币等区块链对等网络让互不信任的各方同意交易不依赖中央当局。](#csli-1711638605446)

<a name="pqlr-1726766100013"></a>[弱谎言形式](#f38o-1711387557457)

<a name="fwz0-1726766100015"></a>[添加防止撒谎弱形式机制；](#eepx-1711638744038)

<a name="efbo-1726766100017"></a>[校验和防止数据包被破坏](#yseh-1711638821915)

<a name="tyv6-1726766100019"></a>[公开访问的系统需仔细清理来自用户的任何输入](#2a8h-1711638847924)

<a name="mvjg-1726766100021"></a>[NTP多数对时间范围达成一致，配置错误的服务器将被排除](#zcdt-1711638888096)

<a name="ghaj-1726766100023"></a>[系统模型与实现](#x4lu-1711387293192)

<a name="wcnv-1726766100025"></a>[定时假设三种系统模型：](#iyps-1711639179162)

<a name="padp-1726766100027"></a>[同步模型synchronous model: 网络延迟，暂停和时钟漂移不会超过某个固定上限；](#pgo0-1711640511485)

<a name="tfdm-1726766100029"></a>[部分同步模型partial synchronous：大多数情况像一个同步系统一样运行，有时出现超时，进程暂停和时钟漂移界限](#h1x4-1711640383000)

<a name="rdri-1726766100031"></a>[异步模型：一个算法不允许对实际做任何假设，事实上它甚至没有时钟。](#vkkn-1711640459345)

<a name="bi07-1726766100033"></a>[节点系统模型：-节点失效问题](#lg5f-1711640536166)

<a name="m8ve-1726766100035"></a>[崩溃停止crash-stop:只能由崩溃失效，且永远不会回来。](#ahco-1711640498506)

<a name="ezq1-1726766100037"></a>[崩溃恢复crash-recovery: 具有稳定存储（非易失性磁盘），崩溃中保留，内存中状态会丢失-innodb三阶段提交](#35nl-1711640632666)

<a name="ta3j-1726766100039"></a>[拜占庭（任意）故障：节点可以做任何事情，包括戏弄和欺骗其他节点](#rpmc-1711640822813)

<a name="eqrd-1726766100041"></a>[具有崩溃恢复的部分同步模型是最有用的模型。分布式算法如何应用这种模型](#6gea-1711640879281)

<a name="ur62-1726766100043"></a>[算法的正确性](#hwoz-1711387576180)

<a name="ejuj-1726766100045"></a>[描述属性：定义算法的正确性](#i9kv-1711640972087)

<a name="9j9p-1726766100047"></a>[锁生成屏蔽令牌，要求具有以下属性：](#qsck-1711641049261)

<a name="9mx7-1726766100049"></a>[唯一性：没有两个屏蔽令牌请求返回相同的值](#tvxj-1711641079676)

<a name="ztcv-1726766100051"></a>[单调序列：时序实现单调](#2d0a-1711641105012)

<a name="p99x-1726766100053"></a>[可用性：请求防护令牌且不会崩溃的节点，最终会收到响应](#mlbd-1711641130527)

<a name="vcid-1726766100055"></a>[安全性和活性](#1lz8-1711387585629)

<a name="q3uw-1726766100057"></a>[澄清这种情况，需区分两种不同性质](#hctm-1711641203049)

<a name="8xoy-1726766100059"></a>[安全性safety: 唯一性和单调序列](#k48b-1711641295367)

<a name="tpd6-1726766100061"></a>[活性：可用性](#fmy7-1711641313609)

<a name="rg5d-1726766100063"></a>[将系统模型映射到现实世界](#ndiw-1711387592922)

<a name="4emv-1726766100065"></a>[9.一致性共识](#rp9s-1705080859004)

<a name="2vzr-1726766100067"></a>[共识consensus: 让所有节点对某件事达成一致](#vrvh-1712996687843)

<a name="qcfu-1726766100069"></a>[脑裂brain split: 两个节点都认为自己是master, 经常导致数据丢失；](#oqcs-1712996726634)

<a name="3ccb-1726766100071"></a>[一致性保证](#obqn-1711730044966)

<a name="9bke-1726766100073"></a>[最终一致性：收敛convergence, 最终收敛到相同的值](#ku5g-1712996774138)

<a name="rf5c-1726766100075"></a>[事务一致性：避免同时执行事务导致的竞争状态](#ga60-1712996859001)

<a name="4vy4-1726766100077"></a>[分布式一致性模型：面对延迟和故障时，如何协调副本间的状态](#eovi-1712996916251)

<a name="zmrm-1726766100079"></a>[线性一致性](#thyh-1711730049653)

<a name="1av1-1726766100081"></a>[背后的想法：原子一致性atomic consistency, 强一致性strong consistency, 立即一致性 immediate consistency ,外部一致性 external consistency](#bvre-1712997165569)

<a name="gzpx-1726766100083"></a>[看起来只有一个数据副本，实际有多个副本 - 强一致性就是逆分布式化，看成一个整体。](#qbsw-1712997247742)

<a name="urgb-1726766100085"></a>[线性一致是一个新鲜度保证 recency gurantee;](#f0su-1712997377059)

<a name="ddoo-1726766100087"></a>[非线性一致的例子： world cup ,  alice refresh - DB1 return germany 1: 0 argentina won ;  bob refresh website - DB2(un asychronize) return still playing;](#mtb7-1712997407717)

<a name="dbqx-1726766100089"></a>[为什么使得系统线性一致？](#qimr-1711730403998)

<a name="unnt-1726766100091"></a>[例子：CAS使得多个客户端并发按序更新](#ffat-1712998155207)

<a name="kx2p-1726766100093"></a>[线性一致性与可序列化是两种完全不同的保证：](#3elk-1712997586736)

<a name="ties-1726766100095"></a>[可序列化serializeble: 单对象或者多对象操作，确保按照某种顺序执行](#qpvu-1712998010030)

<a name="vmlw-1726766100097"></a>[线性一致性Linearizability:是读取和写入寄存器（单个对象）的新鲜度保证，不会将操作组合为事务，不会阻止写入偏差等问题](#ojsh-1712998125336)

<a name="0m3b-1726766100099"></a>[单副本强可串行性strong-1SR: 一个数据库可提供可串行性和线性一致, 基于两阶段锁2PL和实际串行执行通常是线性一致的](#5hda-1712998332148)

<a name="rib8-1726766100101"></a>[SSI一致性快照不是线性一致的：不会包括比快照更新的写入；-不会阻塞非写的读。](#obfn-1712998432352)

<a name="cqjv-1726766100103"></a>[依赖线性一致性](#bje8-1711730427157)

<a name="rqtk-1726766100105"></a>[锁定与领导选举](#xyll-1711730652620)

<a name="1av7-1726766100107"></a>[领导选举的一种方法：每个节点启动时尝试获取锁，成功者称为领导者。](#2fqs-1712998599719)

<a name="nxny-1726766100109"></a>[保证锁时线性一致的： zookeeper 和 etcd 协调服务的一致性算法。curator基于zookeeper上更高级别的配方](#cbzr-1712998723133)

<a name="yujw-1726766100111"></a>[约束和唯一性保证](#gpva-1711730659968)

<a name="brzx-1726766100113"></a>[这种情况类似于一个锁，锁定用户名。该操作与原子性的cas类似：](#9jmj-1712998930168)

<a name="vcwq-1726766100115"></a>[用户名和邮箱；](#lhyk-1712999021176)

<a name="eox8-1726766100117"></a>[银行账号不为负数；](#7sgo-1712999031257)

<a name="enzp-1726766100119"></a>[航班剧院预定了同一时间同一位置](#so5k-1712999045093)

<a name="tyjy-1726766100121"></a>[实际应用中，处理这些限制有时可以接受。如调换位置并补偿。](#q05j-1712999070223)

<a name="show-1726766100123"></a>[跨信道的时序依赖](#7cbv-1711730671963)

<a name="omlo-1726766100125"></a>[将用户上传的照片降低分辨率以加快下载速度：](#cqkp-1712999245541)

<a name="mbli-1726766100127"></a>[步骤：消息队列一般针对较短的消息而设计，一张图片可能达到几M.所以步骤为](#3zoo-1712999362806)

<a name="fisy-1726766100129"></a>[1.上传照片-  web server-2.  (store img) 存储文件服务器  ](#umkb-1712999318589)

<a name="vbqs-1726766100131"></a>[  | 3. send message  || 5.fetch full size img  6.store resized img](#er8u-1712999518585)

<a name="dyob-1726766100133"></a>[消息队列   - 4.deliver message     image resizer](#iiv4-1712999532781)

<a name="fzxm-1726766100135"></a>[问题：存储和缩放存在两个不同的信道，没有线性一致的新鲜度保证](#0yys-1712999647965)

<a name="zb9g-1726766100137"></a>[3和4可能比存储服务器内部的复制更快，当5时，可能会看到图像旧版本或者什么都没有，如果处理的是旧版本，则产生不一致。](#xtun-1712999768959)

<a name="4akc-1726766100139"></a>[实现线性一致性的系统](#ytt0-1711730433598)

<a name="iyoj-1726766100141"></a>[单主复制（可能线性一致）protential潜在线性一致：](#j997-1712999879559)

<a name="zf6n-1726766100143"></a>[快照隔离并发错误；](#t174-1712999979364)

<a name="4lnu-1726766100145"></a>[脑裂；异步复制延迟，故障切换](#hh6o-1712999996439)

<a name="3jwj-1726766100147"></a>[共识算法（线性一致）：共识算法可以安全实现线性一致性的存储，zookeeper 和 etcd](#z3nq-1713000050923)

<a name="tlyd-1726766100149"></a>[多主复制（非线性一致）：同时多个节点上处理写入，异步复制到其他节点，会产生冲突的写入](#q0kz-1713000066034)

<a name="kdi1-1726766100151"></a>[无主复制（也许不是线性一致的）：Dynamo风格，法定人数读写获得强一致性。通常不完全正确](#ca4m-1713030167882)

<a name="3oyi-1726766100153"></a>[线性一致性和法定人数](#9gst-1711730681011)

<a name="derc-1726766100155"></a>[最安全的做法是：假设采用Dynamo风格的无主复制的系统是不能提供线性一致性。](#sqvx-1713030399799)

<a name="dzca-1726766100157"></a>[线性一致性的代价](#vpxf-1711730440465)

<a name="cleo-1726766100159"></a>[CAP定理](#fqqf-1711730717308)

<a name="zjcf-1726766100161"></a>[不仅是单主多主复制的后果，任何线性一致性的数据库都有这个问题：](#8hzl-1713030564813)

<a name="prlw-1726766100163"></a>[.应用需要线性一致性，副本因为网络问题断开连接，请求必须等到网络问题解决或直接返回错误（不可用unavailable）](#7lux-1713030592466)

<a name="biso-1726766100165"></a>[.网络断开也可独立处理请求（如多主复制），可以在网络问题前保持可用，但其行为不是线性一致的。](#48wk-1713031150235)

<a name="gl3i-1726766100167"></a>[CAP定理没有帮助：网络分区是不可避免的，所以只能是AP 或 CP。](#lsdc-1713031249676)

<a name="njqg-1726766100169"></a>[线性一致性和网络延迟](#kxsm-1711730728177)

<a name="wsbn-1726766100171"></a>[ 线性一致的系统惊人的少。例如多核CPU并没有保证一定能读到第一个线程写入的值（除非使用内存屏障memory barrier或围栏fence）](#lbl2-1713031508671)

<a name="zgmb-1726766100173"></a>[ 牺牲线性一致性的原因是性能performance. 内存访问先走缓存，副本都是异步更新的，所以失去了线性一致性。](#pnsn-1713031585885)

<a name="zqtm-1726766100175"></a>[搞笑的线性一致性存储不可实现。](#8y6v-1713031685808)

<a name="dush-1726766100177"></a>[顺序保证](#on5f-1711730057760)

<a name="veoi-1726766100179"></a>[写入顺序order of write: 单主复制的主要目的就是复制日志中确定写入顺序。](#dhiv-1713031758875)

<a name="kble-1726766100181"></a>[序列顺序serial order：某种序列顺序some sequential order](#cyfr-1713031815356)

<a name="vkse-1726766100183"></a>[顺序与因果](#z48k-1711730472679)

<a name="cehk-1726766100185"></a>[顺序有助于保持因果关系causality](#khzl-1713031939113)

<a name="0nep-1726766100187"></a>[一致前缀读：先看到答案再看到问题。违背因cause果effect. 存在因果依赖causal dependency](#nbes-1713031966982)

<a name="zknn-1726766100189"></a>[更新不存在的记录：3位领导者间的复制，一些写入会压到其他写入。一条记录需被创建才能更新。](#xehj-1713032060272)

<a name="bkhq-1726766100191"></a>[检测并发写入：A和B并发，则不知道顺序，A和B不知道彼此。](#v1kv-1713032135082)

<a name="ghge-1726766100193"></a>[快照隔离：写偏差read skew，读取的数据违反因果关系（不可重复读）](#ozi8-1713032226341)

<a name="pfr5-1726766100195"></a>[事务的写偏差write skew：幻读和值班。](#pgzq-1713032264605)

<a name="dben-1726766100197"></a>[世界杯球赛结果，跨信道的时序依赖。](#3ang-1713032756197)

<a name="kqbb-1726766100199"></a>[因果一致causally：系统服从因果关系锁规定的顺序。](#tryg-1713032788961)

<a name="tzah-1726766100201"></a>[因果顺序不是全序的](#niwx-1711730751513)

<a name="grna-1726766100203"></a>[全序total order: 自然数更大或更小，总是有序的](#x8gk-1713086054855)

<a name="zdd7-1726766100205"></a>[偏序partially order: 一个集合大于另一个集合，但是其它情况下无法比较](#wvsa-1713086222914)

<a name="8lvz-1726766100207"></a>[线性一致性：操作是全序的，系统表现好像只有一个副本，所有操作都是原子性的。意味对每个操作总能判定发生顺序](#u7jq-1713086312064)

<a name="tdl4-1726766100209"></a>[因果性：两个操作没在彼此之前发生，即并发无法比较顺序，意味着因果关系定义了一个偏序，而不是全序。一些有序一些无序](#xa0w-1713086399916)

<a name="83jo-1726766100211"></a>[线性一致的数据存储中是不存在并发操作的。确保每个请求都是在唯一时间线上自动处理](#uaxz-1713086531138)

<a name="ooh4-1726766100213"></a>[并发意味着时间线会分叉然后合并。操作的偏序：](#qs64-1713086635361)

<a name="mibg-1726766100215"></a>[类似git系统，一个提交commit发生在另一个提交之后。分支合并merge会在这些并发创建的提交相融合时创建。](#ctkd-1713086670170)

<a name="0oop-1726766100217"></a>[线性一致性强于因果一致性](#qdnf-1711730766239)

<a name="nkk5-1726766100219"></a>[线性一致性隐含implies着因果关系;](#dam4-1713086279684)

<a name="gu0x-1726766100221"></a>[捕获因果关系](#uqqx-1711730776113)

<a name="1grq-1726766100223"></a>[为了维持因果性，需确认操作发生在哪个操作之前happened before:](#agrw-1713086796608)

<a name="9qcu-1726766100225"></a>[刑侦决定Y时是否知到X与Y因果关系](#rys3-1713086865582)

<a name="xlto-1726766100227"></a>[检测并发写入：推广版本向量解决因果依赖](#znup-1713086911030)

<a name="4xal-1726766100229"></a>[SSI序列化隔离快照：事务提交时，检测读取是否最新，为此跟踪哪些事务被那些事务锁读取。](#1ivk-1713086936754)

<a name="v4rr-1726766100231"></a>[序列号顺序](#jsuf-1711730485869)

<a name="17zd-1726766100233"></a>[序列号sequence number或时间戳timestamp](#y9ti-1713091524670)

<a name="tqqx-1726766100235"></a>[非因果序列号生成器](#qpya-1711730796494)

<a name="niyq-1726766100237"></a>[兰伯特时间戳](#mtzj-1711730811106)

<a name="1w54-1726766100239"></a>[兰伯特时间戳提供了与因果关系一致的总排序：施行一个全序](#f8uv-1713091653199)

<a name="deau-1726766100241"></a>[检测并发写入有着不同目的：区分两个操作是并发的，一个因果依赖另一个。](#2ayx-1713091789731)

<a name="4cvp-1726766100244"></a>[光有时间戳排序还不够](#elc6-1711730816628)

<a name="ksjy-1726766100246"></a>[全序广播](#aw2l-1711730490423)

<a name="p04r-1726766100248"></a>[可靠交付reliable delivery：没有消息丢失，如果消息被传递到一个节点，它将被传递到所有节点](#axul-1713091937508)

<a name="zpaw-1726766100250"></a>[全序交付totally ordered delivery: 消息以相同的顺序传递给每个节点。](#cruc-1713091989510)

<a name="hube-1726766100252"></a>[使用全序广播](#hp3a-1711730834892)

<a name="4cfn-1726766100254"></a>[zookeeper和etcd共识服务实际上实现了全序广播](#ztws-1713108978601)

<a name="pwnh-1726766100256"></a>[状态机复制state machine repliacation: 每个副本都按相同的顺序处理相同的写入。](#i8bk-1713109007327)

<a name="easi-1726766100258"></a>[与之类似，使用全序广播来实现可序列化的事务：真的串行执行，确定的事务以存储过程来执行，每个节点以相同的顺序处理这些消息。](#8jch-1713109071990)

<a name="8ttt-1726766100260"></a>[以及防护令牌的锁服务，全序广播使得所有消息按顺序一次编号，序列号可当做防护令牌(单调递增)，zookeeper中这个序列号称为zxid;](#w19a-1713109204107)

<a name="e1r8-1726766100262"></a>[使用全序广播实现线性一致的存储](#i3vg-1711730844593)

<a name="xtqh-1726766100264"></a>[使用线性一致性存储实现全序广播](#xlae-1711730855140)

<a name="xxye-1726766100266"></a>[分布式事务与共识](#y1bv-1711730380233)

<a name="5w0t-1726766100268"></a>[让几个节点达成一致get serveral nodes to agree on somthing](#yt5r-1713109388776)

<a name="ecmr-1726766100270"></a>[领导选举：避免脑裂](#d7t7-1713109479427)

<a name="253f-1726766100272"></a>[原子提交atomic commit：多节点事务提交/中止/回滚](#frsp-1713109508353)

<a name="tesf-1726766100274"></a>[原子提交与两阶段提交2PC](#abk6-1711730509647)

<a name="ehr8-1726766100276"></a>[原子性可以避免中间态，多对象事务原子性确保二级索引与主数据库保持一致。](#0h2f-1713110484428)

<a name="ml0s-1726766100278"></a>[从单节点到分布式原子提交](#iqfd-1711730882368)

<a name="ge79-1726766100280"></a>[从数据库的角度看，这是单独的事务，任何跨事务正确性的保证都是应用自己的问题。](#h1ym-1713110537245)

<a name="kory-1726766100282"></a>[2PC两阶段提交简介](#roa9-1711730906391)

<a name="xlfd-1726766100284"></a>[coodinator协调子事务，子事务单独执行完，在准备阶段询问是否可提交](#vaax-1705118249954)

<a name="md4m-1726766100286"></a>[.全部为是，则分别提交。](#7zwc-1705118288968)

<a name="mi5n-1726766100288"></a>[.其中有否，则中断回滚。](#3b8s-1705118337513)

<a name="jnpp-1726766100290"></a>[系统承诺](#kpgk-1711730913393)

<a name="qipm-1726766100292"></a>[一旦协调者做出决定，这一决定是不可撤销的。](#wkui-1713110739239)

<a name="phdj-1726766100294"></a>[协调者失败](#qhdj-1711730921387)

<a name="y1zy-1726766100296"></a>[参与者投赞成票后，参与者协调者崩溃，数据库1不知道是否提交或中止。](#jpd8-1713110804532)

<a name="bbxc-1726766100298"></a>[三阶段提交](#ixzv-1711730924556)

<a name="iblz-1726766100300"></a>[阻塞blocking原子提交协议, 2PC可能卡主等待协调者恢复的情况。](#edp3-1713111179295)

<a name="zomk-1726766100302"></a>[在提交阶段，如果子事务进程crash,或者协调者崩溃的时的解决方案，弱原子性，最终一致性。](#llyc-1711731148564)

<a name="mqff-1726766100304"></a>[许多coodinator不支持高可用或者只支持基本的复制](#nlrk-1705118500709)

<a name="klql-1726766100306"></a>[实践中的分布式事务](#xexf-1711730524691)

<a name="svib-1726766100308"></a>[云服务由于其导致的运维问题而选择不实现分布式事务。](#inqh-1713111548114)

<a name="t5ot-1726766100310"></a>[两阶段难以实现安全保证，且导致的运维问题造成性能下降。](#zuho-1713111590325)

<a name="lbma-1726766100312"></a>[数据库内部的分布式事务](#gf92-1711731287296)

<a name="lnqf-1726766100314"></a>[VoltDB 与mysql Cluster 的NDB引擎就有这样的内部事务支持。](#jhqw-1705080950920)

<a name="if9p-1726766100316"></a>[异构分布式事务](#gvng-1713111648038)

<a name="8ioj-1726766100318"></a>[保证异构数据库的事务更有挑战性](#st60-1713111659854)

<a name="weoy-1726766100320"></a>[恰好一次的消息处理](#btdt-1711730944613)

<a name="nodf-1726766100322"></a>[XA事务eXtended Architecture](#qvbk-1711730954739)

<a name="ad0t-1726766100324"></a>[怀疑时持有锁](#med0-1711730959684)

<a name="fdl5-1726766100326"></a>[从协调者故障中恢复](#ouyq-1711730969007)

<a name="kqvi-1726766100328"></a>[唯一的出路是让管理员手动决定提交还是回滚事务](#ouur-1713116418144)

<a name="ntfy-1726766100330"></a>[分布式事务的限制](#gzya-1711730975747)

<a name="mjon-1726766100332"></a>[协调者本身就是一种数据库，存储了事务的结果。](#jkt3-1713116480399)

<a name="mgda-1726766100334"></a>[协调者默认不是高可用的，只有基本的复制](#mcvv-1713116529836)

<a name="y9t4-1726766100336"></a>[应用服务器不再是无状态的了](#h6gt-1713116550997)

<a name="yxl8-1726766100338"></a>[不能检测不同系统间的死锁，且无法与SSI协同工作](#rrrl-1713116568769)

<a name="wivm-1726766100340"></a>[与构建容错系统的目标背道而驰，分布式事务有扩大失效amplifying failures的趋势](#wbzw-1713116600081)

<a name="rydp-1726766100342"></a>[容错共识](#npne-1713118985168)

<a name="1h1t-1726766100344"></a>[一个或多个节点提议propose某些值，共识算法决定decides采用其中的某个值。](#beiq-1713118985169)

<a name="gl7f-1726766100346"></a>[一致同意Uniform agreement:  没有两个节点的决定不同-核心 决定了相同的结果，一旦决定不能改变](#pq0x-1713118985170)

<a name="2o8b-1726766100348"></a>[完整性Integrity: 没有节点决定两次-核心](#xnwp-1713118985171)

<a name="dpsg-1726766100350"></a>[有效性validity: 如果一个节点决定了值v, 则v由某个节点所提议-排除平凡的解决方案](#2bty-1713118985172)

<a name="zvjw-1726766100352"></a>[终止Termination由所有为崩溃的几点来最终决定值。-活性属性，必须取得进展，即使部分节点出现故障，其他节点也必须达成一致。不超过一般的节点崩溃或不可达](#9k32-1713118985173)

<a name="8rsj-1726766100354"></a>[稳健达成共识：只要少于三分之一的节点存在拜占庭故障](#scne-1713118985174)

<a name="ypes-1726766100356"></a>[共识算法和全序广播](#prxr-1713118985175)

<a name="vysu-1726766100358"></a>[视图戳复制VSR viewstamped repliacation, Paxos，Raft, Zab](#zmcg-1713118985176)

<a name="oaqi-1726766100360"></a>[全序广播相当于重复进行多轮共识：](#1u8f-1713118985177)

<a name="w46e-1726766100362"></a>[一致同意属性，所有节点决定以相同的顺序传递相同的消息](#d2l2-1713118985178)

<a name="utxu-1726766100364"></a>[完整性属性，消息不会重复](#z7u4-1713118985179)

<a name="snff-1726766100366"></a>[有效性属性，消息不会被破坏，也不能凭空编造](#pphb-1713118985180)

<a name="5eiw-1726766100368"></a>[终止属性,消息不会丢失](#gqmq-1713118985181)

<a name="dcw7-1726766100370"></a>[视图戳复制，raft和zab直接实现了全序广播，比重复一次一致one value a time的共识更高效， paxos 下这种优化称为multi-paxos.](#lxll-1713118985182)

<a name="ppej-1726766100372"></a>[单领导者复制和共识](#krsz-1713118985183)

<a name="ehik-1726766100374"></a>[时代编号和法定人数](#90tt-1713118985184)

<a name="n7nk-1726766100376"></a>[共识的局限性](#qywj-1713118985185)

<a name="lxav-1726766100378"></a>[成员与协调服务](#8qzt-1713118985186)

<a name="trqw-1726766100380"></a>[将工作分配给节点](#4tlb-1713118985187)

<a name="2b9h-1726766100382"></a>[服务发现](#tbbj-1713118985188)

<a name="thkp-1726766100384"></a>[成员服务](#1lld-1713118985189)

<a name="qva3-1726766100386"></a>[第三部分：衍生数据](#46k8-1705118453932)

<a name="2pnd-1726766100388"></a>[记录和衍生数据系统](#rboc-1716226529015)

<a name="hko8-1726766100390"></a>[从高层次看，存储和处理数据的系统可以分为两大类](#cmdh-1716226737947)

<a name="pz5g-1726766100392"></a>[记录系统System of record](#1dmv-1716226552894)

<a name="go7c-1726766100394"></a>[真相源source of truth. 记录用户输入新数据，标准化normalized](#dh96-1716226777418)

<a name="qxi9-1726766100396"></a>[衍生数据系统Derived data system](#qjlf-1716226568395)

<a name="1nxc-1726766100398"></a>[缓存cache, 衍生数据是冗余的，重复了已有的信息。](#igtl-1716226871151)

<a name="kynp-1726766100400"></a>[10.批处理](#0bgb-1716226496297)

<a name="yskl-1726766100402"></a>[服务（在线系统）：高可用性，性能指标-响应时间](#yygb-1720542683707)

<a name="palc-1726766100404"></a>[批处理系统（离线系统）：定时任务job，性能指标-吞吐量](#goo7-1720542700859)

<a name="7loq-1726766100406"></a>[流处理系统（准实时系统）：介于在线离线系统之间](#mv2a-1720542952432)

<a name="5hwu-1726766100408"></a>[使用Unix工具的批处理](#6lu4-1716228538928)

<a name="ehzw-1726766100410"></a>[分析简单日志](#hyii-1716228597300)

<a name="gvjv-1726766100412"></a>[Unix命令链：网站上找到五个最受欢迎的网页（nginx/access.log）](#smoq-1720543218731)

<a name="coln-1726766100414"></a>[命令链与自定义程序Ruby](#ukyi-1716228816049)

<a name="qduu-1726766100416"></a>[排序 VS 内存中的聚合](#cnuw-1716228829632)

<a name="tl4d-1726766100418"></a>[工作集working set(作业需要随机访问的内存大小)，单个url 重复出现百万次，哈希表性能好](#siiu-1720543940755)

<a name="hxs1-1726766100420"></a>[工作集大于内存，排序优，与SSTables 和 LSM树一样，内存聚合归并排序，GNU 中的sort通过溢出至磁盘自动应该大于内存大额数据集，瓶颈可能是磁盘io。-MQ的死信处理也是溢出到磁盘。](#lms0-1720544023798)

<a name="4bk7-1726766100422"></a>[Unix哲学](#mgei-1716228613042)

<a name="05uu-1726766100424"></a>[统一的接口](#sk3b-1716228852580)

<a name="yfua-1726766100426"></a>[Unix中统一的接口是一个文件file](#33ju-1720874904091)

<a name="nfvu-1726766100428"></a>[ASCII文本，\n 分隔，](#yogq-1720875513301)

<a name="9w5u-1726766100430"></a>[CSV， ，号分隔](#7fvb-1720875542091)

<a name="4hux-1726766100432"></a>[逻辑与布线相分离](#3oxq-1716228869387)

<a name="gmc7-1726766100434"></a>[松耦合loose coupling](#0zy9-1720876020643)

<a name="t7at-1726766100436"></a>[晚期绑定late binding](#226j-1720876035472)

<a name="juqi-1726766100438"></a>[控制反转inversion of control](#zedb-1720876065554)

<a name="wrx4-1726766100440"></a>[透明度与实验](#ftj8-1716228879278)

<a name="hpra-1726766100442"></a>[MapReduce和分布式文件系统](#djdy-1716228554334)

<a name="jdkm-1726766100444"></a>[MapReduce像是分布在数前台机器上的Unix。](#illh-1720876369554)

<a name="v3ch-1726766100446"></a>[Hadoop的Map-Reduce视线中，文件系统成为HDFS,基于google文件系统GFS的开源实现。](#e1cy-1720876447842)

<a name="n1ec-1726766100448"></a>[Amazon S3，  Azure blob ](#mapk-1720876955975)

<a name="upa2-1726766100450"></a>[MapReduce作业执行](#kdge-1716228625984)

<a name="lpfr-1726766100452"></a>[Mapper在每条输入记录上调用一次,从输入记录中提取键值（提取键值）](#vleh-1720877349422)

<a name="hi4g-1726766100454"></a>[Reduce拉取Mapper生成的键值对，收集属于同一个键的所有值。（收集同键的所有值）](#aol7-1720877397533)

<a name="qatt-1726766100456"></a>[分布式执行MapReduce](#kv6u-1716231603620)

<a name="4y97-1726766100458"></a>[即在不同服务器上执行mapper reduce 的task。](#wy7r-1720877483243)

<a name="zhcp-1726766100460"></a>[MapReduce工作流](#d0qe-1716231619319)

<a name="wzzy-1726766100462"></a>[workflow。一系列命令，输出写入临时文件，下一个命令从临时文件中读取-物化中间状态](#rvme-1720877910897)

<a name="y1ng-1726766100464"></a>[Reduce端连接与分组](#pyoc-1716228643855)

<a name="y8fh-1726766100466"></a>[用户活动事件](#1pza-1716231634942)

<a name="hk6h-1726766100468"></a>[左侧是事件日志/活动事件activity events/点击流事件clickstream evnets](#4l72-1720878002631)

<a name="85xw-1726766100470"></a>[右侧是用户数据库](#hivt-1720878131008)

<a name="qhdd-1726766100472"></a>[用户行为日志与用户档案的连接](#cvii-1720878237531)

<a name="z6pb-1726766100474"></a>[原始:逐个遍历活动事件关联查询。缺点：吞吐量受限数据库服务器且容易压垮](#eiqe-1720878248508)

<a name="dm8l-1726766100476"></a>[改良：获取用户数据库副本（ETL进程从数据库备份中提取数据，参考数仓），放在同一个分布式文件系统中。将用户数据库存储HDFS中的一组文件中，用户活动记录存储另一组文件中，](#iueg-1720878322010)

<a name="4svv-1726766100478"></a>[并能用MapReduce将左右相关记录集中到同一个地方进行高效处理。](#ruua-1720878498786)

<a name="ytyz-1726766100480"></a>[排序合并连接](#fihy-1716231663765)

<a name="ixxe-1726766100482"></a>[1.map提取键值(userid-url  usrid-do)和reduce(userid all url do)](#q51q-1720947527716)

<a name="tq5s-1726766100484"></a>[2.二次排序secondary sort ：对1的合并按时间戳排序](#4kvv-1720947648039)

<a name="jmn2-1726766100486"></a>[排序合并连接sort-merge join: reduce一次处理一个特定用户所有记录，只需将一条用户记录保存在内存中，无需发送网络请求](#j8br-1720947805879)

<a name="dgag-1726766100488"></a>[把相关数据放在一起](#8vrk-1716231670998)

<a name="jr7g-1726766100490"></a>[Mapper和排序过程确保特定用户id连接操作的必须数据都放在同一个地方](#t1tc-1720947947656)

<a name="qdbh-1726766100492"></a>[GROUP BY](#9j4s-1716228658160)

<a name="3aif-1726766100494"></a>[除了连接之外，“把相关数据放在一起”的常见模式是记录分组。SQL中的Group By](#a6wg-1720952083180)

<a name="lsvt-1726766100496"></a>[处理倾斜](#qa24-1716231688547)

<a name="xu7x-1726766100498"></a>[名流热点数据hot spot](#f55j-1720952155251)

<a name="f9na-1726766100500"></a>[参考负载倾斜和消除热点](#julg-1720952222343)

<a name="t4xp-1726766100502"></a>[Mapper将热键的关联记录随机发送到几个Reduce之一](#akfb-1720952286891)

<a name="k32m-1726766100504"></a>[Map端连接](#2tox-1716228671225)

<a name="jtzq-1726766100506"></a>[预处理输入数据](#qiil-1720971178915)

<a name="g7ze-1726766100508"></a>[广播散列连接](#wjhj-1716231713037)

<a name="l9jk-1726766100510"></a>[broadcast hash join](#k3se-1720971260954)

<a name="ahax-1726766100512"></a>[分区散列连接](#su27-1716231723170)

<a name="z5cr-1726766100514"></a>[Map桶端连接bucketd map jons](#5h9a-1720971514797)

<a name="dkxw-1726766100516"></a>[Map端合并连接](#ftdq-1716231736611)

<a name="kbzj-1726766100518"></a>[MapReduce工作流与Map端连接](#yrmc-1716231744413)

<a name="vnho-1726766100520"></a>[批处理工作流的输入](#zzir-1716228678980)

<a name="jzre-1726766100522"></a>[OLTP ：查找少量记录，使用索引，呈现给用户](#hiqn-1720971586510)

<a name="q6zw-1726766100524"></a>[OLAP：扫描大量记录，执行分组与聚合，输出有着报告的形式，商业决策的分析。](#cqba-1720971612883)

<a name="8tmg-1726766100526"></a>[建立搜索索引](#bwjf-1716231761454)

<a name="cdmh-1726766100528"></a>[MapReduce最初作为google搜索引擎的索引](#lypn-1720971694941)

<a name="e9io-1726766100530"></a>[全文搜索和模糊索引  Lucene](#iijq-1720971776882)

<a name="c394-1726766100532"></a>[分区和二级索引](#vcun-1720971828838)

<a name="skcu-1726766100534"></a>[键值存储作为批处理输入](#8fix-1716231782091)

<a name="4rry-1726766100536"></a>[批处理输入的哲学](#audd-1716231802005)

<a name="dcy0-1726766100538"></a>[视为不可变且避免副作用：](#6i34-1720972317458)

<a name="re6r-1726766100540"></a>[人类容错human fault tolerance](#zciu-1720972319614)

<a name="tbgg-1726766100542"></a>[最小化不可逆性mininizing irreversibility](#oolm-1720972319615)

<a name="kgkc-1726766100544"></a>[Hadoop与分布式数据库的对比](#lp33-1716228684462)

<a name="wy4p-1726766100546"></a>[Hadoop 像Unix的分布式版本，HDFS是它的文件系统，而MapReduce是Unix进程的怪异实现](#g0vj-1720972341966)

<a name="cp4u-1726766100548"></a>[MapReduce论文发表前，并行连接算法已在数据库实现-大规模并行处理MPP massively parallel processing ](#gjbt-1720972427948)

<a name="ay6k-1726766100550"></a>[Gamma database machine, Teradata, Tandem NonStop SQL](#go7m-1720972523351)

<a name="4rlq-1726766100552"></a>[区别：MMP专注一组及骑行并行执行分析SQL 查询](#5mnr-1720972551600)

<a name="xhq9-1726766100554"></a>[MapReduce和分布式文件系统的组合是一个可以运行任意程序的通用操作系统](#gx7b-1720972580058)

<a name="vhf5-1726766100556"></a>[存储多样性](#eebl-1716231817367)

<a name="ppqt-1726766100558"></a>[数据湖data lake / 企业数据中心enterprise data hub](#5lga-1720972673599)

<a name="jzuq-1726766100560"></a>[Hadoop 常用于实现数仓ETL Extract, Transform, Load](#jrhw-1720972777529)

<a name="bior-1726766100562"></a>[处理模型多样](#ysfv-1716231826972)

<a name="7ha2-1726766100564"></a>[针对频繁故障设计](#kwz4-1716231831752)

<a name="rbwk-1726766100566"></a>[MapReduce之后](#p0zx-1716228568687)

<a name="zw3e-1726766100568"></a>[建立在MapReduce上的高级编程模型](#wcyn-1721117329960)

<a name="tw6x-1726766100570"></a>[Pig，Hive, Cascading, Crunch](#l9ug-1721117359714)

<a name="vjvw-1726766100572"></a>[流处理：加速批处理的另一种方法](#bz2s-1721117576614)

<a name="1xvg-1726766100574"></a>[物化中间状态](#fvak-1716228706372)

<a name="46xu-1726766100576"></a>[中间状态intermediate state](#npb7-1721117756510)

<a name="ktpr-1726766100578"></a>[物化materialization:中间态写入文件的过程](#0rlu-1721117876651)

<a name="mp3g-1726766100580"></a>[MapReduce完全物化中间态的方法不足：](#fnqf-1721117967688)

<a name="cw5y-1726766100582"></a>[只有在前驱作业生成其输入完成时才能启动](#pood-1721117984973)

<a name="lfkm-1726766100584"></a>[mapper通常是多余的：仅仅读取由Reducer写入的同样文件](#iljf-1721118032959)

<a name="tnk5-1726766100586"></a>[临时文件（数据）被复制到多个节点](#tghz-1721118071785)

<a name="fwa9-1726766100588"></a>[解决：数据流引擎](#aer2-1721118148615)

<a name="17vb-1726766100590"></a>[数据流引擎](#sdac-1716231877023)

<a name="lavs-1726766100592"></a>[分布式批处理新引擎：](#4gu5-1721118111495)

<a name="juwm-1726766100594"></a>[spark,  Flink: 独立的网络通信层，调度器，用户向API](#nfnv-1721118162692)

<a name="vzfu-1726766100596"></a>[Tez : 薄库，依赖YARN shuffle服务实现节点间的数据复制](#0kbz-1721123564974)

<a name="4wjk-1726766100598"></a>[dataflow engines模型:](#jojo-1721118227522)

<a name="o9bp-1726766100600"></a>[函数/算子operators: 一个算子的输出连接到另一个算子的输入](#kstp-1721118246090)

<a name="gzox-1726766100602"></a>[优点：](#zbrh-1721118327524)

<a name="cgtn-1726766100604"></a>[排序等昂贵工作只需在实际需要地方执行，不是默认在Map和Reduce阶段间](#8oqo-1721118330975)

<a name="sbk9-1726766100606"></a>[没有不必要的Map任务](#amzf-1721118375240)

<a name="sks3-1726766100608"></a>[连接和数据依赖都是显示声明的](#bunw-1721118382779)

<a name="qdkb-1726766100610"></a>[算子中间态足以保存内存或写入本地磁盘，比HDFS需要更少I/O](#bzui-1721122836028)

<a name="nnzm-1726766100612"></a>[算子可在输入就绪后立即执行，不许等待前驱完成](#ka7f-1721123164712)

<a name="mn1b-1726766100614"></a>[MapReduce为每个任务启动新JVM, 而df enginer可重用现有JVM，减少启动开销](#rmr3-1721123191298)

<a name="v9l8-1726766100616"></a>[执行速度更快](#mp4i-1721123431562)

<a name="5mv8-1726766100618"></a>[使用：](#2cxo-1721123304059)

<a name="zmjf-1726766100620"></a>[算子是Map和Reduce的泛化/抽象，相同处理代码可在任意引擎上运行](#vyfa-1721123442398)

<a name="mwwd-1726766100622"></a>[Pig Hive Casacding中实现的工作流无需修改代码，修改配置，从MapReduce切换到Tez 或spark.](#qxck-1721123483308)

<a name="o7jl-1726766100624"></a>[容错](#glfr-1716231882229)

<a name="lq4n-1726766100626"></a>[重启，算子重新计算](#neqa-1721499456929)

<a name="hayx-1726766100629"></a>[关于物化的讨论](#npsg-1716231884238)

<a name="82zo-1726766100631"></a>[图与迭代处理](#dvkh-1716228727874)

<a name="bash-1726766100633"></a>[图数据模型常用于机器学习应用](#y476-1721499725472)

<a name="dksx-1726766100635"></a>[图形算法PageRank:根据连接到某个网页的其他网页来估计该网页的流行度](#ld62-1721499760165)

<a name="miog-1726766100637"></a>[闭包传递transitive clousure: 重复跟进标明地点归属关系的边，生成数据库中北美地点列表](#et5r-1721499798288)

<a name="toor-1726766100639"></a>[MapReduce低效：没考虑算法迭代性](#x4m1-1721499995671)

<a name="y5ot-1726766100641"></a>[Pregel处理模型](#lf5y-1716231892007)

<a name="ha6y-1726766100643"></a>[图批处理的优化：批量同步并行（BSP）计算模型。](#1faf-1721499959178)

<a name="6raa-1726766100645"></a>[Pregel模型：Google的Pregel论文推广了处理图的方法。Apache Giraph , Spark GraphX API 和 Flink Gelly API](#3mh8-1721500149918)

<a name="agag-1726766100647"></a>[容错](#pxnd-1716231909468)

<a name="jufk-1726766100649"></a>[并行执行](#v8gr-1716231912877)

<a name="vjqf-1726766100651"></a>[高级API和语言](#cxqk-1716228736349)

<a name="7oe2-1726766100653"></a>[Hive,pig, Cascading,Crunch等高级语言和API, Tez](#qlnr-1721841646688)

<a name="incu-1726766100655"></a>[向声明式查询语言的转变](#dfa6-1716231923208)

<a name="xyxa-1726766100657"></a>[声明式declarative](#zman-1721841903902)

<a name="cbs5-1726766100659"></a>[与SQL的完全声明式查询有很大的区别：](#inea-1721841971310)

<a name="5evw-1726766100661"></a>[围绕回调函数的概念建立，自由调用任意代码来决定输出什么。](#ahki-1721842021736)

<a name="lun7-1726766100663"></a>[可基于大量已有库的生态系统创作： 解析、自然语言分析，图像分析以及运算数值算法或统计算法等。](#bdyf-1721842047384)

<a name="qt5h-1726766100665"></a>[专业化的不同领域](#m2pu-1716231937991)

<a name="olny-1726766100667"></a>[空间算法：最近邻搜索K-nearest neghbors](#wpot-1721842227412)

<a name="svek-1726766100669"></a>[11.流处理](#iwmv-1721931597264)

<a name="pa5a-1726766100671"></a>[流处理Stream processing: 当事件发生时就可以立即处理](#yeid-1722103475505)

<a name="wayu-1726766100673"></a>[传递事件流](#08iq-1721844360659)

<a name="a4yh-1726766100675"></a>[事件event：流处理的上下文件记录](#n0th-1722103658739)

<a name="3rnu-1726766100677"></a>[生产者producer/发布者publisher/发送者sender](#titb-1722103707652)

<a name="isls-1726766100679"></a>[消费者consumer/订阅者subscribers/接收者recipients](#yhbb-1722103745716)

<a name="9zlu-1726766100681"></a>[主题topic/流stream：相关事件的聚合](#jdqp-1722103794393)

<a name="bisz-1726766100683"></a>[通知机制：数据库触发器trigger(算是弥补机制)、消息传递系统messaging system](#2buw-1722103875913)

<a name="rtm7-1726766100685"></a>[消息系统](#ipga-1721932434160)

<a name="w1sp-1726766100687"></a>[两个关键问题：](#qm3o-1722104029796)

<a name="ktju-1726766100689"></a>[1.生产者快于消费者：丢掉消息/将消息放入缓冲队列/背压backpressure(流量控制flow control) 阻塞生产者，以免其发送更多消息](#sztq-1722104046748)

<a name="yjs1-1726766100691"></a>[2.节点崩溃或脱机，是否有消息丢失： 持久性，高吞吐和低延迟则接收丢失](#5ycq-1722104289674)

<a name="9htt-1726766100693"></a>[直接从生产者传递给消费者](#cj2t-1721932544748)

<a name="sho3-1726766100695"></a>[直接网络通信，而不通过中间节点：](#hjhp-1722104612024)

<a name="kmoe-1726766100697"></a>[UPD组播，金融行业，低延时，不可靠，应用层协议可恢复丢失的包（生产者必须记住发送的包，按需重新发送）](#0ggy-1722104631748)

<a name="6sk6-1726766100699"></a>[无代理的消息库，ZeroMQ、nanomsg, TCP或IP多播](#hnj8-1722104735615)

<a name="ugkr-1726766100701"></a>[StatsD 和 Brubeck 使用UDP](#pcd7-1722104800545)

<a name="d9dh-1726766100703"></a>[消费者在网络上公开了服务，生产者可以直接发送HTTP和RPC请求将消息推送给使用者webhooks.](#3se2-1722104863261)

<a name="zfh4-1726766100705"></a>[消息代理](#jwkh-1721932555905)

<a name="xjby-1726766100707"></a>[消息代理message broker(也称为消息队列message queue)](#dtlb-1722106424439)

<a name="mi0a-1726766100709"></a>[消息代理与数据库对比](#fyus-1721932559957)

<a name="ouhr-1726766100711"></a>[.数据存储：数据库保留数据直至显示删除；大多数消息代理在消息成功传递给消费者时地总删除](#aj3x-1722106519844)

<a name="vjez-1726766100713"></a>[.删除消息快，所以队列可以很短。如过缓冲很多消息可能会溢出到磁盘，吞吐量会下降](#pkoh-1722106591225)

<a name="apaw-1726766100715"></a>[.匹配方式：数据库通常支持二级索引和各种搜索数据的方式；消息代理按照模式匹配订阅子集](#lfst-1722106688956)

<a name="rz5n-1726766100717"></a>[.最新数据：数据库通常支持事务，基于某个时间点数据快照；消息代理不支持任意查询，有新消息会通知客户端](#q13l-1722106755764)

<a name="tqk3-1726766100719"></a>[多个消费者](#v0lh-1721932568637)

<a name="5yzv-1726766100721"></a>[负载均衡load balance: 多个客户端从同一个队列中消费。JMS中称为共享订阅shared subscripiton](#enlv-1722191268259)

<a name="oh5x-1726766100723"></a>[扇出fan-out:将每条消息传递给多个消费者](#bjqd-1722191397355)

<a name="ymhs-1726766100725"></a>[确认与重新交付](#aoas-1721932573289)

<a name="xbfg-1726766100727"></a>[消息代理使用确认acknowlegements:客户端需显示告知代理消息处理完毕的时间，代理将消息从队列中移除。](#8lsc-1723155930519)

<a name="lokv-1726766100729"></a>[确认丢失：需一种原子提交协议才能处理，如分布式事务。](#w6ac-1723156157534)

<a name="yezj-1726766100731"></a>[负载均衡与重传的组合不可避免导致消息顺序(JMS，AMQP标准要求保留消息的顺序。)重新排序](#zlnz-1723156224601)

<a name="ysxo-1726766100733"></a>[解决：每个消费者使用单独的队列-即不适用负载均衡功能](#fovj-1725028626326)

<a name="up2w-1726766100735"></a>[消息完全独立，消息重排序并不是个问题，消息之间存在因果依赖关系则是个重要问题](#3kzh-1725028667923)

<a name="ypcb-1726766100737"></a>[分区日志](#9bmj-1721932438668)

<a name="trdx-1726766100739"></a>[消息传递/不留痕迹：网络数据包 和 消息代理 (可抓包和日志持久)](#xree-1725028818863)

<a name="4ufc-1726766100741"></a>[持久化：数据库和文件系统，显式删除前将永久记录](#sbbo-1725028858585)

<a name="akru-1726766100743"></a>[消息代理log-base message brokers: 既有数据库的持久化，又有消息传递的低延迟通知。](#n6lq-1725028981222)

<a name="kuho-1726766100745"></a>[使用日志进行消息存储](#keft-1721932590686)

<a name="cg6u-1726766100747"></a>[生产者通过将消息追加到日志末尾来发送消息，消费者通过以此读取日志来接收消息。](#tlnm-1725029031868)

<a name="fvim-1726766100749"></a>[Unix tail -f 监视文件被追加写入的数据就是这样工作的。](#1606-1725029123561)

<a name="tllu-1726766100751"></a>[Apache Kafka, Amazon Kinesis Streams , Twitter DistributedLog都是基于日志的消息代理](#aq8x-1725029525384)

<a name="se71-1726766100753"></a>[Google Cloud Pub/Sub在架构上类似，单对外暴露的是JMS风格的API，而不是日志抽象](#0wz5-1725029598472)

<a name="cf9v-1726766100755"></a>[尽管写入磁盘，但通过跨多台机器分区，每秒能实现数百万消息的吞吐量，并通过复制来实现容错性。](#zqkl-1725029648581)

<a name="mzoc-1726766100757"></a>[日志与传统消息相比](#pr6y-1721932607757)

<a name="ajvx-1726766100759"></a>[天然支持扇出式消息传递：过个消费者独立读取日志，而不相互影响](#i3q5-1725115574888)

<a name="qgzx-1726766100761"></a>[负载平衡：读取消息不会从日志中删除，代理可以将整个分区分配给消费者组中的节点，而不是单挑消息分配给客户端。](#ymqj-1725115609372)

<a name="7a1w-1726766100763"></a>[消费者偏移量](#o0ft-1721932621047)

<a name="njvv-1726766100765"></a>[和单领导者数据库复制中常见的日志序列号非常相似，代理无需跟踪每条消息，只需定期记录消费者偏移即可。有助于提高基于日志的系统吞吐量](#emow-1725115793168)

<a name="n0gh-1726766100767"></a>[问题：消费者节点失效而没有记录偏移量，重启后这些消息将被处理两次。本章后续讨论。](#gmal-1725115911246)

<a name="4zpa-1726766100769"></a>[磁盘空间使用](#ipmx-1721932629330)

<a name="byk5-1726766100771"></a>[只追加写入日志，回收时将旧段删除或移动到归档存储](#5ep6-1725115987947)

<a name="phgl-1726766100773"></a>[问题，消费者跟不上生产者，指向删除段，错过一些消息。](#kjgm-1725116313754)

<a name="v9pz-1726766100775"></a>[日志实现一个有限大小的缓冲区：循环缓冲区circular buffer/环形缓冲区，填满时将丢弃旧消息](#k3hi-1725116359622)

<a name="sosl-1726766100777"></a>[设 大型硬盘容量为 6TB, 顺序写入为150MB/s， 最快需要约11小时填满磁盘，之后开始覆盖旧消息。实践中的部署很少能用满磁盘的写入带宽。所以通常可保留一个几天甚至几周的日志缓冲区](#jjma-1725116440115)

<a name="xkb5-1726766100779"></a>[以上保留多长时间的消息，日志吞吐量或多或少保持不变，因为每个消息都写入磁盘。](#bdoa-1725116521841)

<a name="i5eu-1726766100781"></a>[   而默认将消息保存在内存中，当队列很短，系统很快；当系统开始写入磁盘，就慢得多，所以吞吐量取决于保留的历史数量。](#rxx7-1725116637183)

<a name="bjwh-1726766100783"></a>[当消费者更不上生产者时](#91b6-1721932634947)

<a name="lpc8-1726766100785"></a>[重播旧信息](#6tnb-1721932645175)

<a name="y9pq-1726766100787"></a>[流与数据库](#rnwj-1721932350699)

<a name="nfco-1726766100789"></a>[保持系统同步](#ehyq-1721932450135)

<a name="c8kv-1726766100791"></a>[变更数据捕获](#1ako-1721932460819)

<a name="fcdi-1726766100793"></a>[变更数据捕获的实现](#xkpl-1721932670593)

<a name="d4df-1726766100795"></a>[初始快照](#uxpn-1721932683846)

<a name="gitp-1726766100797"></a>[日志压缩](#j0w6-1721932690312)

<a name="8v09-1726766100799"></a>[变更流的API支持](#5pqr-1721932694290)

<a name="ymyk-1726766100801"></a>[事件溯源](#qkmx-1721932472062)

<a name="ycjm-1726766100803"></a>[从时间日志中派生出当前状态](#vydq-1721932714045)

<a name="yqla-1726766100805"></a>[命令和事件](#xbwr-1721932732154)

<a name="jbcy-1726766100807"></a>[状态，流和不变形](#k3v8-1721932742549)

<a name="67rr-1726766100809"></a>[从同一事件日志中派生多个视图](#diql-1721932751200)

<a name="npfq-1726766100811"></a>[并发控制](#tzcl-1721932772042)

<a name="dsk4-1726766100813"></a>[不变性的限制](#urmz-1721932775107)

<a name="hkf6-1726766100815"></a>[流处理](#nbcs-1721932419014)

<a name="hdto-1726766100817"></a>[流处理的应用](#jf4x-1721932507881)

<a name="tffi-1726766100819"></a>[复合时间处理](#80rp-1721932792357)

<a name="bj5s-1726766100821"></a>[流分析](#6jjt-1721932799443)

<a name="wkrn-1726766100823"></a>[维护物化视图](#5iog-1721932801692)

<a name="egwr-1726766100825"></a>[在流上搜索](#0asi-1721932807278)

<a name="b4og-1726766100827"></a>[消息传递和RPC](#10bm-1721932817553)

<a name="kzms-1726766100829"></a>[时间推理](#oca5-1721932519502)

<a name="l8yu-1726766100831"></a>[事件时间和处理时间](#is6l-1721932844579)

<a name="gx8k-1726766100833"></a>[知道什么时候准备好](#aue5-1721932851975)

<a name="bbyx-1726766100835"></a>[你用的是谁的时钟](#vsi1-1721932859473)

<a name="tbr1-1726766100837"></a>[窗口的类型](#gryf-1721932868260)

<a name="0vyt-1726766100839"></a>[流式连接](#jbet-1721932523864)

<a name="rms6-1726766100841"></a>[流流连接(窗口连接)](#eaux-1721932880085)

<a name="k5c5-1726766100843"></a>[流表连接(流扩展)](#hixz-1721932915139)

<a name="dil7-1726766100845"></a>[表表连接(维护物化视图)](#zbsv-1721932945841)

<a name="fegr-1726766100847"></a>[连接的时间依赖性](#xqtb-1721932962310)

<a name="wmqc-1726766100849"></a>[容错](#v1om-1721932530009)

<a name="nzop-1726766100851"></a>[微批量与存档点](#pqfe-1721932996846)

<a name="c5lm-1726766100853"></a>[原子提交再现](#elio-1721933013244)

<a name="1phk-1726766100855"></a>[幂等性](#bwyd-1721933023622)

<a name="tjjn-1726766100857"></a>[失败后重建状态](#dijm-1721933026909)



<a name="jeyl-1677787446995"></a>**一.数据库设计**

<a name="5hya-1677787446996"></a>**1. 关系型数据库**

<a name="ohc5-1621692571287"></a>**.E-R图，由台湾工程师提出的设计概念**

<a name="4z7m-1645598900270"></a>权益系统数据库设计复盘：雄爷并行看需求文档一两天设计DB。

<a name="5ocb-1645598528868"></a>**.流程图-业务逻辑相关，系统用户动作。抽象出E-R图**

<a name="gzqe-1677787446997"></a>**1.1 E-R图** 

<a name="r1ac-1621692724628"></a>**1.根据名词抽象出实体**

<a name="d2fl-1621692745600"></a>**2.名词找属性**

<a name="dwkp-1621692752824"></a>**3.实体间联系**

<a name="cyqi-1699843717785"></a>（单条记录对应关系 A表一条记录对应B表多条记录，B表一条记录对应A表多条记录即 m对）

<a name="53bo-1621692829033"></a>**.状态图**

<a name="c2cy-1677787446998"></a>**1.2 转化成数据库设计（公式）**

<a name="xmox-1621692858500"></a>**.1 对1 关系 往记录少的乙方加主键**

<a name="mdr8-1621692924289"></a>**.1对n 关系 ，往 n 实体加关联主键** 

<a name="hd3i-1621692960576"></a>**. n对 m 关系，需要一个关联表作映射关联**

<a name="p0tb-1655431896857"></a><a name="i6pd-1655431897042"></a>最好不要自己设计自己的表，关乎字段名统一（属性思想上的统一），以及字段冗余，字段依赖问题。

<a name="kneq-1715100176411"></a><a name="szqu-1715100194538"></a>**2.数据类型选择**

<a name="she1-1715100176604"></a>选择合适的数据类型对于数据库设计和性能至关重要。

<a name="0rub-1715100184335"></a>**整数类型（Integer Types）**

<a name="ww2f-1715100184339"></a>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT：分别用于存储不同范围的整数值。

<a name="xz9x-1715100184341"></a>建议根据数据范围选择合适的整数类型，以节省存储空间和提高性能。例如，如果数据范围在 -128 到 127 之间，可以选择 TINYINT 类型。

<a name="j4ut-1715100184343"></a>**浮点数类型（Floating-Point Types）**

<a name="ribt-1715100184347"></a>FLOAT、DOUBLE、DECIMAL：用于存储浮点数值。

<a name="fayg-1715100184349"></a>建议根据精度和范围选择合适的浮点数类型。FLOAT 适用于单精度浮点数，DOUBLE 适用于双精度浮点数，DECIMAL 适用于需要精确计算的场景。

<a name="muci-1715100184351"></a>**字符串类型（String Types）**

<a name="w0kv-1715100184355"></a>CHAR、VARCHAR、TEXT、BLOB：用于存储字符串数据。

<a name="yxnd-1715100184357"></a>建议根据存储的数据长度和使用场景选择合适的字符串类型。CHAR 适用于固定长度字符串，VARCHAR 适用于可变长度字符串，TEXT 适用于存储较大文本数据，BLOB 适用于存储二进制数据。

<a name="fjm4-1715100184359"></a>**日期和时间类型（Date and Time Types）**

<a name="hxzu-1715100184363"></a>DATE、TIME、DATETIME、TIMESTAMP：用于存储日期和时间数据。

<a name="phcm-1715100184365"></a>建议根据需要存储的精度和范围选择合适的日期和时间类型。DATE 适用于仅存储日期，TIME 适用于仅存储时间，DATETIME 适用于存储日期和时间，TIMESTAMP 适用于存储时间戳，通常用于记录数据的创建和修改时间。

<a name="tofd-1715100184367"></a>**其他类型**

<a name="ozmi-1715100184371"></a>ENUM、SET：用于存储枚举值和集合值。

<a name="885s-1715100184373"></a>建议在需要枚举或固定集合值的情况下使用这些类型，以提高数据的完整性和可读性。

<a name="vjgq-1715100184375"></a>在选择数据类型时，除了考虑数据范围、精度和使用场景外，还应考虑存储空间、性能和数据完整性等因素。选择合适的数据类型可以**提高数据库的性能和可维护性，同时降低存储成本。**

<a name="6bqw-1715100177239"></a><a name="cdso-1677787447000"></a>**二.系统优化**

<a name="3qep-1642647362896"></a>**应用整体的优化**

<a name="knge-1642647371136"></a>**-cpu -> 纳秒级别**

<a name="ovup-1704437622969"></a>**1.多线程和并发编程**

<a name="ufpl-1704437634986"></a>**2.JNI** 

<a name="ixb5-1704437634987"></a>**3.JIT/AOT编译**

<a name="kr1f-1704437634988"></a>**4.算法优化**

1\.多线程和并发编程：多线程和并发重复利用多核CPU,利用线程池管理复用线程，避免创建和销毁线程昂贵开销。

2\.JNI: C本地代码调度CPU

3\.JIT/AOT编译：JVM 和 JIT 足够时间来优化热点代码 / 云原生native Graavm ahead of time(AOT)静态编译

<a name="pojo-1704436320217"></a>4.算法优化：优化关键算法和数据结构，确保CPU执行效率

<a name="1xur-1642647384168"></a>**-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)**

<a name="7hi9-1704437851514"></a>**1.JVM内存管理**

<a name="te7c-1704437851799"></a>**2.缓存**

<a name="bqty-1704437851800"></a>**3.消息中间件**

(空间换时间)

1\.JVM内存管理：设置合理的堆大小及垃圾回收策略。

2\.缓存：redis缓存，spring缓存，ORM缓存

<a name="pxxu-1704436648342"></a>3.消息中间件：异步写，提高并发写能力。-吞吐量

<a name="ziti-1642647439005"></a>**-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)**

<a name="zups-1704437900079"></a>**1.减少磁盘io**

<a name="u3ok-1704438035018"></a>**2.数据压缩**   

1\.减少io(磁盘读写): 异步io,sql索引,局部性原理加载相邻页数据 ,DB数据磁盘预读----数据存储一般在DB系统中

<a name="ayss-1704436737847"></a>2.数据压缩：对需要存储或传输的数据进行压缩，减少磁盘占用

<a name="irbp-1642647458856"></a>**-网络传输/系统交互 -> 秒级 (减少io，连接池化)** 

<a name="6qil-1704438276193"></a>**1.减少网络请求**   

<a name="p5dt-1704438283633"></a>**2.使用CDN**

<a name="zhp8-1704438283634"></a>**3.Sockets异步通信**                                      

1\.减少网络请求：减少io(系统交互/连接池连接数)：去除for循环sql 

`    `--池化思想，创建和销毁消耗大的资源创建一个资源池，维护一定数量的资源数，统一管理资源创建和销毁

2\.使用CDN: 对于静态资源，使用内容分发网络（CDN）来加速资源的加载。

<a name="85si-1704436765735"></a>3.Sockets异步通信：对于需要等待的网络通信，可以考虑使用异步方式。

<a name="3l0l-1704424353262"></a>**项目架构层面的优化**

<a name="8o8s-1704424396933"></a>**-多级缓存**

亿级流量-多级缓存

<a name="lm7b-1704438499917"></a>浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

<a name="trcg-1704438366333"></a>**-应用层**

<a name="68oa-1704438530062"></a>**.代码优化**

<a name="clmf-1704438530257"></a>**.数据库优化**

<a name="md03-1704438530259"></a>**.日志优化**

·代码优化:通过代码审查和性能分析工具来识别和优化慢速或低效的代码。

·数据库优化:对于数据库访问，使用索引、合理的查询语句，以及数据库连接池等来提高性能。

<a name="8o0m-1704438517387"></a>·日志优化:避免过度记录日志，尽量异步记录，或者使用日志级别进行动态调整。

<a name="ocux-1704438477879"></a>**-监控与调优**

<a name="vdq2-1704438556836"></a>**.性能监控：**

<a name="t29d-1704438557094"></a>**.分析和调优**

·性能监控:使用性能监控工具，例如Java Mission Control、VisualVM等，来实时监测应用程序的性能。

<a name="l3kg-1704437252457"></a>·分析和调优:根据监控结果，进行分析并进行调优，优化性能瓶颈。

<a name="ukjf-1704424419442"></a>**-分布式系统架构**

<a name="a0bx-1704438677201"></a> **.负载均衡**

<a name="xn9x-1704438687994"></a>**.分布式缓存**

<a name="zcdp-1704438687996"></a>**.服务降级和容错**

浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

`                `CDN                  SLB负载均衡        分布式缓存          异步通信、MQ异步写/并发写、容错降级

·负载均衡:对于分布式系统，使用负载均衡来分配请求，以确保各个节点的负载均匀。

·分布式缓存:使用分布式缓存来减轻数据库负担，提高数据读取速度。

<a name="xpee-1704438657125"></a>·服务降级和容错:实现服务降级和容错机制，以应对网络或服务不稳定的情况。

<a name="six7-1642647372926"></a>**读写层面**

<a name="g4uv-1704732583614"></a>**.读优化**

<a name="uuzh-1704732602620"></a>**1.缓存**

<a name="qobc-1704732605892"></a>**2.索引**

<a name="zlg9-1704732609048"></a>**3.减少io/批量读/非阻塞io**

<a name="fpjd-1704732631316"></a>**4.减少多余数据加载/列式存储读**

<a name="oyob-1704732598377"></a>**.写优化**

<a name="6jmb-1704732509150"></a>**1.异步写**

<a name="tkwp-1704732723564"></a>**2.并发写**

<a name="hewz-1704732862030"></a>**3.批量写**

<a name="ccd8-1704732727854"></a>**4.优化算法和数据结构**

<a name="eqd9-1704732736281"></a>**5.缓存写**

<a name="hyq8-1704732768916"></a>**6.非阻塞io**

1\.批量操作:将多个写操作合并为批量操作，减少与数据库或其他外部存储的交互次数。例如，使用批量插入、批量更新或批量删除等操作，以减少单个写操作的开销。2.异步写入:使用异步写入的方式，将写操作放入队列或缓冲区中，由专门的线程异步处理。这样可以将写操作与主程序解耦，提高响应速度，并将写入操作批量化。

3\.数据库优化:对于关系型数据库，可以考虑优化数据库的配置和索引，以提高写入性

能。使用合适的数据库引擎和事务隔离级别，并优化查询和写入语句的性能。

4\.使用缓存:对于频繁的写入操作，可以使用缓存来减少对数据库的直接访问。将数据写入缓存，并通过批量或定期更新将数据同步到持久化存储。

5\.数据结构优化:选择合适的数据结构来存储数据，以提高写入性能。例如，使用哈希表、跳表等高效的数据结构来支持快速插入和更新操作。

6\.并发处理:使用多线程或分布式处理来并行处理写入操作，以提高写入性能。使用线程池或任务调度器来管理并发写入任务，并确保线程安全和数据─致性。

7\.使用非阻塞IO:对于高并发的写入操作，可以使用非阻塞IO技术，如NIO (New lO)或Netty等，以提高写入性能和吞吐量。

8\.数据分片:如果数据量较大，可以考虑将数据分片存储，将数据分散到多个存储节点上。这样可以将写入操作分散到多个节点上并行处理，以提高写入性能和扩展性。9.写缓冲:使用写缓冲区来缓存写入的数据，减少对物理存储设备的实时写入。通过批

<a name="z4ya-1704738513279"></a>量或异步的方式将缓冲区的数据定期写入存储设备，以提高写入性能。

<a name="tncv-1677787447001"></a>**1.分控系统优化复盘**

<a name="ydq7-1677787447002"></a>**1.1 数据库系统**

<a name="xsbg-1642647218571"></a>数据库的性能过低

<a name="eg0t-1642647223498"></a>提升硬件配置

<a name="wxdd-1677787447003"></a>**1.2 sql慢**

<a name="javd-1642647045138"></a>数据量大一千6百多万条数据

<a name="no1c-1642647140123"></a>删除冗余数据，每天采集13次，需求7天外数据只保留最新一批数据，修正删除的sql, 剩余数据，200w~600w左右。

<a name="ykot-1642649009232"></a>添加索引

<a name="olpb-1677787447004"></a>**1.3 接口慢**

<a name="blpq-1642649142995"></a>for循环遍历sql

<a name="s2zh-1642649153917"></a>去除for循环sql

<a name="yryq-1642649204976"></a> 频繁的采集种erverywhere log.info

<a name="afeg-1642649254648"></a>减少日志文件io，非必要信息改为debug。

<a name="fjt3-1643394063817"></a><a name="efqc-1643394063942"></a>优先考虑优化代价比较少的代码优化及sql优化，完成此类优化再考虑系统设计层面的优化，如：分库分表等（系统复杂度提升）。

<a name="navz-1652597408993"></a>一期历史数据重大bug修复方案设计问题（参看文档）： 注意像算法那样考虑极端情况（bug）处理，梳理方案的优缺点，对比不同方案实现优缺点接受度。

<a name="w6cm-1652597504660"></a>1.保证数据为最新的一批：

<a name="o4ka-1652597649729"></a>原方案. 每天13批次数据，不做事务回滚，取maxid ，>24小时数据删除---<24小时当天取消航班会在其中

<a name="ihuw-1652599412442"></a>配置难点：采集时段不同，每个账号采集不同天数; 采集的时间频率不同：

<a name="uarz-1652598784895"></a>熊爷方案：不改动原有逻辑，增加字段增加判段历史数据逻辑。

<a name="yxwj-1652599128439"></a>优点：基本不用改动一期代码和逻辑，改动sql增加判断历史条件。

<a name="rjdk-1652599326567"></a>缺点：新增判断的逻辑需要批次保证事务性，且配置难度很大，跨小时频率或者地区重叠，不可保证批次完整性，对比无效且配置和代码都得写死。

<a name="cehv-1652599093885"></a>我的方案：保证批次完整性，失败的批次直接整批删除，取最新一批。也是仅改动sql，获取最新一批批次代替 max(id)。

<a name="fm9n-1652599202701"></a>优点：只需要天数不重叠即可，配置相对灵活。

<a name="0ckh-1652599307805"></a>缺点：需要改sql逻辑，业务逻辑影响风险较大，需仔细验证。

<a name="nwww-1652597653246"></a> 

<a name="yjau-1644231171609"></a>分控系统重构设计

<a name="q9y5-1644231078993"></a>可靠性：写操作频繁，250k/h ~70次请求/s，将采集和后台分开两个应用。目前问题，采集两周左右系统资源耗尽会挂，可有多台服务器，实际上只用了两台。（集成应用监控，实现预警）

<a name="1ozg-1644231149674"></a>可拓展性：暂无,用户负载暂无数据

<a name="nbg9-1644231153386"></a>可维护性：代码质量，可读性。

<a name="wrwk-1642647280506"></a>**高并发系统设计**

<a name="8ien-1704757782146"></a>**1.满足大规模用户同时访问，提供良好响应时间和性能**

<a name="xy0g-1704757785190"></a>**2.设计之初就要考虑伸缩性和容错性是非常重要的**

<a name="wr12-1704947861599"></a>**.垂直伸缩** 

<a name="bizh-1704947959744"></a>**.水平伸缩**

·随着互联网的普及，用户访问量可能会在短时间内急剧增加。高并发系统设计可以确保系统在面对大规模用户同时访问时能够提供良好的响应时间和性能。

.高并发系统的设计是一个复杂而动态的过程，需要根据业务需求和系统特点不断优化。在设计之初就考虑到系统的可伸缩性和容错性是非常重要的。

` `垂直伸缩

`  `+配置32核CPU +124GB内存 +500G硬盘

优点；方案简单，易理解操作

缺点：容易达到机器物理上限，不具备高可用能力，单点故障高。

水平伸缩

<a name="4kjn-1704757525367"></a>多实例高可用，无需高性能服务器也可进行伸缩。

<a name="fvzi-1704756770858"></a>**1.分布式架构**

<a name="ywzr-1704756872033"></a>**.微服务架构**

<a name="xgna-1704756877646"></a>**.分布式计算**

·微服务架构:使用微服务拆分系统，将系统拆分成多个小而独立的服务，每个服务专注于特定的业务功能。

<a name="6khx-1704757167738"></a>·分布式计算:将任务分布到多个节点上，以充分利用计算资源。

<a name="wnfy-1704756775272"></a>**2.负载均衡**

<a name="h6nf-1704756891918"></a>**.负载均衡**

<a name="c8zr-1704756894402"></a>**.水平扩展**

·负载均衡器:使用负载均衡器分配请求到多个服务器，确保各个服务器的负载均衡。

<a name="o1d2-1704757209512"></a>·水平扩展:可以通过增加服务器数量来水平扩展系统，以支持更多的并发请求。

<a name="wxjk-1704756782840"></a>**3.数据库设计**

<a name="lxca-1704756910837"></a>**.读写分离**

<a name="p7d2-1704756922362"></a>**.数据库分片**

<a name="hxjt-1704756963988"></a>**.缓存**

·读写分离:使用读写分离来分担数据库的读写负载，提高数据库性能。

·数据库分片:将数据库分片，使数据分布在多个节点上，降低单—数据库的压力

<a name="yymm-1704757244191"></a>·缓存:使用缓存来减轻数据库负担，提高数据读取速度。

<a name="iivs-1704756788012"></a>**4.缓存优化**

<a name="cvui-1704756971791"></a>**.分布式缓存**

<a name="ysly-1704756979122"></a>**.本地缓存**

<a name="rqwj-1704756986363"></a>**.缓存预热**

·分布式缓存:使用分布式缓存，如Redis或Memcached，以提高数据的读取速度。

·本地缓存:在服务端使用本地缓存，减少对数据库或远程服务的请求次数。

<a name="vkcq-1704757254304"></a>·缓存预热:在系统启动时，预先加载一部分热门数据到缓存中，提高缓存命中率。

<a name="so9h-1704756800253"></a>**5.消息队列**

<a name="sxlo-1704756996000"></a>**.异步处理**

<a name="llm2-1704757002994"></a>**.削峰填谷**

·异步处理:使用消息队列进行异步处理，将一些非实时关键路径的任务放入队列中处理，减轻服务器负担。

<a name="99fz-1704757286906"></a>·削峰填谷:缓解系统压力，通过消息队列实现请求的削峰填谷，防止瞬时大量请求导致系统崩溃。

<a name="n39o-1704756805232"></a>**6.分布式事务**

<a name="5bhj-1704757017700"></a>**.两阶段提交**

<a name="becc-1704757028036"></a>**.补偿事务**

两阶段提交（2PC):在分布式环境中，确保事务的一致性，可以使用两阶段提交协议。

<a name="qset-1704757299753"></a>·补偿事务:使用补偿事务机制，处理在分布式环境中的异常情况。

<a name="wgkk-1704756813448"></a>**7.高可用和容错**

<a name="akwz-1704757035393"></a>**.多地域部署**

<a name="3nxv-1704757055271"></a>**.设计容错**

<a name="g3xx-1704757371028"></a>**1. 熔断限流**

<a name="jafy-1704757374368"></a>**2. 多节点服务**

·多地域部署:在不同地理位置部署系统，提高系统的可用性。

<a name="h6bn-1704757326243"></a>·容错设计:使用容错设计，确保系统在部分节点或服务失效时能够继续提供服务。

<a name="ilyo-1704756820772"></a>**8.监控和性能调优**

<a name="kpwq-1704757064566"></a>**.实时监控**

<a name="shf4-1704757066453"></a>**.性能测试**

·实时监控:使用监控系统实时监测系统性能，对系统进行及时调整。

<a name="lkos-1704757433031"></a>性能测试:定期进行性能测试，模拟高并发情况，找出系统的瓶颈并进行优化。

<a name="2pry-1704756830245"></a>**9.安全性设计**

<a name="pkiw-1704757078583"></a>**.防御性编程**

<a name="g4l1-1704757084924"></a>**.访问控制**

·防御性编程:编写安全的代码，防范SQL注入、XSS攻击等。

<a name="g9ef-1704757459182"></a>·访问控制:对系统的访问进行严格控制，避免未经授权的访问。

<a name="1tsd-1704756838192"></a>**10.水平扩展**

<a name="r1dd-1704757092061"></a>**.自动化部署**

<a name="7mhk-1704757104117"></a>**.云服务**

·自动化扩展:设计自动化扩展机制，根据系统负载自动增减节点。

<a name="g3qv-1704757477668"></a>·云服务:使用云服务提供商的弹性计算能力，根据需求调整计算资源。

<a name="rpxb-1677787447005"></a>**高并发性能指标**

<a name="klnv-1704761369323"></a>**QPS(每秒请求)**

<a name="zvlz-1704761369324"></a>**TPS(每秒事务)**

<a name="gvrn-1704761369325"></a>**RT(响应时间)**

我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。

公式：( 总PV数 \* 80% ) / ( 每天秒数 \* 20% ) = 峰值时间每秒请求数(QPS)

机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器

1、每天300w PV(网页浏览量) 的在单台机器上，这台机器需要多少QPS？ 

( 3000000 \* 0.8 ) / (86400 \* 0.2 ) = 139 (QPS)

2、如果一台机器的QPS是58，需要几台机器（cpu瓶颈）来支持？ ---得分析性能瓶颈，例如是CPU还是数据库。

<a name="02ut-1704761377369"></a>139 / 58 = 3 

<a name="nuln-1709310472128"></a><a name="ysmj-1709309531982"></a>**(原子操作)并发编程中保证数据一致性/安全的方法**

<a name="gawc-1709307342094"></a>在并发编程中，为了保证数据安全（**即避免数据竞争和并发访问导致的不确定行为**），可以采取以下一些措施：

<a name="kfs4-1709308475961"></a>总体来看，就是需要保证原子操作：**原子性+隔离性(锁串行化执行/cas)=一致性** ，用事务的思想可以简化并发问题。

<a name="nian-1709319335754"></a>保证 **原子性+串行化执行 。**

<a name="fdxy-1709308630108"></a>**原子性+悲观锁：各种锁机制**

<a name="v06l-1709312268021"></a>**.（锁+事务/ 分布式锁+分布式事务）**

<a name="k0op-1709312304164"></a>**.  CASmysql版本号实现 (前提是数据库的update已经是原子写：mysql update排它锁）**

<a name="qth5-1709308703202"></a>**原子性+乐观锁/不加锁: CAS原子操作(java原子类)，**

import redis.clients.jedis.Jedis;

public class RedisDistributedLock {

`    `private static final int LOCK\_EXPIRE\_TIME = 10000; // 锁的过期时间，单位毫秒

`    `private static final String LOCK\_KEY = "my\_lock"; // 锁的键名

`    `private static final String LOCK\_VALUE = "locked"; // 锁的值，用于标识锁的持有者

`    `private Jedis jedis;

`    `public RedisDistributedLock(Jedis jedis) {

`        `this.jedis = jedis;

`    `}

`    `public boolean acquireLock() {

`        `String result = jedis.set(LOCK\_KEY, LOCK\_VALUE, "NX", "PX", LOCK\_EXPIRE\_TIME);

`        `return "OK".equals(result);

`    `}

`    `public boolean releaseLock() {

`        `Long result = jedis.del(LOCK\_KEY);

`        `return result != null && result > 0;

`    `}

`    `public static void main(String[] args) {

`        `// 假设已经创建了一个连接Redis的Jedis实例

`        `Jedis jedis = new Jedis("localhost", 6379);

`        `// 创建一个RedisDistributedLock对象

`        `RedisDistributedLock lock = new RedisDistributedLock(jedis);

`        `// 获取锁

`        `boolean locked = lock.acquireLock();

`        `if (locked) {

`            `try {

`                `// 成功获取到锁后的业务逻辑

`                `System.out.println("Successfully acquired lock");

`            `} finally {

`                `// 释放锁

`                `lock.releaseLock();

`                `System.out.println("Lock released");

`            `}

`        `} else {

`            `// 获取锁失败时的处理逻辑

`            `System.out.println("Failed to acquire lock");

`        `}

`        `// 关闭Jedis连接

`        `jedis.close();

`    `}

<a name="gmx8-1709799551752"></a>}

<a name="g3uo-1709309147469"></a>**CAS底层实现原理**

<a name="vgcy-1709308841739"></a>在现代 CPU 中，CAS 操作的原子性是通过硬件级别的支持来实现的。CPU 提供了特殊的原子性指令（如 x86 架构中的 cmpxchg 指令），这些指令在执行过程中能够保证操作的原子性。

<a name="talv-1709308842019"></a>具体来说，CPU 在执行 CAS 操作时会采取以下措施来保证原子性：

<a name="qpbw-1709308842021"></a>**总线锁定（Bus Locking）：**

<a name="awe7-1709308842023"></a> 在执行 CAS 操作期间，CPU 会向总线发送一个锁定信号，阻止其他 CPU 访问相同的内存位置。这样可以确保在同一时间只有一个 CPU 能够成功执行 CAS 操作。

<a name="ikm2-1709308842025"></a>**缓存一致性协议（Cache Coherence Protocol）：**

<a name="fqvh-1709308842027"></a> 现代 CPU 都支持缓存一致性协议，如 MESI（Modified, Exclusive, Shared, Invalid）协议。当一个 CPU 修改了某个内存位置的值时，它会通知其他 CPU 缓存中相同内存位置的数据无效，从而保证所有 CPU 都能看到最新的数据。

<a name="wpeu-1709308842029"></a>**指令序列化（Instruction Serialization）：**

<a name="ubwg-1709308842031"></a> CAS 操作是一个原子性的指令序列，CPU 会确保在执行 CAS 操作期间不会被中断，以避免其他指令插入导致 CAS 操作失效。

<a name="elct-1709308842033"></a>通过这些硬件级别的支持，CPU 能够保证 CAS 操作的原子性。这种硬件支持使得 CAS 操作成为实现无锁并发算法的重要基础，大大提高了并发程序的性能和效率。

<a name="olfu-1709309769107"></a>**不同的场景适用哪种锁**

<a name="zfod-1709308647416"></a>不同的并发安全措施适用于不同的场景，具体选择取决于应用的需求、性能要求、数据结构以及并发访问模式。以下是一些常见的场景以及相应的并发安全措施：

<a name="y60t-1709309615585"></a>**.共享数据的读写操作：**

<a name="lqad-1709309615587"></a>**适用措施：读写锁（ReadWrite Lock）、互斥锁（Mutex）、原子操作、无锁算法。Copy on Write优化读写锁**

<a name="p6fs-1709309615589"></a>场景说明：当多个线程需要同时读取共享数据，但只有一个线程能够修改数据时，可以使用读写锁来提高读操作的并发性能。互斥锁适用于读写操作都较为频繁的场景，原子操作和无锁算法适用于对共享数据的简单修改操作。

<a name="t4at-1709312672885"></a>-读写锁与copy on write适用于写不依赖于读，令写是原子操作(单写原子性+锁隔离性)，如写缓存。写时复制则令读无需加锁，读性能更高。

<a name="zxpo-1709355699609"></a>nacos注册新实例的时候也是写时复制写缓存。

<a name="fsfa-1709309615591"></a>**.并发容器的操作：**

<a name="rs2n-1709309615593"></a>**适用措施：线程安全的容器类（如ConcurrentHashMap、ConcurrentLinkedQueue）、原子操作。**

<a name="qw0y-1709309615595"></a>场景说明：当多个线程需要对容器进行并发操作时，可以使用线程安全的容器类，这些类内置了并发安全的机制。如果需要更精细的控制，可以使用原子操作来保证数据的一致性。

<a name="xdpv-1709309615597"></a>**.多个线程协作的场景：**

<a name="uzlr-1709309615599"></a>**适用措施：信号量（Semaphore）、条件变量（Condition Variable）。**

<a name="xaa9-1709309615601"></a>场景说明：当多个线程需要在特定条件下进行协作，例如生产者-消费者模型中的缓冲区满或空时，可以使用信号量或条件变量来实现线程之间的同步和通信。

<a name="0aah-1709309615603"></a>**.分布式系统的并发操作：**

<a name="wlhe-1709309615605"></a>**适用措施：分布式锁、分布式事务。**

<a name="5gvg-1709309615607"></a>场景说明：在分布式系统中，多个节点可能需要并发地访问共享资源，可以使用分布式锁来保证资源的互斥访问。对于涉及到多个节点的事务操作，可以使用分布式事务来保证数据的一致性。

<a name="angi-1709309615609"></a>**.不可变数据的并发访问：**

<a name="pga0-1709309615611"></a>**适用措施：不可变数据结构、原子操作。**

<a name="dbat-1709309615613"></a>场景说明：当数据不会发生变化时，可以使用不可变数据结构来避免并发修改导致的数据安全问题。原子操作可以保证对不可变数据的并发访问的线程安全性。

<a name="pw5v-1709309615615"></a>**.高性能要求的并发操作：**

<a name="plv6-1709309615617"></a>**适用措施：无锁算法、并发数据结构。 -CAS乐观锁**

<a name="j4zd-1709309615619"></a>场景说明：在对性能要求较高的场景下，可以使用无锁算法或者特定的并发数据结构来提高并发操作的性能，避免因锁竞争而导致的性能下降。

<a name="pfj2-1709309615621"></a>根据具体的应用场景和需求，选择合适的并发安全措施可以保证程序的正确性、可靠性和性能。

<a name="hjak-1709309764888"></a><a name="62mg-1709309976431"></a>**互斥访问：**

<a name="0qt3-1709307350160"></a>**.互斥锁（Mutex）：**

<a name="yvog-1709307350162"></a>使用互斥锁来保护共享数据的访问，确保在同一时刻只有一个线程可以访问共享数据，其他线程需要等待锁释放后才能访问。常见的互斥锁有互斥量（Mutex）、读写锁（ReadWriteLock）等。

<a name="7xva-1709307350164"></a>**.原子操作：**

<a name="sdcn-1709307350166"></a>使用原子操作来执行对共享数据的读取和修改，确保这些操作是不可分割的，不会被其他线程中断。例如，C++中的原子操作、Java中的Atomic类。

<a name="r8cl-1709307350168"></a>**.临界区（Critical Section）：**

<a name="ctfn-1709307350170"></a>将访问共享数据的代码段包裹在临界区中，通过对临界区进行互斥保护，确保同一时刻只有一个线程可以执行临界区内的代码。

<a name="occj-1709307350172"></a>**.读写锁（ReadWrite Lock）：主要用于避免脏读**

<a name="bhqi-1709307350174"></a>使用读写锁来区分读取和修改操作。读取操作可以被多个线程同时执行，但修改操作需要互斥执行。这样可以提高读取操作的并发性能。

<a name="vej9-1709307350176"></a>**.信号量（Semaphore）：**

<a name="cbah-1709307350178"></a>使用信号量来控制并发线程的数量，限制同时访问共享资源的线程数量。通过信号量的计数值来控制资源的可用性。

<a name="ssge-1709307350180"></a>**.条件变量（Condition Variable）：**

<a name="zp3w-1709307350182"></a>使用条件变量来实现线程之间的同步和通信。当共享数据的状态发生变化时，通过条件变量通知等待的线程。

<a name="zk0j-1709307350184"></a>**.无锁算法（Lock-Free Algorithms）：**

<a name="ijop-1709307350186"></a>使用无锁算法来实现对共享数据的并发访问，避免使用互斥锁等同步机制。常见的无锁算法有CAS（Compare-And-Swap）等。

<a name="tiqo-1709307350188"></a>**.数据拷贝-写时复制（Copy-on-Write）：优化读写锁，写时复制且串行执行(锁)，读不加锁**

<a name="rhsp-1709307350190"></a>对于不可变数据结构，可以采用数据拷贝的方式来保证线程安全。当数据发生修改时，将数据进行复制，而不是直接修改原始数据。

<a name="b8ca-1709307350192"></a>**.线程安全的数据结构：**

<a name="mxvy-1709307350194"></a>使用线程安全的数据结构来替代普通的数据结构，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些数据结构已经内置了线程安全机制。

<a name="qzbb-1709307350196"></a>以上措施都可以在并发编程中用于保证数据安全，具体选择取决于应用场景、性能需求和编程语言特性。

<a name="qy4e-1709307703527"></a><a name="nyrv-1709307688718"></a>**===系统架构设计师===**

<a name="mpwu-1704949756608"></a>**系统工程与信息系统基础**

<a name="2gzz-1704980837071"></a>**.系统工程方法**

|<a name="ufly-1704951943937"></a>系统工程方法|<a name="nxus-1704951943940"></a>关键点|
| :- | :- |
|<p><a name="1laj-1704951943944"></a>霍尔三维结构</p><p><a name="sxj8-1704951943946"></a>“硬科学”方法论</p>|<p><a name="lfis-1704951943949"></a>逻辑维:逻辑维即解决问题的逻辑过程。</p><p><a name="mbik-1704951943951"></a>时间维:时间维即是工作进程。</p><p><a name="6eif-1704951943953"></a>知识维:知识维即是专业科学知识。</p><p><a name="ujck-1704951943955"></a>应用场景:组织和管理大型工程建设项目</p>|
|<p><a name="jrym-1704951943959"></a>切克兰德方法</p><p><a name="q8lv-1704951943961"></a>“软科学”方法论</p>|<p><a name="iypv-1704951943964"></a>核心不是“最优化”，而是“比较”和“探寻”</p><p><a name="ovv5-1704951943966"></a>7步骤:认识问题、根底定义、建立概念模型、比较及探寻、选择、设计与实│</p><p><a name="nbrk-1704951943968"></a>施、评估与反馈</p>|
|<a name="klwq-1704951943972"></a>并行工程方法|<p><a name="lys5-1704951943975"></a>“制造过程”与“支持过程”并行</p><p><a name="fst8-1704951943977"></a>强调三个方面:产品设计开发期间，最快速度按质完成;各项工作问题协调解决;适当的信息系统工具。</p>|
|<a name="prt1-1704951943981"></a>综合集成法|<p><a name="khme-1704951943984"></a>钱学森命名【简单系统】和【巨系统】</p><p><a name="t5z1-1704951943986"></a>四原则:整体论原则、相互联系原则、有序性原则、动态原则</p>|
|<a name="6lvr-1704951943990"></a>wSR系统方法|<a name="1mrj-1704951943993"></a>实践准则:【懂物理】–【明事理】–【通人理】|

<a name="yvug-1704980841473"></a>时间维

1、规划阶段 调研，谋求活动的规划与战略    2、拟定方案    提出具体的计划方案    3、研制阶段 完成研制方案及生产计划      

4、生产阶段生    产零部件及提出安装计划    5、安装阶段 安装完毕，完成系统的运行计划    6、运行阶段    系统按照预期的用途开展服务

7、更新阶段    改进原有系统、或消亡原有系统

逻辑维    

1、明确问题    2、确定目标    建立价值体系或评价体系    3、系统综合    4、系统分析    

<a name="bf7c-1704980841472"></a>5、优化    系统方案的优化选择    6、系统决策    7、实施计划

<a name="mk93-1704952875199"></a>**.系统工程生命周期阶段**

系统工程生命周期阶段

<a name="lrmz-1704980944545"></a>探索性研究>概念阶段>开发阶段>生产阶段>使用阶段（5年）>保障阶段>退役阶段

<a name="ny2c-1704952893636"></a>**.系统工程生命周期方法**

系统工程生命周期方法

计划驱动方法:需求->设计->构建->测试->部署  ---瀑布模型

渐进迭代式开发:提供连续交付以达到期望的系统

精益开发:起源于丰田，是一个动态的、知识驱动的，以客户为中心的过程

<a name="0u7n-1704980953163"></a>敏捷开发:更好的灵活性

<a name="shmt-1704952904062"></a>**.信息系统建设原则**

信息系统建设原则

高层管理人员介入原则    如:CIO介入

用户参与开发原则    用户确定范围、核心用户全程参与、用户深度参与

自顶向下规划原则    以此减少信息不一致的现象

工程化原则    引入【软件工程】

<a name="wtaj-1704951817591"></a>其它原则    创新性原则、整体性原则、发展性原则、经济性原则

<a name="itje-1704951812273"></a>**.信息系统开发方法**

<a name="bnzq-1705819374009"></a>**原型法**

<a name="ujj3-1705819377863"></a>**结构化法-瀑布型**

<a name="8wek-1705819398251"></a>**形式化法-数模**

<a name="jeuk-1705819392097"></a>**敏捷方法**

原型法【需求阶段】  

按功能分：水平原型（界面） 垂直原型（复杂算法-抖音视频推送）

按最终结果分：抛弃式原型       演化式原型

结构化法：面向过程-瀑布型-自顶向下

面相对象方法：抽象-自底向上

面相服务方法： 粗粒度、松耦合、标准化和构件化

其他信息系统开发方式

形式化方法： 数学模型化  飞机，芯片等物理 模型化模拟

统一过程方法【up】

敏捷方法：scrum

<a name="kf2a-1704980979092"></a>基于架构的开发方法：ABSD

<a name="w8yd-1704980881013"></a>**.信息系统分类**

<a name="hlhq-1705819204285"></a>**业务处理系统TPS**

<a name="oksn-1705819204735"></a>**管理信息系统MIS**

<a name="lwm7-1705819204736"></a>**决策支持系统DSS**

<a name="bmeu-1705819204737"></a>**专家系统ES**

<a name="kffq-1705819204738"></a>**办公自动化系统OAS**

<a name="k2px-1705819204739"></a>**企业资源系统ERP**

业务处理系统TPS： OLTP、数据库、报表  -批处理数据

管理信息系统MIS：高度集成化的人机系统    -信息源、信息处理器、信息用户、信息处理者 donphi、pascal

【管理信息系统(Manage lnformation System,MIS)】是由业务处理系统发展而成的，

是在TPS基础上引进大量管理方法对企业整体信息进行处理，并利用信息进行预测、控制、计划、辅助企业全面管理的信息系统。

MIS系统四大部件:信息源、信息处理器、信息用户和信息管理者。十

决策支持系统DSS：语言系统，知识系统和问题处理系统组成，辅助决策

[DSS应具有的特征】

(1)数据和模型是DSS的主要资源。

(2)DSS用来支援用户作决策而不是代替用户作决策。

(3)DSS主要用于解决半结构化及非结构化问题。

(4)DSS的作用在于提高决策的有效性而不是提高决策的效率。

专家系统ES: 知识+推理 。人工智能的一个重要分支

知识库:存储求解实际问题的领域知识。

综合数据库∶存储问题的状态描述、中间结果、求解过程的记录等信息。

推理机:实质是【规则解释器】。

知识获取:两方面功能:知识的编辑求精及知识自学习。

解释程序:面向用户服务的。

办公自动化系统OAS: 

<a name="ct61-1704982049404"></a>企业资源系统ERP: 供应链

<a name="f98t-1704981918920"></a>**过程模型**

<a name="yk4j-1705841608124"></a>**瀑布模型**

严格区分阶段，每个阶段因果关系紧密相连

只适合需求明确的项目

缺点： 

软件需求完整性、正确性难确定

严格串行化，很长时间才能看到结果

<a name="3qne-1705842709255"></a>瀑布模型要求每个阶段一次性完全解决该阶段工作,这不现实。

<a name="oryp-1705841608705"></a>**V模型【瀑布变种-测试贯穿】**

测试贯穿于始终

测试分阶段(测试计划提前

<a name="p0k5-1705846375566"></a>编码后开始测试倒V成V字

<a name="b0cp-1705841621350"></a>**原型模型**

适合需求不明确的项目原型模型两个阶段:

1、原型开发阶段

2、目标软件开发阶段

<a name="cqhh-1705845876255"></a>[抛弃型原型)与【演化型原型】

<a name="sfqi-1705841608707"></a>**螺旋模型【原型+瀑布 风险】**

迭代型与增量型

以快速原型为基础+瀑布模型

<a name="b7wi-1705846464151"></a>考虑了风险问题

<a name="kbjw-1705841608709"></a>**构件组装模型/基于构件的开发方法**

【优点】易扩展、易重用、降低成本、安排任务更灵活。

【缺点】构件设计要求经验丰富的架构师、设计不好的构件难重用、强调重用可能牺牲其它指标(如性能)、第三方构件质量难控制。

【示例】

方舱医院

乐高积木

基于构件的软件工程(CBSE)

CBSE体现了【购买而不是重新构造】的哲学。

(CBSE的构件应该具备的特征】

1、可组装性:所有外部交互必须通过公开定义的接口进行。

2、可部署性:构件总是二进制形式的，能作为一个独立实体在平台上运行。

3、文档化:用户根据文档来判断构件是否满足需求。

4、独立性:可以在无其他特殊构件的情况下进行组装和部署。5、标准化:符合某种标准化的构件模型。

【构件的组装】

1、顺序组装:按顺序调用己经存在的构件，可以用两个已经存在的构件来创造一个新的构件。

2、层次组装:被调用构件的“提供”接口必须和调用构件的“请求”接口兼容。

<a name="zjcw-1705846978074"></a>3、叠加组装:多个构件合并形成新构件，新构件整合原构件的功能，对外提供新的接口。

<a name="mvze-1705841627436"></a>**快速应用开发RAD【瀑布+构件组装】**

业务建模

数据建模

过程建模

应用生成

<a name="nafe-1705930248825"></a>测试与交付

<a name="xici-1705841629815"></a>**统一过程/统一开发方法**

9个核心工作流：

业务建模

需求分析与设计

实现测试部署

配置与变更管理

项目管理

<a name="rsee-1705931291257"></a>环境

<a name="9jca-1705841608711"></a>**敏捷开发方法**

敏捷宣言

√个体和交互胜过过程和工具

√可工作的软件胜过大量的文档

√客户合作胜过合同谈判

√响应变化胜过遵循计划

传统软件开发方法: 预设性的 > 以开发过程为本 > 整体分阶段

<a name="flva-1705938097079"></a>敏捷方法: 适应性的 - 以人为本 - 增量迭代，小步快跑 - 适合小型项目

<a name="28va-1705841590197"></a>**XP**

敏捷方法- XP

4大价值观

沟通【加强面对面沟通】

简单【不过度设计】

反馈【及时反馈】

勇气【接受变更的勇气】

12条过程实践规则:

简单设计 测试驱动 代码重构 结对编程 持续集成 现场客户

发行版本 小型化 系统隐喻 代码集体所有 制规划策略 规范代码

<a name="mbtp-1705938236342"></a>40小时工作机制

<a name="fyfq-1705938223773"></a>**Scrum**

.极限编程\_(XP)∶价值观【交流、朴素、反馈、勇气】、近螺旋式的开发方法。

.水晶方法:提倡“机动性”的方法，拥有对不同类型项目非常有效的敏捷过程。

.SCRUM:侧重于项目管理。

.特征驱动开发方法（FDD)∶认为有效的软件开发需要3要素【人、过程、技术】。

.定义了6种关键的项目角色:项目经理、首席架构设计师、开发经理、主程序员、程序员和领域专家。

.开放式源码:程序开发人员在地域上分布很广【其他方法强调集中办公】。

.ASD方法:其核心是三个非线性的、重叠的开发阶段:猜测合作与学习。

<a name="elzb-1705938420182"></a>.动态系统开发方法(DSDM)︰倡导以业务为核心。

<a name="d5ko-1705938215067"></a>**逆向工程**

<a name="os3c-1706090901666"></a>**实现级**

<a name="irxb-1706090905276"></a>**结构级**

<a name="rk8d-1706090908958"></a>**功能级**

<a name="k3pt-1706090912460"></a>**领域级**

现有工程 - 再工程  -新系统   

逆向工程是设计的恢复过程。

\------

实现级:包括程序的抽象语法树、符号表、过程的设计表示

结构级:包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构

功能级:包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型

领域级∶包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型

与逆向工程相关的概念有重构、设计恢复、再工程和正向工程。

(1）重构/重组(Restructuring)。重构是指在【同一抽象级别】上【转换系统描述形式】。

(2）设计恢复(Design recovery)。设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。

(3)逆向工程(Reverse engineering):逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程。

(4）正向工程（Forward engineering)。正向工程是指不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，以改善其整体质量。

<a name="efxo-1705938813039"></a>(5）再工程/重构工程(Re-engineering)。再工程是对现有系统的重新开发过程，包括逆向工程、新需求的考虑过程和正向工程三个步骤。

<a name="tybd-1705938215235"></a>**净室软件工程**

√净室即无尘室、洁净室。也就是一个受控污染级别的环境。

√使用盒结构规约（或形式化方法)进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制。

√使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息。

-- 举例前端的 拖拽式功能框

【技术手段】

√统计过程控制下的增量式开发:控制迭代

√基于函数的规范和设计:盒子结构

`    `定义3种抽象层次:行为视图(黑盒)->有限状态机视图（状态盒)->过程视图（明盒/白盒)

√正确性验证:净室工程的核心

√统计测试和软件认证:使用统计学原理，总体太大时必须采用抽样方法

【缺点】

√太理论化，正确性验证的步骤比较困难且耗时。

√开发小组不进行传统的模块测试，这是不现实的。

<a name="iesl-1705939167964"></a>√脱胎于传统软件工程，不可避免带有传统软件工程的一些弊端。

<a name="ochn-1705940085547"></a>**需求工程**

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。  -需求开发

【需求工程主要活动的阶段划分】

需求获取

需求分析

形成需求规格【形成SRS】

需求确认与验证【形成需求基线(经过评审的SRS)】

需求管理【变更控制、版本控制、需求跟踪、需求状态跟踪】

<a name="nlvu-1705940085546"></a>需求管理是对【需求基线】进行管理

<a name="xdlf-1705940054108"></a>**.需求获取**

<a name="s1uq-1706090846730"></a>**用户面谈** 

<a name="vuil-1706090851858"></a>**联合需求计划(JRP)** 

<a name="gpxg-1706090851859"></a>**问卷调查** 

<a name="mg9n-1706090851860"></a>**现场观察**   

<a name="3ww6-1706090851861"></a>**原型化方法**        

<a name="0awr-1706090851863"></a>**头脑风暴法**

软件需求获取方法

用户面谈 - 需求专题讨论会(JRP) - 问卷调查 - 现场观察 - 原型化方法 - 头脑风暴法

分层

√业务需求()整体全局)

√用户需求用户视角

√系统需求(计算机化)   -功能需求  -性能需求(非功能)  -设计约束

项目管理维度QFD

√基本需求(明示，常规需求)

√期望需求（隐含)

√兴奋需求(多余)

`    `方法                                    特点

用户面谈                1对1-3，有代表性的用户，了解主观想法，交互好。成本高，要有领域知识支撑。

联合需求计划(JRP)        高度组织的群体会议，各方参与，了解想法，消除分歧，交互好，成本高。

问卷调查                用户多，无法一一访谈，成本低。

现场观察                针对较为复杂的流程和操作。

原型化方法               通过简易系统方式解决早期需求不确定问题。

<a name="jvim-1705940257086"></a>头脑风暴法               一群人围绕新业务，发散思维,不产生新的观点。

<a name="axny-1705940052332"></a>**.需求分析**

<a name="v8wz-1706090812929"></a>**1.功能模型(数据流图DFD)**

<a name="3uls-1706090814821"></a>**2.行为模型(状态转换图)**

<a name="69df-1706090816407"></a>**3.实体模型(E-R图)**

需求工程-需求开发-需求分析- SA(DFD)

数据字典 数据元素-数据结构-数据流-数据存储-加工逻辑-外部实体

功能模型(数据流图DFD):数据流-加工-数据存储-外部实体

行为模型(状态转换图)：  状态(初态、终态)-事件

<a name="ovab-1705940661004"></a>实体模型(E-R图):  实体-联系

<a name="loq2-1705940640473"></a>**UML**

UML(统一建模语言)︰平台无关、语言无关。

结构事物:最静态的部分，包括:类、接口、协作、用例、活动类、构件和节点。

\>行为事物:代表时间和空间上的动作。包括:消息、动作次序、连接。

\>分组事物:看成是个盒子，如:包、构件。

\>注释事物:UML模型的解释部分。描述、说明和标注模型的元素。

动态图(行为图)

用例图:系统与外部参与者的交互

顺序图:强调按时间顺序

通信图(协作图)

状态图:状态转换变迁

活动图:类似程序流程图，并行行为

定时图:强调实际时间

交互概览图

静态图(结构图)

类图:一组类、接口、协作和它们之间的

关系对象图:一组对象及它们之间的关系

构件图:一个封装的类和它的接口

部署图:软硬件之间映射

制品图:系统的物理结构

·包图:由模型本身分解而成的组织单元，以及它们之间的依赖关系

·组合结构图

系统分析、设计人员                        程序员

逻辑视图(logical view)            实现视图(implementation view)

类与对象                           物理代码文件和组件 

系统集成人员                                系统和网络工程师

进程视图(process view)                部署视图(deployment view)    

<a name="ygog-1706091052296"></a>线程、进程、并发                            软件到硬件的映射

<a name="4aeg-1706091062964"></a>**需求定义**

严格定义法：

√所有需求都能够被预先定义

√开发人员与用户之间能够准确而清晰地交流

√采用图形/文字可以充分体现最终系统

原型法：

√并非所有的需求都能在开发前被准确的说明

√项目参加者之间通常都存在交流上的困难

√需要实际的、可供用户参与的系统模型

√有合适的系统开发环境

<a name="xyp0-1706092631364"></a>√反复是完全需要和值得提倡的，需求一旦确定，就应遵从严格的方法

<a name="ud2s-1706090947930"></a>**需求验证**

SRS:

需求评审  正式评审>非正式评审

需求测试

<a name="yies-1706092882866"></a>用户签字>确认验收标准之一

<a name="l03x-1705940634470"></a>**需求跟踪**

<a name="muqf-1706093218719"></a>**需求变更管理**

识别出问题

`    `问题分析和变更描述

`        `变更分析和成本计算   CCB

<a name="g9hm-1706093512613"></a>             变更实现  > 修改后的需求

<a name="ilpb-1706093190683"></a>**软件系统建模**

<a name="j396-1706094675778"></a>**软件界面设计**

黄金三法则

★置于用户控制之下

·以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式

·提供灵活的交互

·允许用户交互可以被中断和撤销

.当技能级别增加时可以使交互流水化并允许定制交互

·使用户隔离内部技术细节

·设计应允许用户和出现在屏幕上的对象直接交互

★减少用户的记忆负担

.减少对短期记忆的要求

·建立有意义的缺省

·定义直觉性的捷径

·界面的视觉布局应该基于真实世界的隐喻

·以不断进展的方式揭示信息

★保持界面的一致性

·允许用户将当前任务放入有意义的语境

·在应用系列内保持一致性

<a name="zy6c-1706094832554"></a>·如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要改变它

<a name="vqsk-1706094478028"></a>**结构化设计**

概要设计【外部设计】︰功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图

详细设计【内部设计】︰为每个具体任务选择适当的技术手段和处理方法

结构化设计原则:

模块独立性原则(高内聚、低耦合)

·保持模块的大小适中

·多扇入，少扇出       模块A扇入3(高复用)，扇出2(高依赖)       1>A 2>A 3>A  A<4 A<5  -高扇入即A被多个函数调用，复用率高good; 高扇出A调用多个函数，系统复杂性不可预见性增加；

<a name="upqt-1706095030525"></a>·深度和宽度均不宜过高

<a name="jczo-1706095018132"></a>**内聚**

内聚类型(由高到低)                描述

功能内聚    完成一个单一功能,各个部分协同工作，缺一不可

顺序内聚    处理元素相关,而且必须顺序执行

通信内聚    所有处理元素集中在一个数据结构的区域上

过程内聚    处理元素相关，而且必须按特定的次序执行

时间内聚    所包含的任务必须在同一时间间隔内执行  (瞬时内聚)

逻辑内聚    完成逻辑上相关的一组任务

<a name="snap-1706095411069"></a>偶然内聚    完成一组没有关系或松散关系的任务  (巧合内聚)

<a name="qa8z-1706095402118"></a>**耦合**

耦合类型（由低到高）        描述

非直接耦合  两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的

数据耦合    

标记耦合    一组模块借助参数表传递简单数据

控制耦合    一组模块通过参数表传递记录信息(数据结构

外部耦合    模块之间传递的信息中包含用于控制模块内部逻辑的信息一组模块都访问同一全局简单变量，而且不是通过参数表传递该全局变量的信息

公共耦合    多个模块都访问同一个公共数据环境

<a name="yov0-1706095508310"></a>内容耦合    一个模块直接访问另一个模块的内部数据;一个模块不通过正常入口转到另一个模块的内部;两个模块有一部分程序代码重叠;一个模块有多个入口

<a name="g1dc-1706095391028"></a>**模块四要素**

模块的四个要素

输入和输出:模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。

处理功能:指模块把输入转换成输出所做的工作。

内部数据:指仅供该模块本身引用的数据。

<a name="j80k-1706095890170"></a>程序代码:指用来实现模块功能的程序。

<a name="ydwa-1706095870710"></a>**面相对象设计**

<a name="fouz-1706095958643"></a>**类的分类**

边界类：机器接口-API接口、人机交互-用户界面

`    `例:显示屏、窗体、打印机接口、、通信协议、对话框、菜单、购物、车、报表、二维码

控制类: 应用逻辑、业务逻辑、数据访问逻辑

`    `例:身份验证器

实体类：数据

<a name="fa2r-1706096021041"></a>    例:学员类、课程类

<a name="9pd1-1706095996137"></a>**基本过程**

分析模型            设计师            设计模型

用例模型        设计用例实现方案    架构图(用包图表示)

`                `设计技术支撑实施    用例实现图(用交互图表示)

`                `设计用户界面        类图（完整、精确)

分析模型        细化设计模型            其他（状态图、活动图等)l

<a name="tdyn-1706096267080"></a>(领域模型)

<a name="k8lc-1706096001163"></a>**设计原则(同设计模式)**

★单一职责原则:设计目的单一的类

★开放-封闭原则:对扩展开放，对修改封闭

★李氏(Liskov)替换原则:子类可以替换父类    泛化/继承

★依赖倒置原则:要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程

★接口隔离原则:使用多个专门的接口比使用单一的总接口要好

★组合重用原则:要尽量使用组合，而不是继承关系达到重用目的

<a name="we2w-1706096471101"></a>★迪米特(Demeter)原则（最少知识原则)︰一个对象应当对其他对象有尽可能少的了解（信息隐蔽，避免绕过接口）

<a name="qvol-1706095952165"></a>**计算机**

<a name="ef1b-1706108352037"></a>**计算机结构(★)**

CPU

运算器

算术逻辑单元ALU:数据的算术运算和逻辑运算

累加寄存器AC:通用寄存器，为ALU提供一个工作区，用在暂存数据数据

缓冲寄存器DR:写内存时，暂存指令或数据

状态条件寄存器PSW:存状态标志与控制标志(争议:也有将其归为控制器的)

控制器

程序计数器PC:存储下一条要执行指令的地址

指令寄存器IR:存储即将执行的指令

指令译码器ID:对指令中的操作码字段进行分析解释

<a name="2tuf-1706108642011"></a>时序部件:提供时序控制信号

<a name="4kj7-1706108373776"></a>**存储系统(★★★★)**

<a name="ucta-1706109825295"></a>**层次化存储结构**

<a name="j9hn-1706109828962"></a>**Cache**

<a name="pv51-1706109847372"></a>**主存编址计算**

层次化存储结构

CPU:寄存器

Cache:按内容存取(相联存储器)

内存(主存):DRAM

外存(辅存):硬盘、光盘、U盘等

Cache  -高命中率+快速访问能力  -L1、L2cache 高速缓存器

√ Cache的功能:提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。

√在计算机的存储系统体系中，Cache是访问速度最快的层次。  

√Cache对程序员来说是透明的。  -硬件相关，与程序员无法操作

√使用Cache改善系统性能的依据是程序的局部性原理。

√时间局部性:指程序中的某条指令一旦执行，不久以后该指令可能再次执行，典型原因是由于程序中存在着大量的循环操作。 -循环

√空间局部性:指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，

其典型情况是程序顺序执行。                -索引局部性

√工作集理论:工作集是进程运行时被频繁访问的页面集合。

主存编址计算

存储单元：存储单个数=最大地址最小地址1 

编址内容：

按字编址存储体的存储单元是存储单元，即最小寻址单位是一个字

按字节编址存储体的存储单元是字节存储单元，即最小寻址单位是一个字节。

总容量=存储单元个数\*编址内容

根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出所需芯片的总数，即:

<a name="nfaa-1706109451658"></a>        总片数总容量/每片的容量

<a name="jcqv-1706108377026"></a>**磁盘基本结构与存储过程**

<a name="gnlm-1706111292670"></a>存取时间=寻道时间+等待时间，寻道时间是指磁头移动到磁道所需的时间;等待时间为等待读写的扇区转到磁头下方所用的时间。

<a name="puux-1706111215530"></a>**磁盘优化分布存储**

<a name="dvin-1706111222861"></a>**磁盘单缓冲区与双缓冲区读取**

<a name="jr2r-1706111239137"></a>**磁盘移臂调度算法**

先来先服务(FCFS)

最短寻意时间优先(SSIE)

扫描算法(SCAN) -电梯算法

<a name="eh8a-1706113646563"></a>循环扫描(CSCAN)算法

<a name="sz2k-1706111188014"></a>**数据传输控制方式（★)**

I/O

√程序控制(查询)方式:分为无条件传送和程序查询方式两种。方法简单，硬件开销小，但I/O能力不高，严重影响CPU的利用率。

√程序中断方式:与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度。

<a name="ox7i-1706114676724"></a>√DMA方式:DMA方式是为了在主存与外设之间实现高速、批量数据交换而设置的。DMA方式比程序控制方式与中断方式都高效。

<a name="cbul-1706108378755"></a>**总线（★★)**

√总线是一组能为多个部件分时共享的公共信息传送线路。

`    `·共享

`    `·分时:是指同一时刻仅允许一个部件向总线发送信息，但允许多个部件同时从总线上接收相同的信息。

√串行总线(适合长距离传输)与并行总线(适合近距离连接，不宜过长)√单工、半双工与全双工

√总线宽度与总线带宽

总线的分类:

数据总线(Data Bus,DB)︰在CPU与RAM之间来回传送需要处理或是需要储存的数据。

地址总线(Address Bus，AB)︰用来指定在RAM (Random AccessMemory)之中储存的数据的地址。

<a name="ohwy-1706118513285"></a>控制总线(Control Bus，CB)∶将微处理器控制单元(Control Unit)的信号，传送到周边设备。

<a name="0hb5-1706108373778"></a>**CISC与RISC(★)**

<a name="ernn-1706108380109"></a>**流水线(★★)**

相关参数计算:流水线执行时间计算、流水线吞吐率、流水线加速比等。

流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，

<a name="ssri-1706118953399"></a>它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度

<a name="grix-1706108381278"></a>**校验码(★)**

<a name="1p2v-1706108382511"></a>**嵌入式（★)**

<a name="8vmt-1706198382356"></a>**计算机网络**

网际互连协议(IP,Internet Protocol)

传输控制协议(TCP,Transmission Control Protocol)  长连接3次握手

<a name="mucg-1706198453540"></a>用户数据报协议(UDP，User Datagram Protocol)       扔数据包

<a name="a4es-1706106975412"></a>**TCP/IP协议族(7层/4层网络模型)**

OSI七层模型    TCP/IP模型

应用层            -                POP3：110 

表示层            应用层            FTP：20/21    HTTP:80    DHCP：67     TFTP：69

会话层            -                Telnet：23    SMTP：25 简单邮件    SNMP：161     DNS：53

传输层            传输层            TCP    UDP

网络层            网际层            IP  ICMP    IGMP    ARP    RARP

数据链路层        网络接口层

物理层            -                CSMA/CD    TokingRing

TCP/IP协议族

POP3: 110端口，邮件收取

SMTP:25端口，邮件发送

FTP:20数据端口/21控制端口，文件传输协议

HTTP:80端口，超文本传输协议，网页传输

DHCP:67端口，IP地址自动分配

SNMP: 161端口，简单网络管理协议

DNS:53端口，域名解析协议，记录域名与IP的映射关系

TCP:可靠的传输层协议

UDP:不可靠的传输层协议

ICMP:因特网控制协议，PING命令来自该协议IGMP:组播协议 - trace

ARP:地址解析协议，IP地址转换为MAC地址

<a name="cgyp-1706249614651"></a>RARP:反向地址解析协议，MAC地址转lP地址

<a name="vwim-1706198561289"></a>**.TCP与UDP (★★★)**

共同点：基于IP协议的传输层协议，可以端口寻址

不同点:             

TCP -面向连接（连接管理)、三次握手、流量控制-滑动窗口限流、差错校验和重传、IP数据报按序接收(不  丢失、不重复)、可靠性强、牺牲通信量、效率低                         

UDP -不可靠、无连接、错误检测功能弱，无拥塞控制、无流量控制， 有助于提高传输的高速率性。

`     `不对无序IP数据报重新排序、不负责重传、不消除重复IP数据报、不对已收到的数据报进行确认、不负责建立或终止连接，

`     `这些由UDP进行通信的应用程序进行处理。



相关协议:

TCP - HTTP、FTP、Telnet、POP3、SMTP

<a name="2nxi-1706256522084"></a>UDP - DNS、DHCP、TFTP、SNMP

<a name="imsh-1706198537828"></a>**.DHCP与DNS (★★★)**

主机向本地域名服务器的查询采用递归查询。

本地域名服务器向根域名服务器的查询通常采用迭代查询。

域名解析链路：

`    `域名  - 本地host-缓存-（递归查询）本地域名服务器 dns.xyz.com -    

`                `（迭代查询，全球仅几台）3根域名服务器 / 4顶级域名服务器  / 5权限域名服务器



递归查询:服务器必需回答自标IP与域名的映射关系

迭代查询:服务器收到一次迭代查询回复一次结果，这个结果不一定是目标IP与域名的映射关系,也可以是其它DNS服务器的地址。

浏览器输入域名 ： HOSTS→本地DNS缓存→本地DNS服务器→根域名服务器→顶级域名服务器→权限域名服务器。

主域名服务器接收到域名请求 ：   本地缓存记录→区域记录→转发域名服务器→根域名服务器。

动态主机配置协议(DHCP，Dynamic Host Configuration Protocol)

1、客户机/服务器模型2、租约默认为8天

3、当租约过半时，客户机需要向DHCP服务器申请续租;

4、当租约超过87.5%时，如果仍然没有和当初提供IP的DHCP服务器联系上则开始联系其他的DHCP服务器。

5、分配方式

固定分配(管理员分配静态绑定固定的IP地址)

动态分配（为客户端分配租期为无限长的IP地址)

自动分配（为客户端分配具有一定有效期限的IP地址)

<a name="oikq-1706256859327"></a>6、无效地址:169.254.X.X和0.0.0.0

<a name="u7sd-1706198559304"></a>**网络规划与设计**

<a name="nov8-1706198591905"></a>**1.逻辑设计与物理设计(★★★★）**

网络规划与设计-逻辑网络设计

逻辑网络设计是体现网络设计核心思想的关键阶段，在这一阶段根据需

求规范和通信规范，选择一种比较适宜的网络逻辑结构，并基于该逻辑结构实施后续的资源分配规划、安全规划等内容。利用需求分析和现有网络体系分析的

结果来设计逻辑网络结构，最后得到一份逻辑网络设计文档。

逻辑网络设计工作主要包括以下内容:

(1）网络结构的设计

(2）物理层技术的选择

3）局域网技术的选择与应用

(4)广域网技术的选择与应用

(5)地址设计和命名模型

(6）路由选择协议

(7)网络管理

(8）网络安全

(9)逻辑网络设计文档

输出内容包括以下几点:

.逻辑网络设计图

.IP地址方案

.安全管理方案

.具体的软/硬件、广域网连接设备和基本的网络服务

.招聘和培训网络员工的具体说明

.对软/硬件费用、服务提供费用、员王和培训的费用初步估计

网络规划与设计–物理网络设计

物理网络设计是对逻辑网络设计的物理实现，通过对设备的具体物理分布、运行环境等确定，确保网络的物理连接符合逻辑连接的要求。

在这一阶段，网络设计者需要确定具体的软/硬件、连接设备、布线和服务的部署方案，

输出如下内容:

.网络物理结构图和布线方案

.设备和部件的详细列表清单

.软硬件和安装费用的估算

.安装日程表，详细说明服务的时间以及期限

.安装后的测试计划

<a name="1jly-1706257567932"></a>.用户的培训计划

<a name="sy2g-1706198599196"></a>**2.层次化网络设计**

核心层:主要是高速数据交换，实现高速数据传输、出口路由，常用冗余机制。

汇聚层∶网络访问策略控制、数据包处理和过滤、策略路由、广播域定义、寻址。

<a name="notp-1706257986732"></a>接入层:主要是针对用户端，实现用户接入、计费管理、MAC地址认证、MAC地址过滤、收集用户信息,可以使用集线器代替交换机。

<a name="igl7-1706257923205"></a>**3.网络冗余设计**

在网络冗余设计中，对于通信线路常见的设计目标

主要有两个:

`    `备用路径

`    `负载分担。

备用路径，提高可用性,由路由器、交换机等设备之间的独立备用链路构成，一般情况下备用路径仅仅在主路径失效时投入使用。

设计时主要考虑:

(1）备用路径的带宽

(2)切换时间

(3）非对称

(4）自动切换

(5）测试

负载分担,是对备用路径方式的扩充,通过并行链路提供流量分担(冗余的形式)来提高性能，主要的实现方法是利用两个或多个网络接口和路径来同时传递流量，

设计时注意考虑:

.网络中存在备用路径、备用链路时,可以考虑加入负载分担设计

.对于主路径、备用路径都相同的情况,可以实施负载分担的特例—负载均衡

<a name="hmbb-1706259541284"></a>.对于主路径、备用路径不相同的情况,可以采用策略路由机制，让一部分应

<a name="zkxb-1706257899477"></a>**网络存储（★★)**

分类

直连式存储(DAS，Direct-Attached Storage)

网络附加存储(NAS，Network-Attached Storage)

存储区域网络(SAN，Storage Area Network)

Internet小型计算机系统接口（iSCSl，Internet Small Computer System Interface)

DAS/SAS: 通过SCSI连接到服务器，本身是硬件的堆叠，不带有任何操作系统。存储器必须被直接连接到应用服务器上，不能跨平台共享文件，

`        `各系统平台下文件分别存储。

NAS: 通过网络接口与网络直接连接，由用户通过网络访问(支持多种TCP/IP协议)。NAS设备有自己的OS，类似于一个专用的文件服务器，

`        `一般存储信息采用RAID进行管理。即插即用。

SAN: 通过专用高速网络将一个或多个网络存储设备和服务器连接起来的专用存储系统，采用数据块的方式进行数据和信息的存储。

`        `目前主要使用以太网(IP SAN)和光纤通道(FC SAN)两类环境。

<a name="e8rr-1706259655613"></a>IP-SAN/iSCSI : 基于IP网络实现,设备成本低，配置技术简单，可共享和使用大容量的存储空间。

<a name="fxma-1706198636789"></a>**磁盘阵列Raid**

磁盘阵列(RAID，Redundant Arrays of Independent Disk)

Raid0(条块化):性能最高，并行处理，无冗余，损坏无法恢复

Raidl(镜像结构):可用性，可修复性好，仅有50%利用率

RaidO+1(Raid10): Raid0与Raidl长处的结合，高效也可靠

Raid3(奇偶校验并行传送):N+1模式，有固定的校验盘，坏一个盘可恢复

Raid5(分布式奇偶校验的独立磁盘):N+1模式，无固定的校验盘，坏一个盘可恢复

<a name="zf39-1706259856625"></a>Raid6(两种存储的奇偶校验):N+2模式，无固定的校验盘，坏两个盘可恢复

<a name="vlem-1706259832461"></a>**lPv6 (★)**

IPv6是设计用于替代现行版本lP协议(IPv4)的下一代IP协议。

(1）寻址能力方面的扩展。IPv6地址长度为128位，地址空间增大了2的96次方倍;

(2）灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPv4中可变长度的选项字段。IPv6中选项部分的出现方式也有所变化，

使路由器可以简单路过选项而不做任何处理，加快了报文处理速度;

(3)IPv6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量;

(4）提高安全性。身份认证和隐私权是IPv6的关键特性;

(5）支持更多的服务类型;

(6)允许协议继续演变，增加新的功能，使之适应未来技术的发展;

IPv6地址由8个16进制字段构成。例如:

2001:0db8:85a3:0000:1319:8a2e:0370:7344

lPv6地址的省写，上面的IP地址等价于:

2001:0db8:85a3.:1319:8a2e:0370:7344。

遵守这些规则，如果因为省略而出现了两个以上的冒号，则可以压缩为一个，

但这种零压缩在地址中只能出现一次。因此:

2001:0DB8:0000:0000:0000:0000:1428:57ab2001:0DB8:0:0:0:0:1428:57ab

2001:0DB8::1428:57ab

2001:DB8::1428:57ab

以上都是合法的地址，并且它们是等价的。同时前导的零可以省略，因此:

2001:0DB8:02de::Oe13等价于2001:DB8:2de:e13。

·单播地址(Unicast):用于单个接口的标识符，传统的点对点通信。

·组播地址(Multicast):多播地址，一点对多点的通信，数据包交付到一组计算机中的每一个。IPv6没有广播的术语，而是将广播看做多播的一个特例。

.任播地址(Anycast):泛播地址，这是IPv6增加的一种类型。任播的目的站是一组计算机，但数据包在交付时只交付给其中一个，通常是距离最近的一个。

多播:前缀为11111111

任播:前缀固定，其余位置为0

单播

·可聚合全球单播地址:前缀001。

.本地单播地址:

`    `链路本地:前缀为1111111010 (一般以fe80开头)

`    `站点本地:前缀为1111111011

lPv6规定每个网卡最少有3个IPv6地址，分别是链路本地地址、全球单播地址和回送地址(站点本地地址)。

lPv6把自动IP地址配置作为标准功能，只要计算机连接上网络便可自动f分配IP地址。

√全状态自动配置(Stateful Auto-Configuration): IPv6继承了IPv4动态主机配置协议(DHCP）这种自动配置服务。

√无状态自动配置(Stateless Auto-Configuration):主机通过两个阶段分别获得链路本地地址和可聚合全球单播地址。

.首先主机将其网卡MAC地址附加在链路本地地址前缀11111111010之后，产生一个链路本

地地址，发出一个ICMPv6邻居发现请求，验证其地址唯一性。不唯一则便用随机接口ID组成一个新的链路本地地址。

.主机以链路本地地址为源地址，向本地链路中所有路由器的组播ICMPv6路由器请求报文并返回一个包含可聚合全球单播地址前缀的路由器公告报文响应。

该地址前缀加上自己的接口ID，自动配置一个全球单播地址。使用无状态自动配置，无须用户手工干预就可以改变主机的IPv6地址。

lPv4/ IPv6过渡技术有:

(1）双协议栈技术:双栈技术通过节点对IPv4和IPv6双协议栈的支持，从而支持两种业务的共存。

(2）隧道技术:隧道技术通过在IPv4网络中部署隧道，实现在IPv4网络上对IPv6业务的承载，保证业务的共存和过渡。

隧道技术包括:

6to4隧道；

6over4隧道;

ISATAP隧道。

<a name="cfbw-1706259967110"></a>(3)NAT-PT技术: NAT一PT使用网关设备连接IPv6和IPv4网络。当IPv4和IPv6节点互相访问时，NAT一PT网关实现两种协议的转换翻译和地址的映射。

<a name="g438-1706198637653"></a>**网络接入(有线/无线)**

有线接入：

公用交换电话网络(PSTN)

数宁数据网(DDN)

综合业务数字网(ISDN)

非对称数字用户线路(ADSL)

同轴光纤技术(HFC)

无线接入：

IEEE 802.11(WiFi)

IEEE 802.15(蓝牙Bluetooth)

红外(IrDA)

WAPI

<a name="wbb7-1706260463027"></a>1G~5G

<a name="lxli-1706198497856"></a>**综合布线(★)**

.工作区子系统由信息插座、插座盒、连接跳线和适配器组成。

.水平子系统由一个工作区的信息插座开始，经水平布置到管理区的内侧配线架的线缆所组成。

.管理子系统由交连、互连配线架组成。管理子系统为连接其它子系统提供连接手段。

.垂直干线子系统由建筑物内所有的垂直干线多对数电缆及相关支撑硬件组成，

`    `以提供设备间总配线架与干线接线间楼层配线架之间的干线路由。

.设备间子系统是由设备间中的电缆、连接器和有关的支撑硬件组成，

`    `作用是将计算机、PBX、摄像头、监视器等弱电设备互连起来并连接到主配线架上。

.建筑群子系统将一个建筑物的电缆延伸到建筑群的另外一些建筑物中的通信设备和装置上，是结构化布线系统的一部分，

<a name="3phi-1706275430215"></a>    支持提供楼群之间通信所需的硬件。它由电缆、光缆和入楼处的过流过压电气保护设备等相关硬件组成，常用介质是光缆。

<a name="5dlt-1706198650540"></a>**网络技术扩展**

<a name="jgll-1706198586849"></a>**物联网(IOT)**

物联网(The Internet of Things）是实现物物相连的互联网络 IOT

其内涵包含两个方面:

.物联网的核心和基础仍然是互联网，是在互联网基础上延伸和扩展的网络;

.其用户端延伸和扩展到了任何物体与物体之间，使其进行信息交换和通信

.感知层:识别物体、采集信息。如:二维码、RFID、摄像头、传感器(温度、湿度)

.网络层:传递信息和处理信息。通信网与互联网的融合网络、网络管理中心、信息中心和智能处理中心等

.应用层:解决信息处理和人机交互的问题

关键技术--RFID QRcode

射频识别技术\_(Radio Frequency ldentification，RFID),又称电子标签，是一种通信技术，可通过无线电讯号识别特定目标并读写相关数据，

而无需识别系统与特定目标之间建立机械或光学接触。该技术是物联网的一项核心技术,很多物联网应用都离不开它

RFID的基本组成部分通常包括:标签、阅读器、天线。

二维码是用某种特定的几何图形按一定规律在平面(二维方向上）分布的黑白相间的图形记录数据符号信息的。在代码编制上巧妙地利用构成计算机

内部逻辑基础的“O”、 “1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信

息自动处理.

二维条码中，常用的码制有:Data Matrix，Maxi Code，Aztec,QR Code，Vericode,PDF417,Ultracode，Code 49，Code 16K

.若采用扩展的字母数字压缩格式,可容纳1850个字符

.若采用二进制/ASCII格式,可容纳1108个字节

<a name="xro7-1706275865320"></a>.若采用数字压缩格式，可容纳>710个数字

<a name="pr8x-1706198586851"></a>**云计算(Saas/Paas/Iaas)**

云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需提供给计算机和其他设备。云其实是网络、互联网的一种比喻说法。

云计算的核心思想，是将大量用网络连接的计算资源统一管理和调度，构成一个计算资源池向用户按需服务。提供资源的网络被称为“云”。

狭义云计算指IT基础设施的交付和使用模式，指通过网络以按需、易扩展的方式获得所需资源;广义云计算指服务的交付和使用模式，指通过网络以按需、

易扩展的方式获得所需服务。这种服务可以是IT和软件、互联网相关，也可是其他服务

特点:

.集合了大量计算机，规模达到成千上万

.多种软硬件技术相结合

.对客户端设备的要求低

.规模化效应

√软件即服务(SaaS)    -软件

√平台即服务(PaaS)       -二次开发

<a name="824i-1706275570096"></a>√基础设施即服务(laaS)   -硬件

<a name="1rnn-1706941312871"></a>**===系统架构设计case===**

<a name="nm5q-1706969255961"></a>**google L5设计一个分布式数据库架构**

DESIGN-A DISTRIBUTED DATABASE

RESOURCES:

-taken ·from-somebody's real -google system-design-interview

REQUIREMENTS:

--distributed database

-specify stuff like isolation- level, transactions support,consistency-level

variations:

\1) Read-heavy

\2) write-heavy

\3) Total ordering and heavy writes for ticketmaster/"flashsale"

Most use cases are read-heavy

\------

snapshot isolation

multi-version concurrency control 

use-some- "version-vectors"?

Does it·make sense to have a separate coordinator for all of the shards?-(Like ZooKeeper)

or-does the: request - router - handle coordinating the-shards?

\==========================

write-heavy or read-heavy

read-heavy

B-tree

single-leader

DynamoDB/spanner style 

snapshot isolation

multi-version concurrency control

use some "version vectors""?

aim for sequential consistency

write-heavy

LSM-tree 

leaderless

cassandra/riak/scylla styled

cosmos DB is also some inspiration  here

probably still-snapshot isolation & multi-version concurrencycontrol

( requestrouter stuff might be -different)

just-aim for causal-consistency,

and do risk & cosmos DB's write conflict resolution specifying thing

ticketmaster/distributed linked list/"flash sale" oriented DBwrite-heavy and total ordering is important)

meaning aim for sequential consistency

BUT,we're super write-heavy

single-leader

LSM-tree


<a name="fug2-1707454709063"></a>request router is likely going to stay looking like theread-heavy approach

<a name="g7yu-1707229908505"></a>**.what is total ordering(ordering first 100 custormer)**

Can- you explain -whats total ordering use case briefly?

ordering all the records of the database, for example: flashsales on amazon.com  - first 100 customers will be luckers to get free iphone;  

fairness"

I am going to be using  "weak fairness"

which is the difference between"sequential consistency" and"linearizability - seattle to your IDC 100km, be later 5 sec than others which approach your IDC;

there's actually multiple there.jepsen.io/consistency

------by the way----

distributed system node serizability rank

https://jepsen.io/consistency  

when network down

Total Available

Sticky Available

<a name="qzxn-1707454693080"></a>Unavailable

<a name="ebxf-1707230056989"></a>**.why single leader()**

why single-leader?

simplifies write conflicts

concurrent-writes are imposssible when PostgreSQL is set to serializable-isolation-level

zookeeper -and- etcd or-strongly consistent- KV storesetcd is used by kubernetes internally

<a name="llq0-1707455190492"></a>aim for sequential consistency

<a name="ttmg-1707230034624"></a>**.request router**

\- my opinion is that it is likely mycat;

"request router"

`             `strong consistent kv store(cassadra)

`                             `|

client   -        "request router"    -    (partion1) postgreSQL shard(leader node)  -  sychronus read raplica(follower) -gossinping  read raplic

`                                                `|

`                                           `(partion2) postreSQL shard(leader)     



Strong Read Consistency  :  do request to leader, leader will expi

<a name="tuet-1707455232935"></a>Eventual Consistyency  : do request to  raplica

<a name="aftd-1707229925082"></a>**.variations**

<a name="uk2k-1707457488655"></a>**1.Failover handing**

<a name="btbd-1707457496651"></a>**2.Reblancing after new node added**

<a name="moaq-1707457524278"></a>**3.Leaderless for heavy write-shard**

<a name="wyvq-1707458882987"></a>**4.TicketMasler (and total ordering is necessary**

variations 1-Failover handling

1\.detect the failur

`    `From "Database leader->"phi accruar

2\.do the leader election and switch over to the new leader

1\.detect the failur

2\.prmote The syrchronous read replica(this is our leader election we're doing the 'ring') in the kv store

variation 1 reblancing after new node added

1\.start gossiping data over to the new machines

2\.the machines become sychronuse read replica 

`    `for the partition that they should be promoted to 'leader' of

3\.promotes one of the machines to 'leader' (in kv store)

4\.it is now being router write request;

variation 2 leaderless for heavy write (No total ordering support only causal consistency)

write scenario: wirte to machine 1 ,machine 2

`    `gossiping -> concurrent write is detected!! now we have to do a write conflict resolution

`    `under Last-Write-Win. you just take the write from machine 2 . and that becomes the value on both machines(cassandre dose this)

`    `with  cosmosDB and (IIRC) Riak, you can specify the conflict resolution strategy instead of the defualt of LWW



FOR-THIS-SCENARIO,

basically just follow Variation· 1, but-shard the hell out of.it( fewer read: replicas necessary)

and use· LSM-trees

and - use the serializable isolation level on each leader node

Variation 3-TicketMasler (and total ordering is necessary)->just copy variation 1 but with tollowing changes

-use LSMM-trees

\- fewer read replicas necessary- shard the hell out of it

<a name="m8yp-1706969251706"></a>- seriazation isolation level

<a name="sswx-1706094478181"></a>**===数据密集型应用===**

<a name="ef5t-1644230945318"></a>数据系统基础

<a name="unbe-1677787447006"></a>**第一部分 数据系统的基石**

<a name="kwfx-1677787447007"></a>**1.可靠性、可拓展性、可维护性能**

<a name="zrzj-1642646974315"></a>小结：一个应用必须满足各种需求才称得上有用

<a name="lykw-1644227240038"></a>**-功能性需求：CRUD**

<a name="b2tu-1644227249556"></a>**-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性**

.数据密集型 data intensive -cpu 很少成为此类应用的瓶颈

.计算密集型 compute intensive  

<a name="kvjx-1708356889532"></a>.database   、cache 、 search indexes 、stream processing 、 batch processing

<a name="qqm5-1644227303238"></a>**.可靠性：**

<a name="vdpc-1699843965882"></a>以为着即使发生故障，系统也能正常工作。

<a name="mk9e-1644227360160"></a>故障可能发生在硬件（通常是随机和不相关的）

<a name="w7by-1644227387308"></a>软件（通常是系统性的bug,很难处理）

<a name="dozl-1644227415061"></a>人类（不可避免的时不时出错）

<a name="fvz4-1644227444254"></a>**容错技术**可以对终端用户隐藏某些类型的故障。

故障fault  容错fault-tolerant 失效failure

<a name="wgkl-1708269791452"></a>阻止错误 prevent error

<a name="7xms-1644228225080"></a>**硬件故障**

<a name="iw87-1708357694946"></a>hardware faults

<a name="3gfd-1708357730326"></a>硬盘的平均无故障时间mean time to failure 约为10~50年

<a name="yusj-1708357802977"></a>aws虚拟机实例不可用缺无任何告警，因为设计优先考虑灵活性flexibility 和 弹性 elasticity,而非单机可靠性

<a name="dfpv-1708357497902"></a>**软件错误**

<a name="ptxr-1708357908223"></a>系统性错误 systematic error

<a name="ybic-1708358007856"></a>测量监控系统行为，那么系统可以在运行时不断自检，并在出现差异desrepancy时报警

<a name="drpl-1708357507365"></a>**人为错误(如何让系统变得可靠)**

<a name="eb1v-1708358093033"></a>既然人类不可靠，

<a name="pqmh-1708523552230"></a>**如何让系统变得可靠：**

<a name="i4we-1708358144376"></a>**。最小化犯错机会的方式设计系统,  但如果限制太多，人们可能会忽略它们的好处而绕开，很难把握其中微妙的平衡**

<a name="xzfa-1708358243121"></a>**。在易错地方和可能导致失效的地方解耦decouple,提供非生产环境沙箱sandbox-虚拟化环境，隔离真实系统进行安全测试**

<a name="9jaa-1708358634289"></a>**。彻底的测试，单元测试，集成测试，手动测试，自动化测试覆盖边缘场景corner case.**

<a name="zlp4-1708358698137"></a>**。滚动发布，快速回滚**

<a name="40us-1708358954660"></a>**。配置详细和明确的监控**

<a name="o66x-1708358967000"></a>**。良好的管理和充分的培训。一个复杂而重要的方面，但超出本书的范围**

<a name="x7co-1708357515795"></a>**可靠性有多重要**

<a name="nc0w-1708358745350"></a>**造成客户巨大损失-阿里云宕机造成的用户损失**

<a name="qopp-1708358856827"></a>**家长将孩子照片存储在你的应用李，数据库损坏，客户有何体验，他们可能会知道如何从备份恢复吗？**

<a name="uzlx-1708358804665"></a><a name="dsae-1708357483848"></a>**.可扩展性：** 

<a name="t59j-1699843967201"></a>意味着即使在增加负载的情况下也能保持性能的策略。

<a name="gqfn-1644228379215"></a>为了讨论可拓展性，首先要定量描述负载和性能的方法。

<a name="krij-1644228405843"></a>推特主页时间线的例子，介绍描述负载参数，并将响应时间百分点作为衡量性能的一种方式。头部阻塞、尾部延迟。(有很多人通过将工作负载迁移到低延迟、自适应的GC来控制尾部延迟-infoQ java趋势)

<a name="bynr-1644228470161"></a>在可扩展的系统中可以添加**处理容量** 以在高负载下保持可靠。

<a name="lm8f-1708356469121"></a><a name="eg4z-1708359118801"></a>服务降级degradation的一个常见原因是负载的增加。可拓展性Scalability是用来描述系统应对负载增长能力的术语。

<a name="vja4-1708356470840"></a>**描述负载(tps-推特主页时间线扇出-查询性能优化)**

负载参数load parameters

推特2012年11月发布的数据，主要两个业务：

发布推文：

`    `用户可以向粉丝发布新消息（平均4.6k 请求/秒 ， 峰值超12k 请求/ 秒） TPS

主页时间线：

`    `用户可以查阅他们关注的人发布的推文（300K 请求/秒） 

处理每秒12k次的写入还是很简单的，拓展挑战主要来自扇出（fan-out),请求自己的主页时间线(查看关注的人的推文)。

方法1： 通过正常sql  select user.\*, tweets.\* form tweets join user join follows  查找关注的人推文

方法2： 为每个用户的主页时间线维护一个缓存 -根据时间线缓存用户id和推特id

4\.6k TPS 写入推特 -> 345K tps 写入主页时间线缓存 -> 300K tps查询主页

`    `推特的第一个版本使用了方法1，但系统很难跟上主页时间线查询的负载。所以转向方法2.方法2效果更好，发推频率比查询主页时间线的频率几乎低了两个数量级，这种情况下，最好在写入时做更多的工作，而在读取时做更少的工作。

`    `而方法2的缺点是，发推需要大量的额外工作。平均来说，一条推文会发往约75个关注者，所以每秒4.6k的发推写入，变成对时间线缓存每秒345k的写入。30m的粉丝，意味着一条推文需要3千万次的写入，及时完成是一个巨大挑战，且推特尝试在5秒内向粉丝发送推文(通知)。

<a name="mnug-1708269817280"></a>    推特轶事的最终转折：现在已经稳健的实现了方法2，逐步转向两种方法的混合。大多数用户发的推文会被扇出写入其粉丝主页时间线缓存中，名人则除外。当用户读取主页时间线时，分别获取每位名流的推文，再与用户的主页时间线缓存合并。

<a name="s6un-1708356581594"></a>**描述性能**

<a name="fcez-1708523606684"></a>**吞吐量throughput**

<a name="k30f-1708523620292"></a>**响应时间 response time.**

<a name="bogk-1708523658968"></a>**响应时间的高位百分点（也称为尾部延迟tail latencies**

.增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？

.增加负载参数并希望保持性能不变时，需要增加多少的系统资源？

如何描述系统性能：

hadoop这样的批处理系统，通常关心的是吞吐量throughput,即每秒可以处理的记录数量

通常更重要的服务是响应时间 response time. (延迟latency，休眠latent)

算术平均值arithmetic mean ,典型typical ,百分位点percentiles, 中位数median

响应时间的高位百分点（也称为尾部延迟tail latencies）非常重要,直接影响用户服务体验。amazon响应时间要求时以99.9百分位点为准，即使它只影响一千个请求中的一个

优化99.99百分位点（一万个请求中最慢的一个）则认为太昂贵了

当一个请求需要多个后端请求时，单个后端慢请求就会拖慢整个终端用户的请求-高扇出导致的不可确定性增加

排队延迟queueing delay    头部阻塞head of line blocking     

纵向扩展 scaling up  /垂直扩展vertical  scaling     

横向拓展scaling out   /水平扩展 horiziontal scaling 

<a name="tuzo-1708355786743"></a>无共享 shared-nothing   负载极难预测highly unpredictable of load    无状态服务stateless services

<a name="k1dg-1708355783343"></a>**.可维护性：**

<a name="vg1v-1699843968229"></a>可维护性实质上是关于工程师和运维团队生活质量的。

<a name="mq1x-1644231096441"></a>良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。

<a name="qj5f-1644228656997"></a>良好的可操作性意味这对系统的健康状态具有良好的可见性，并拥有有效的管理手段。

遗留legacy    可操作性operability    简单性simplicity    复杂度complexity    可演化性evolability

可拓展性extensibility    可修改性modifiability    可塑性plasticity    可见性visibility    烂泥堆a big ball of mud

<a name="hjaw-1708362268869"></a>敏捷agile    tdd 

<a name="jufm-1677787447008"></a>**2.数据模型与查询语言**

<a name="guby-1644404619396"></a>本章小结：数据模型时一个巨大的课题，在本章中，我们快速浏览了各种不同的模型。以便激起兴趣，更多的了解**最适合你的应用的需求模型**。（数据库选型）

<a name="o6we-1644404838474"></a>在历史上，**数据最开始被表示为一颗大树（层次型结构**），但是这不利于表示多对多的关系，所以发明了

<a name="pgu6-1699844351041"></a>**-关系模型**

<a name="jayo-1699844352979"></a>来解决这个问题。

<a name="kfpd-1644410618294"></a>**-NoSql (es,redis)**

<a name="uzbw-1699844301003"></a>**通常**不会为存储的数据强制一个模式，这可以使应用程序更容易适应不断变化的需求。

<a name="0p23-1644410807294"></a>**1.文档数据库:MongoDB**

<a name="9rlb-1699844336493"></a>数据通常是自我包含的，而且文档之间的关系非常稀少

<a name="09bl-1644410666587"></a>  **2.图形数据库 ：**

<a name="imif-1699844337670"></a>与文档数据库相反的场景-任意事务都可能与任何事务相关联

<a name="6fxw-1644410924417"></a>**-其它模型(基因序列)**

<a name="he0m-1699844309707"></a>** 基因组 通常需要 **序列相似性搜索，意味着一**个很长的字符串，并在一个拥有类似但不完全相同的字符串的大型数据库中寻找匹配。这里所描述的数据库都不能处理这种用法。研究人员编写了想GenBank专门的基因组数据库软件。

<a name="opsf-1644411138194"></a>                 粒子物理学家进行大数据类型的大规模数据分析。粒子对撞机（LHC）这样的项目可以工作在数百亿兆字节的范围内。这样的规模下，需要指定解决方案来阻止硬件成本的失控。

<a name="pnul-1644935322505"></a><a name="sm0u-1677787447009"></a>**3.存储与检索**

<a name="ycte-1644935336049"></a>本章小结：数据库如何处理存储何检索。将数据存储在数据库中会发生什么，再次查询数据库会发生什么？

<a name="bivs-1644935398311"></a>在高层次上，存储引擎分两大类：

<a name="bhcv-1644935436804"></a>**-优化事务处理（OLTP）transaction** 

<a name="tbhw-1699844517372"></a>**1.OLTP系统通常面向用户，大量的请求。**

<a name="fnev-1644935714127"></a>**2.磁盘寻道时间往往是这里的瓶颈。**

<a name="cjwp-1644935609899"></a>**3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。**

<a name="jg7s-1699844443567"></a>**-优化分析（OLAP）analys**

<a name="n8me-1644935726822"></a>    OLTP数据 copy and translatin 转换为适合业务分析的数据副本 to 数据仓库（OLAP）

<a name="3cwp-1644935731444"></a>OLAP**数据仓库**和类似的分析系统不太知名，因为只要由业务分析人员使用，而不是由最终用户使用

<a name="s6pt-1644935799372"></a>处理比OLTP系统少得多得查询量，但是每个查询通常要求很高，短时间内扫描百万条记录。

<a name="cyhe-1644935862917"></a>磁盘带宽（不是查找时间）往往是瓶颈，列式存储是这种工作负载的流行解决方案。

<a name="pjd1-1703887811615"></a>**1.列式储存(投影操作，压缩技术，聚合过滤)**

OLAP TB,PB级别的数据(几百列)情况下，索引的相关性就会下降很多，磁盘带宽往往是瓶颈

解决方案-列式存储(将表右旋90度，每行为单个列文件)

1\.将表头设置为列文件名，文件存储单列内容、

2\.如需第23行，则将需要的列文件的第23项形成表的第23行

SSN            Name    Age    Addr    city    st    

101259797    SMITH     88    899 FIRST ST

892375862

318370701

block 1 SSN

101259797|l892375862|318370701|468248180|378568310/231346875|317346551|770336528|277332171


优势：

.投影操作：仅需检索所需的列，大大减少读取的数据量。

.压缩技术：通常采取高度优化的压缩技术。-相邻的数据通常具有相似的值。减少存储空间，提高查询性能

.向量化处理：通常采用向量化处理，意味着可以一次操作整个数据向量，而不是逐个处理行。

-并行处理和SIMD指令集优化非常有利

.聚合操作：在SUM、AVG等聚合操作上表现良好

.过滤操作：特定列过滤更快

.分析查询：部分查询而不是全部

<a name="kg2a-1703885936042"></a>Apache: Cassandra、 HBase

<a name="8sgm-1644935924013"></a>**-OLTP两大主流学派的存储引擎：**

<a name="i55y-1644935943748"></a>**1.日志结构学派**

<a name="4nm8-1644935988277"></a>只允许附加到文件和删除过时文件，但不会更新已经写入的文件。（高效，顺序IO?）

<a name="6ymo-1644936029696"></a>Bitcask, SSTables, LSM树，LevelDB, Cassandra, HBase, Lucene等都属于这个组。

<a name="h3il-1644935977285"></a>**2.就地更新学派**

<a name="2w0c-1644936091115"></a>将磁盘视为一组可以覆盖的固定大小页面。（随机IO?）

<a name="hpzs-1644936142472"></a>B树是这种哲学的最大例子，被用在所有主要的关系数据库中，还有许多非关系数据库。

<a name="fil5-1644936170765"></a><a name="vypn-1644936170925"></a>日志结构的存储引擎是相对较新的发展，他们的主要想法是，系统地将随机访问写入顺序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短的介绍。

<a name="a5tj-1644936526197"></a>然后我们从存储引擎的内部绕开，看看典型的数据仓库的高级架构。这一背景说明了为什么分析工作负载和OLTP差别很大：

<a name="nyml-1644936619727"></a>当您的查询需要在大量（几百列）的行中顺序扫描时，索引的相关性就会下降很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读取的数据量。我们讨论了列式存储如何帮助实现这一目标。

<a name="2akd-1644935679338"></a>作为一名应用开发人员，如果您掌握了有关存储引擎内部知识，那么就能更好地那种工具最适合您的特定应用程序。如果需要调整库的参数，这种理解可以让您设想一个更高或者更低的参数可能会产生什么效果。

<a name="ohao-1644936963029"></a>尽管本章不能让你成为一个特定存储引擎的调参专拣，但它至少有大概率使你有了足够的概念与词汇储备去读懂数据库的文档，从而选择合适的数据库。

<a name="en4q-1644936942676"></a><a name="lbs1-1677787447010"></a>**4.编码（序列化）与演化(XML,JSON,CSV)**

<a name="18rw-1644940257792"></a>在本章中，我们研究了将数据结构转换为网络中的字节或磁盘上的字节的几种方法。编码的细节影响其效率，更重要的是应用程序的体系结构和部署它们的选项。

<a name="bfvx-1644940365841"></a>特别是，许多服务需要支持滚动升级（灰度发布），其中新版本的服务逐步部署到少数节点，而不是同时部署到所有节点。滚动升级允许在不停机的情况下发布新版本的服务（从而鼓励在罕见的大型版本上频繁发布小型版本），并使部署风险降低（允许在影响大量用户之前检测并回滚有故障的版本）。这些属性对于可演化性，以及对应用程序进行更改的容易性都是非常有利的。

<a name="w4qv-1644940598057"></a>在滚动升级期间，或出于其它原因，我们必须假设不同的节点正在运行我们的应用程序代码的不同版本。因此，在系统周围流动的所有数据都是以提供向后兼容性（新代码可以读取旧数据-服务端）和向前兼容性（旧代码可以读取新数据-客户端）的方式进行编码是重要的。我们讨论了几种数据编码格式极其兼容性：

<a name="zw4l-1644940805237"></a>编程语言特定编码仅限于单一编程语言，并且往往无法提供向前和向后兼容性。

<a name="1zx9-1644940881501"></a>JSON, XML和CSV等文本格式非常普遍，其兼容性取决于如何使用它们。他们有可选模式语言，这有时是有用的，有时是一个障碍。这些数据格式对于数据类型有些模糊，所以你必须小心数字和二进制字符串。

<a name="q8m7-1644942050475"></a>像Thrift, Protocol Buffers和Avro这样的二进制模式驱动格式允许使用清晰定义的向前和向后兼容性语义进行紧凑，搞笑的编码。这些模式可以用于静态类型语言的文档和代码生成。但是，他们有一个去缺点，就是在数据可读之前需要对数据进行解码。

<a name="hqvm-1644942192088"></a>我们还讨论了几种数据流的几种模式，说明了数据编码是重要的不同场景：

<a name="c94y-1644942236778"></a>数据库，写入数据库的进程对数据进行编码，并从数据库读取进程对其进行解码

<a name="kcmv-1644942289426"></a>RPC 和 REST API, 客户端对请求进行编码，服务器对请求进行解码并对相应进行编码，客户端最终对相应进行解码。

<a name="nvcq-1644942366178"></a>异步消息传递（使用消息代理或参与者），其中节点之间通过发送消息进行通信，消息由发送者编码并由接收者解码。

<a name="oxsf-1644942481249"></a>我们可以小心地得出这样的结论：向前兼容性和滚动升级在某种成都上是可以实现的。愿您的应用程序的演变迅速，敏捷部署。

<a name="rmsh-1646310193756"></a><a name="4p9n-1677787447012"></a>**第二部分 分布式数据**

<a name="gr0m-1646310278506"></a>本章考察了复制的问题，复制可以用于几个目的：

<a name="o4ag-1646310813851"></a>**1.高可用性/容错**

<a name="r7ua-1646310833943"></a>即使在一台机器（或多台机器，或整个数据中心）停机的情况下也能保持系统正常运行

<a name="snwm-1646310894841"></a>**2.断开连接的操作**

<a name="x2dq-1646310900787"></a>允许应用程序在网络中断时继续工作

<a name="evly-1646310918322"></a>**3.减少延迟(节点近)**

<a name="iz8f-1646310928916"></a>将数据放置在距离用户较近的地方，以便用户能够更快地与其交互

<a name="itsh-1646310968967"></a>**4.可拓展性**

<a name="ncek-1646310974776"></a>能够处理比单个机器更高的读取量可以通过对副本进行读取来处理

<a name="ybmg-1646311013702"></a><a name="a6ti-1646311014184"></a>尽管是一个简单的目标-在几台机器上保留相同数据的副本，但复制确实一个非常棘手的一个问题。它需要仔细考虑并发和所有可能出错的事情，并处理这些故障的后果。

<a name="cpjg-1646311086181"></a>至少，我们需要处理不可用的节点和网络中断（甚至不考虑更隐蔽的故障，例如由软件错误导致的无提示数据损坏）。

<a name="gjis-1708362947856"></a>**.拓展至更高的载荷**

<a name="mgia-1708362999715"></a>**垂直扩展scale up ：购买更强大的机器 cpu**

<a name="pdo8-1708363038596"></a>**共享内存架构shared-memory architecture：许多处理器、内存和磁盘再同一操作系统下相互连接，共享内存和磁盘**

<a name="wgwl-1708363065800"></a>**共享磁盘share-disk architecture：独立处理器和内存，数据存储在机器之间共享的磁盘阵列上，磁盘通过快速网络连接。数仓**

<a name="klw2-1708363340866"></a>**无共享架构**

<a name="z1yn-1708363411467"></a>share nothing/scale out: 水平拓展，单独节点，通过网络连接。

<a name="gbgq-1646311175182"></a>**.复制VS分区**

复制replication  副本replica

<a name="e95h-1708363467520"></a>分区partitioning   分区partition/分片shard

<a name="gd4q-1708363438406"></a>**5.复制**

<a name="ekkr-1708364726154"></a>-复制的三种主要方法：几乎所有分布式数据库都使用这三种方法之一

<a name="wg6v-1646311185918"></a><a name="ftqb-1646311200843"></a>**2.多主复制**

<a name="ak8v-1646311613462"></a>客户端发送每个写入到几个领导节点之一，其中任何一个都可以接受写入。领导者将数据更改事件流发送给彼此以及任何跟随着节点。

<a name="4xbf-1646311410600"></a>**3.无主复制**

<a name="b6zn-1646311685371"></a>客户端发送每个写入到几个节点，并从多个节点并行多去，以检测和纠正具有陈旧数据的节点。

<a name="tyus-1646311850435"></a><a name="dzsw-1646311850942"></a>单主复制是非常流行的。多领导和无领导复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。

<a name="sgmj-1646311002454"></a>我们讨论了一些有助于决定应用程序在复制滞后时的行为的

<a name="w1xl-1708441626775"></a><a name="eumz-1646312681469"></a>多领导者和无领导者复制方法所固有的并发问题：允许多个写入并发发生冲突。研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者他们是否同时发生。

<a name="xukg-1646312787143"></a>还谈到了通过合并并发更新来解决冲突的方法。

三种流行的变更复制算法：

单领导者single leader多领导者multi leader 无领导者leaderless 几乎所有分布式数据库都使用这三种方法之一。

<a name="hu8h-1708441083912"></a>最终一致性eventual consistency    读己之写read your write        单调读monotonic read

<a name="9hbs-1708441077626"></a>**.领导者与追随者-单主复制**

<a name="aucb-1708528116000"></a>**客户端将所有写入操作发送到单个节点（领导者），该结点将数据更改事件流发送到其它副本（追随者）。**

<a name="wgge-1646311567456"></a>**读取可以再任何副本中执行，但从追随者读取可能是陈旧的 （最终一致性问题）**

副本replica    基于领导者的复制leader based replication也称主动/被动active/passive  或 主/从master/slave复制

领导者leader    主库master primary    

<a name="evej-1708441699768"></a>追随者followers      只读副本read replicas    从库slaves 次要sencondaries  热备hot standby    复制日志replication log    变更流change stream

<a name="cbey-1646310922523"></a>**.同步复制与异步复制**

同步synchronously    异步asychronously

所有从库设置为同步复制：慢，低可用

<a name="tyba-1708441996611"></a>半同步semi synchronous 即至少在两个节点上拥有最新的数据副本：主库和同步从库    持久durable

<a name="j5o0-1704983008475"></a>**.设置新从库(快照复制+caught up binlog)**

增加副本数量 / 替换失败节点；如何确新的从库拥有主库数据的精确副本

.锁库后同步数据/备份  -mysql全局锁同步数据，低可用

.非阻塞性同步，快照同步，步骤如下：        -其实就是先快照复制/备份某个时间点前的数据，再通过binlog lsn同步后续变更

1\.在某个时刻获取主库的一致性快照 如mysql innobackupex

2\.将快照复制到新的从库节点

3\.连接主库，并拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。PostgreSQL称为日志序列号log sequence number-LSN，mysql将其称为二进制日志坐标binlog coordinates

4\.当从库处理完快照之后积压的数据变更，我们说它赶上caught up了主库。现在可以继续处理主库产生的数据变化了

<a name="rv7k-1708442520512"></a>-question :为什么不直接用binlog设置新从库？因为binlog日志文件占磁盘空间大，为了释放磁盘空间，会定时清理掉久远的数据。而快照备份原理则直接利用数据库数据文件进行复制/备份(如备份当前的数据)，参考mysql 快照备份。

<a name="bcod-1708442233018"></a>**.处理宕机节点**

<a name="5ufz-1708443850274"></a>**从库失效：追赶恢复**

<a name="r3tg-1708443904810"></a>比较容易恢复，从库可以从日志中知道，发生故障前处理的最后一个事务。

<a name="nsxx-1708443979184"></a>因此，从库可以连接到主库，并caught up后像之前一样继续接收数据变更流。

<a name="udix-1708443860752"></a>**主库失效：故障切换failover**

<a name="w3sj-1708523445192"></a>**自动切换步骤：1.确认主库失效**

<a name="y3qn-1708523480847"></a>**2.选举新主库：共识**

<a name="wua6-1708523497956"></a>**3.配置系统启用新主库**

<a name="z7mn-1708523814309"></a>**failover的麻烦：1.异步复制数据丢失**

<a name="mnjx-1708523836932"></a>**2.自增主键冲突**

<a name="dbhg-1708523873194"></a>**3.脑裂split brain**

<a name="561v-1708523878338"></a>**4.如何设置超时**

相当棘手：故障切换failover

其中一个从库需要被提升为新的主库，重新配置客户端，将写操作发送给新的主库，其他从库从新主库中拉取变更流。

自动故障切换可以手动进行（通知管理员，采取必要步骤创建新主库）

自动进行：

1\.确认主库失效。崩溃/超时

2\.选择新的主库。选举election 或 由之前选定的控制器节点controller node 来制定新的主库。主库最佳人选通常是拥有旧主库最新数据副本的从库。让所有节点同意一个新的领导者，是一个共识consensus问题

3\.重新配置系统以启用新主库。客户端需要将写请求发送给新主库（请求路由）。如果老主库回来，可能仍然认为自己是主库，系统需要确保就主库认可新主库，成为一个从库。

故障切换会出现很多大麻烦

1\.如果异步复制，可能会丢失数据

2\.如果数据库需要与其他外部存储相协调，那么丢弃写入内容是极其危险的操作。

github的一场事故中，一个过时的mysql从库被提升为主库，使用自增id作为主键，新主库计数器落后于老主库。重新分配一些id作为主键。这些主键在redis中使用。导致mysql和redis中数据产生不一致。导致一些私有数据泄露到错误用户手中。-是不是清缓存就可以,且详细验证

3\.脑裂split brain,出现两个节点都以为自己是主库。如果两个主库都接收写操作，却没有冲突解决机制，数据可能会丢失或损坏。

可以设计当检测到两主库，可以设置关闭其中一个节点，但粗糙的机制可能导致两个节点都被关闭

<a name="uv1j-1708443830595"></a>4.主库超时时间如何配置，如过在峰值中切换，可能让情况变得更糟。

<a name="8mem-1708442228760"></a>**.复制日志的实现**

<a name="k8yo-1708524004340"></a>**基于语句的复制(每个写入请求语句statment)**

<a name="hcqe-1708524155632"></a>**记录每个写入请求语句statment，语句日志传输给从库**

<a name="9xml-1708524182083"></a>**问题：非确定函数nondeterministic, NOW()  RAND()**

<a name="il4a-1708524271564"></a>    **自增列- 造成差异**

<a name="azmh-1708524331636"></a>**副作用的语句：用户自定义函数，触发器，存储过程**

<a name="rcfb-1708524371120"></a>**解决: 用固定值替换**

<a name="6uy2-1708524426849"></a>  **如语句存在任何不确定性，切换到基于行的数据**

<a name="ityn-1708524645902"></a><a name="rnmz-1708524013585"></a>**传输预写式日志(WAL)**

<a name="hze4-1708524498278"></a>**日志存储引擎SSTables LSM树**

<a name="qzop-1708524541132"></a>**磁盘块的B树  WAL, 崩溃恢复**

<a name="rh9a-1708524641979"></a><a name="a3ng-1708524040960"></a>**逻辑日志复制(基于行)**

<a name="jiiu-1708524648209"></a>**binlog**

<a name="ezoi-1708524083973"></a>**基于触发器的复制**

<a name="nyjo-1708527704881"></a><a name="jamd-1708524904250"></a>**.复制延迟问题(解决方法都是反分布式，或者趋于单机一致性。数据一致性模型：<https://jepsen.io/consistency>)**

<a name="w5nz-1708525244967"></a>**读己之写(读主库或带写时间戳查询)**

<a name="25nj-1708526407050"></a>**写后从旧副本读取数据-未同步**  

<a name="4st1-1708525569674"></a>**解决：写后读read after write 一致性 或叫做 read your write consistency 防止这种异常**

<a name="v4r0-1708525736897"></a>**1.都从主库读。适用仅由用户本人编辑的数据，如个人信息。大部分内容从主库读不适用，扩容读无效果**

<a name="vqjs-1708525818133"></a>**2. 扩容读需要保证更新时间，监控复制延迟，防止滞后超过一分钟从从库发出查询**

<a name="nmrh-1708525971734"></a>**3. 客户端记录写入时间戳，系统确保从库提供查询时，版本时间已覆盖，否则从另一个从库读，或者等待caught up-  等待不就相当弱可用状态，且时钟不可靠**

<a name="wmu9-1708526095856"></a>**4. 副本在多个数据中心，复杂度高，都需经过主库IDC**

<a name="o5gj-1708702027717"></a><a name="kwrd-1708525264596"></a>**单调读(基于id散列路由同一副本)**

<a name="npwe-1708527802311"></a>**先读到最新副本，后读到旧副本感觉数据消失**

<a name="4cn0-1708526272081"></a>**A看到B评论后消失，时光倒流moving backward in time** 

<a name="drqk-1708526396300"></a>**解决：单调读monotonic reads总是从同一个副本进行读取(基于用户散列id，如果副本失效则重新路由)**

<a name="s6u3-1708526566643"></a>  **比强一致性(同步复制/类比单机)弱，比最终一致性更强**

<a name="hfrl-1708527791940"></a><a name="bfps-1708525268614"></a>**一致前缀读(因果关系写到相同分区)**

<a name="q7p0-1711363121071"></a>**consistent prefix reads**

<a name="rqcm-1708527879976"></a>**不同分片副本同步先后问题导致读顺序错误**

<a name="bwov-1708526677620"></a>**分区partition/分片sharded数据库中的一个特殊问题，全局写入顺序**

<a name="7e9o-1708526727984"></a>**分区主库1写入 A:你吃饭了吗？ 分区主库2写入B:没有。 分区1副本同步主库1落后分区2副本同步主库2    C读取1副本: 没有，后读取2副本。你吃饭了吗？**

<a name="turn-1708527108521"></a>**解决：确保因果关系都写入到相同分区**

<a name="yygl-1708702065256"></a><a name="a2la-1708525420248"></a>**复制延迟解决方案**

<a name="x8ng-1708527233293"></a>**趋于反分布式，局部或者部分看做一个单机，做到强一致性**

<a name="gecf-1708527304184"></a>**写后读。**

<a name="zsq6-1708527307246"></a>**数据库通过事务提供强大保证。**

<a name="m7de-1708525314549"></a><a name="pbfd-1708528009698"></a>**.多主复制(主主复制，互为副本-写冲突。多主复制被认为是危险的领域)**

<a name="kxkx-1708441627686"></a>**多主复制的应用场景**

<a name="xrso-1708700002291"></a>**运维多个数据中心(IDC-主主间复制需要处理写冲突）**

<a name="06t6-1708700132681"></a>**性能(多活配置，写操作在本地IDC处理，其他IDC异步复制，性能更好)**

<a name="9sww-1708700267631"></a>**容忍IDC停机**

<a name="dtkl-1708700295371"></a>**容忍网络问题(临时的网络中断不会妨碍正在写入的处理)**

<a name="knxa-1708700020273"></a>**需要离线操作的客户端(支持多个终端离线操作couchDB)**

<a name="hvwb-1708700115895"></a>**协同编辑**

<a name="kjs9-1708701808580"></a><a name="fdot-1708700612321"></a>**处理写冲突(A将标题从1改2,B将1改3)**

<a name="u8bc-1708700824251"></a>**同步于异步冲突检测**

<a name="wfgd-1708700957597"></a>**同步：单主程序复制 - 不允许每个副本独立接受写入**

<a name="x6is-1708701017804"></a>**异步：独立接受写入- 异步检测，但为时已晚**

<a name="xg2a-1708700840681"></a>**避免冲突(特定记录写入都通过同一个领导者，主库切换或者用户迁移至更近的主库时会有同时写入的可能性)**

<a name="ucfn-1708700844474"></a>**收敛convergent至一致的状态(副本主库和其副本在复制完成时收敛至一个相同的最终值)**

<a name="cbla-1708701376316"></a>**最后写入胜利LWW,last write wins- 给每个写入一个唯一id, 挑选最高ID的写入作为胜利者，并丢弃其他写入-数据丢失**

<a name="40po-1708701481447"></a>**为每个副本分配一个唯一ID,ID编号更高的具有高优先级。数据丢失**

<a name="p4m4-1708701593939"></a>**将值合并在一起**

<a name="8fcs-1708701611999"></a>**记录冲突，并编写解决逻辑代码。如通过提醒用户方式**

<a name="yrdi-1708700860148"></a>**自定义冲突解决逻辑**

<a name="t4i7-1708702160004"></a>**自定义冲突解决逻辑(complex)**

<a name="pdql-1708702370625"></a>**写时执行-后台处理**

<a name="sksk-1708702376293"></a>**读时执行-提供多版本用户选择，回写数据库**

<a name="4bqp-1708702425059"></a>**亚马逊购物车移除的商品重新出现**

<a name="6x4i-1708700867996"></a>**什么是冲突(两个领导者预订同一个会议室，7章看冲突实例12章看检测解决)**

<a name="xotk-1708702756879"></a><a name="o41a-1708702111509"></a>**多主复制拓扑**

<a name="5feh-1708702903239"></a>**环形，星型，all to all -mysql仅支持环形**

<a name="ddyu-1708702949257"></a>**问题：多主复制时，可能在某些副本中写入错误的顺序。like A写主库1，B写主库2，主库3先同步2，再同步1。类似一致前缀读。**

<a name="ghp3-1708703247102"></a>**解决：时间戳是不够的-不可靠时钟，使用一种称为版本向量(version vectors)的技术-检测并发写入**

<a name="fdrv-1708759283998"></a><a name="bfz8-1708759285067"></a>**无主复制leaderless**

<a name="cvru-1708759359537"></a>**Amazon的Dynomo系统。**

<a name="wf6o-1708759707666"></a>**Riak, Cassandra，Voldmort 也称为Dynamo风格。**

<a name="xpqf-1708760120711"></a>**类型1：客户端直接将写入发送到几个副本中**

<a name="pl2z-1708760121090"></a>**类型2：coordinator协调者节点代表客户端写入。**

<a name="x6pj-1708759817229"></a><a name="qgpe-1708760989905"></a>**当节点故障时写入数据库(仲裁写⼊，法定读取，并在节点中断后读修复。)**

<a name="zfuz-1708760396929"></a>**如果主从复制，主故障/重启系统更新 则需进行故障切换**

<a name="3soj-1708760452090"></a>**无主复制： userA set piture\_url   -> replica1 ok    Then version=7**

<a name="4f05-1708760543198"></a>           **user set piture\_url   -> replica2 ok  Then version=7**

<a name="ynls-1708759898772"></a>**user set piture\_url   -> replica3 offline  fail   version= 6**

<a name="e1ur-1708760618873"></a>    **userB get piture  :  rp3(version6) rp1(version7)  rp2(version7)  Than fix rp3 value to version7**

<a name="tyv3-1708760780373"></a> **读修复和反熵(失效节点重新连机后如何caught up)**

<a name="wjho-1708761214792"></a>**读修复like userB get piture fixed rp3**

<a name="xblj-1708761286988"></a>**反熵 后台进程不断查找副本之间的数据差异。Voldmort无反熵过程，副本可能丢失数据**

<a name="w3ia-1708761120623"></a> **读写的法定人数（仲裁）**

<a name="ddkz-1708761600371"></a><a name="oj1i-1708759830121"></a>**仲裁一致性的局限性-最终一致，更强的保证需要事务或共识**

<a name="cu5q-1708759841416"></a>**松散法定人数与带提示的接力**

<a name="kzki-1708761744887"></a>**运维多个数据中心-将写入发送到所有副本，仅需本地IDC内法定节点确认**

<a name="pt1k-1708759856530"></a>**检测并发写入**

<a name="mu89-1708761978075"></a>**Dynamo风格的数据存储，没有明确定义的顺序。**

<a name="dbni-1708763823783"></a>**userA set x=A   get x**

<a name="auce-1708763993783"></a>**rp 1 A ok    B unresponsive   A**

<a name="kteo-1708764011894"></a>**rp2 A ok   B OK  B**

<a name="9xyy-1708764019308"></a>**rp3 B ok A ok A**

<a name="esiv-1708702764305"></a>**userB set x=B** 

<a name="wd1i-1708764197180"></a>**最后写入胜利(丢弃并发写入)**

<a name="uzhw-1708874432788"></a>**LLW 无法确定真实排序，强制排序，选择最新的最大时间戳，并丢弃较早的任何写入.Cassandra唯一支持的方式，Riak可选**

<a name="henp-1708874594301"></a>**缺点：数据丢失** 

<a name="hzwp-1708764215825"></a>**此前发生的关系和并发**

<a name="3wp0-1708874672763"></a>**因果依赖(causally dependent)  如果B后发与A, 则B因果依赖A,** 

<a name="1wzv-1708875051673"></a>**如果是并发，则存在需要解决的冲突**

<a name="j2r6-1708764228505"></a>**捕获此前发生的关系**

<a name="vv7q-1708875756229"></a>**捕获两个客户端间的因果关系，同时编辑购物车(示例为单副本)**

<a name="zp0i-1708874374616"></a>**合并同时写入的值**

<a name="wawo-1708876272614"></a>**客户端需额外工作，合并并发写入的值来擦屁股。Riak称这些并发值兄弟(sibings)**

<a name="arlv-1708874381589"></a>**版本向量**

<a name="b1ov-1708700703636"></a>**所有副本的版本号集合称为版本向量(version vector)**

<a name="hdj8-1708940956650"></a><a name="dyz5-1709800112532"></a>**6.分区**

<a name="twd1-1709800204792"></a>**.分区与复制(分区与复制方案是独立的)**

<a name="efhv-1709800783933"></a>分区⽅案的选择与复制⽅案的选择是独⽴的，为简单起⻅，本章中将忽略复制。

<a name="cbpl-1709800862211"></a>图例：组合使用复制和分区，同一分区不同数据分片可为其他区分片主从。

<a name="fbqg-1709800263679"></a>**.键值数据的分区**

<a name="s7ju-1709801062977"></a>**偏斜skew：分区过多数据或过多查询**

<a name="u0d3-1709801107270"></a>**热点hot spot:高负载的分区**

<a name="lqbu-1709800332210"></a>**根据键的范围分区**

<a name="i2ju-1709801151406"></a>**Bigtable, HBase, RethinkDB 和 MongoDB2.4**

<a name="np00-1709801582805"></a>**按照一定的顺序保存键（SSTbale和LSM-树）**

<a name="evhb-1709801683166"></a>**按时间分区当日写过载（需加传感器保证日期+传感主键均匀分布）**

<a name="a1yy-1709800347130"></a>**根据键的散列分区(可将偏斜数据均匀分布)**

<a name="mdg4-1709801628016"></a>**不适合分区的简单哈希函数：java .hashCode-同键不同进程不同哈希值**

<a name="7rkg-1709802019859"></a>**一致性哈希consistent hashing:哈希键分区边界均匀间隔，也可伪随机选择（CDN均匀分配负载）。**

<a name="iktb-1709802309508"></a>**缺点：无序，低效范围查询(需发送到所有分区)**

<a name="zznq-1709802490074"></a>**折中方案：复合主键/组合索引。(uid,time).不同用户在不同分区，每个用户按时间搓顺序存储在单个分区上。**

<a name="ed70-1709800357523"></a>**负载倾斜与消除热点**

<a name="403a-1709802593546"></a>**数百万追随者做某事-大量写入同一个键**

<a name="wx5s-1709802730512"></a>**解决：火爆主键+随机数即可将主键分散为100个分区**

<a name="h0b7-1709802773377"></a>**缺点：数据合并，跟踪火爆主键。需权衡利弊。**

<a name="ekdv-1709800287975"></a>**.分片与次级索引**

<a name="n3vk-1709803239471"></a>**次级索引通常并不能唯一标识记录。**

<a name="q1u5-1709803293988"></a>**HBase Volde-mort为了减少实现复杂度放弃了次级索引。**

<a name="fhpr-1709803333585"></a>**Riak开始添加， 次索是Solr Elasticesearch 搜索的基石**

<a name="mwm0-1709800370635"></a>**按文档的二级索引**

<a name="ud7o-1709803718409"></a>**文档分区索引/本地索引**

<a name="zlhf-1709803740582"></a>**每个分区独立维护自己的二级索引。**

<a name="bkj3-1709803789802"></a>**查询发送所有分区，并合并所有返回结果，分散/聚集scatter/gather-容易导致尾部延迟放大。**

<a name="ghpm-1709803878421"></a>**缺点：可能使二级索引读取查询相当昂贵。**

<a name="itl0-1709800380617"></a>**根据关键词(Term)的二级索引**

<a name="8bw4-1709804016790"></a>**全局索引：覆盖所有分区数据的索引，也须分区。**

<a name="qc2d-1709913637902"></a>**关键词分区：关键词本身或它的散列进行分区。**

<a name="jmj8-1709913775261"></a>**优点：只需请求包含关键词的分区，读取更有效率**

<a name="i7kp-1709913825503"></a>**缺点：写入慢且复杂。需支持分布式事务。**

<a name="mv7j-1709913923874"></a>**理想下总是最新，实践中更新通常为异步。Amazon DynamoDB声称全局次级索引不到1s内更新。**

<a name="hpnd-1709800294747"></a>**.分区再平衡(reblancing)**

<a name="1f0n-1709914101899"></a>**吞吐量增加：加cpu**

<a name="vjb0-1709914129763"></a>**数据集大小增加：加磁盘和RAM**

<a name="smcd-1709914153882"></a>**机器故障：其他机器接管**

<a name="2efu-1709916803909"></a>**----------再平衡应满足--------------**

<a name="20wj-1709916807951"></a>**发生时：数据库应该继续接受读取和写入**

<a name="cxoi-1709916893371"></a>**节点之间只移动必须数据(分区)，以便快速再平衡，减少网络和磁盘io负载。**

<a name="cj8j-1709916938075"></a>**平衡后：存储，读取和写入公平共享**

<a name="cavd-1709800402611"></a>**平衡策略**

<a name="6f6z-1709800409866"></a>**反面教材：hash mod N**

<a name="anib-1709916997775"></a>**$hash(key)=22  22mod10..2  22mod 11...0  22 mod 9 ...4** 

<a name="anz7-1709917243580"></a>**节点需要转移秘钥及次数过多，过于昂贵。**

<a name="7ytl-1709917334275"></a>**解决：更换为只移动必须数据的方法。**

<a name="8l9j-1709800420954"></a>**固定数量的分区(加节点时分配分区)**

<a name="vmsm-1709917322722"></a>**新增/减少节点时，将现存部分数据转移到节点新增/现存节点(Riak,es,couchbase Voldemort使用这种再平衡）**

<a name="ktrd-1709917648400"></a>**适用：分区数量第一次建立时确定。**

<a name="vw7j-1709917692466"></a>**缺点：数据集总量大小难以预估时；分区大再平衡代价昂贵，分区小产生额外开销。**

<a name="eszc-1709921747523"></a>**分区大小与集群数据总量成比例增长**

<a name="tkjw-1709800428033"></a>**动态分区(适用键范围的分区)**

<a name="itsg-1709917825657"></a>**解决：使用键范围分区，固定边界的固定数量的分区不便。出现边界错误，手动重新去配分区边界将非常繁琐。**

<a name="05rm-1709917996703"></a>**动态分区：与B树类似，分区数据增长超过配置时将分成两区，大量数据删除分区缩小低于阈值则合并(HBase RethinkDB)**

<a name="v8uv-1709918235496"></a>**优点：分区数量适应总数据量-动态划分分区数量。**

<a name="cdjv-1709918375629"></a>**注意：空库分区开始，未绘制边界先验信息。所有写操作都必须由单个节点处理。其它节点空闲**

<a name="3uee-1709918458100"></a>**解决：配置一组初始分区-预分割 Hbase MongoDb。配需提前知道键分配方式。**

<a name="tlmq-1709918504615"></a>**MongoDB同时支持范围和哈希分区且动态分割分区。**

<a name="xqee-1709921516740"></a>**分区数量与数据集大小成正比**

<a name="kcsr-1709800432396"></a>**按节点比列分区**

<a name="xscz-1709920011051"></a>**新增节点，分区将变小。随机选择固定数量的现有分区进行拆分,最终获得公平的负载份额。cassandre ketama.**

<a name="pmpc-1709920187661"></a>**随机选择分区边界要求使用基于散列的分区-一致性哈希。**

<a name="a0l0-1709923420226"></a>**分区数量与节点数量无关**

<a name="w6ob-1709800443454"></a> **运维：手动还是自动平衡**

<a name="qobk-1709920292898"></a>**自动：与故障检测结合将十分危险，高负载节点响应慢被视为死亡被踢掉，重新平衡集群时其他超负荷节点可能级联失败**

<a name="a05n-1709920414620"></a>**手动人为监控+自动**

<a name="qxk3-1709800301840"></a>**.请求路由**

<a name="sd2e-1709921854453"></a>**分区再平衡后的服务发现(IP 端口)**

<a name="gliq-1709921964410"></a>**-------方案-------**

<a name="ibln-1709921978507"></a>**1.循环策略：Round-Robin load balancer，轮询节点看是否有请求的分区。**

<a name="gjxa-1709922094115"></a>**2.路由层：有中间层的路由决定请求的节点，由路由层负载均衡**

<a name="ukz9-1709922149547"></a>**3.要求客户端知道分区和节点的分配。客户端可直连节点。**

<a name="1c54-1709922244119"></a>**具有挑战性的问题。重要的是所有参与者都同意-否则将被发送到错误的节点，而不是正确处理。分布式中的共识协议-但很难正确实现。**

<a name="c7dc-1709922373821"></a>**Zookeper分区分配改变时通知路由层保持最新信息。**

<a name="ne7u-1709922442881"></a>**LinkedIn的Espressor使用Heix进行集群管理(依靠Zookeeper）**

<a name="41cr-1709922584212"></a>**Hbase,SolrCloud 和kafka也是用Zookeeper来跟踪分区分配。**

<a name="kg5k-1709922347652"></a>**Cassandra  Riaks节点间使用留言协议gossip protocol来传播群集状态变化。请求发送任意节点，该节点转发到含有请求分区的节点。模型增加数据库节点的复杂性。但避免对Zookeeper这类外部协调服务的依赖**

<a name="uohs-1709922928889"></a>**Couchbash不会自动再平衡，简化了设计。moxi路由层。**

<a name="h26t-1709800460759"></a>**执行并行查询**

<a name="oj8k-1709923010027"></a>**大规模并行处理(MPP,massively parallel processing)-数仓**

<a name="7qvp-1708523954496"></a>**7.事务**

<a name="wk3n-1710172857428"></a>**简化故障失败的机制-强大的事务！！**

<a name="pzui-1710172844274"></a>**故障**

<a name="znoj-1710172848152"></a>**崩溃**

<a name="vovu-1710172885568"></a>**网络中断**

<a name="sxty-1710172894683"></a>**多线程/客户端写入覆盖**

<a name="hbqy-1710172933218"></a>**读取无意义中间态数据**

<a name="jlng-1710172974900"></a>**多线程/客户端竞争**

<a name="5vwc-1710172919264"></a><a name="rhog-1710172796700"></a>数据库软件、硬件可能在任意时刻发⽣故障（包括写操作进⾏到⼀半时）。 -回滚，原子性  undolog， 

<a name="hfad-1704983671342"></a>应⽤程序可能在任意时刻崩溃（包括⼀系列操作的中间）。                    -恢复(已提交的部分)，持久性redolog

<a name="3lnd-1704983671344"></a>⽹络中断可能会意外切断数据库与应⽤的连接，或数据库之间的连接。   

<a name="av8h-1704983671346"></a>多个客户端可能会同时写⼊数据库，覆盖彼此的更改。           -隔离性，锁 + mvcc（隐藏字段+版本链+readview），并发安全级别是串行化。

<a name="emwl-1704983671348"></a>客户端可能读取到⽆意义的数据，因为数据只更新了⼀部分。 -一致性  原子性+隔离性(并发访问安全问题)=原子操作 

<a name="wimr-1709303907049"></a>即单线程 Transaction 、 分布式式事务、或者x86 的cas操作(不加锁的方式)

<a name="cbjd-1708942581743"></a>   

<a name="nhvj-1704983671350"></a>客户之间的竞争条件可能导致令⼈惊讶的错误。

<a name="bhvp-1708940338863"></a>**原子操作-原子性(共同成功失败)且有隔离性(高并发下数据安全)才能保证数据一致性（符合预期，强一致性)** 

<a name="739h-1708940746090"></a>什么数据库缓存双写一致性，都是只考虑了高并发下数据接近一致，实际上不能避免短时间数据不一致的情况，除非保证原子操作，加入事务可简化问题。


<a name="rpud-1708940366352"></a><a name="offx-1708940363646"></a><a name="vo8p-1704983742288"></a>**事务（transaction）** ⼀直是简化这些问题的⾸选机制。整个事务要么成功（**提交（commit）**）要么失败（**中⽌（abort）**，**回滚（rollback）**）

<a name="pnng-1646310922957"></a>**简化应⽤编程模型  安全保证（safety guarantees）**

<a name="lyog-1646310871301"></a>深⼊**并发控制**的领域   如何实现**读已提交**，**快照隔离**和**可串⾏化**等隔离级别

<a name="58hv-1710167822460"></a>**.事务的棘手概念**

<a name="eae5-1710239842883"></a>第一个sql数据库：IBM System R 于1975年引用的事务风格

<a name="nfd5-1710239927223"></a>2000年以后，NoSQL开始普及。

<a name="yxrp-1710167867782"></a>**ACID的含义**

<a name="hryj-1710167943276"></a>**原子性atomicity**

<a name="v62c-1710173076601"></a>能够在错误时中⽌事务，丢弃该事务进⾏的所有写⼊变更的能⼒。** 或许 **可中⽌性（abortability）是更好的术语**

<a name="6b47-1705118743952"></a>要么全部成功，要么全部失败，简化系统复杂度， **避免“部分成功失败”等中间态复杂逻辑的修正**。

<a name="xlmq-1709304402238"></a>原子在不同分支代表不同。**多线程编程当中，原子操作包含了 原子性+隔离性，保证了数据一致性。**

<a name="9aal-1710167983379"></a>**一致性consistency**

<a name="dsf1-1710173128804"></a>**对数据的⼀组特定陈述必须始终成⽴**。即**不变量（invariants）**

<a name="jkse-1710173130714"></a>**—致性这个词重载的很厉害:**

<a name="k1fa-1708878764771"></a>在第5章中，我们讨论了副本数据一致性，以及异步复制系统中的**最终一致性问题**（参阅“复制延迟问题") 。

<a name="t3tg-1708878764773"></a>一致性散列(Consistency Hash)\_)是某些系统用于重新分区的一种分区方法。

<a name="iwwj-1708878795623"></a>在CAP定理中，一致性一词用于表示**可线性化 -** 指分布式系统在发生网络分区时的一致性保证。

<a name="uzzc-1708878764775"></a>在ACID的上下文中，一致性是指数据库在应用程序的特定概念中处于“良好状态" -要么全部成功，要么全部失败，保证数据一致性。

<a name="7nnu-1708878764777"></a>很不幸，这一个词就至少有四种不同的含义。但大多都可归为符合数据预期

<a name="ovbp-1709306759049"></a><a name="vfh3-1709306802566"></a>异步复制中的一致性和CAP理论中的一致性都属于弱一致性，事务中的一致性更强调数据严格的一致性。

<a name="ov0g-1709306808935"></a>- 数据符合预期、分布式事务借鉴CAP 和Base理论(弱一致性，柔性事务)。最终一致是数据符合分布式     

<a name="nvqd-1709305291223"></a>              事务预期

<a name="hzf3-1708881156903"></a>-黑马上的CAP：一致性-任意节点数据一致  可用性-访问任意健康节点不能中断拒绝服务  分区-容错 分布式网络必定中断必定会产生分区，分区后必须对外提供正常服务。     举例分区后中断的副本未同步不能提供服务则强一致，未同步能提供服务则为高可用。

<a name="gfkv-1710171645686"></a>**隔离性isolation**

<a name="znac-1710240177722"></a>并发问题（**竞争条件race conditions**）

<a name="7fbu-1710173195291"></a>**同时执⾏的事务是相互隔离的，快照隔离（snapshot isolation）** 的功能-MVCC，**这是⼀种⽐可序列化更弱的保证**【8,11】

<a name="7kja-1710171663168"></a>**持久性durability**

<a name="x5so-1710173216536"></a>硬件故障或数据库崩溃，写⼊的任何数据也不会丢失。

<a name="sesd-1646310817481"></a><a name="yi8z-1704985578742"></a>参考mysql的事务、MVCC及锁

<a name="rlxa-1705080720222"></a>**弱隔离级别**：读已提交，可重复读，序列化

<a name="2jhg-1705080777447"></a>并行事务非阻塞态，MVCC快照读

<a name="avnt-1705080821368"></a>比较并设置(CAS)

<a name="pblh-1710167919896"></a>**单对象与多对象操作**

<a name="42qx-1710250188446"></a>**违反隔离性：一个事务读取另一个事务未被执行的写入（脏读）**

<a name="daxd-1710250201202"></a> **原⼦性确保发⽣错误时，事务先前的任何写⼊都会被撤消，以避免状态不⼀致（all or nothing）**

<a name="7ymn-1710171710772"></a>**单对象写入**

<a name="h5aa-1710250215106"></a>**单对象写入崩溃，原子性通过日志实现恢复**

<a name="ihdr-1710250368749"></a>**原子操作：CAS也是流行的操作**

<a name="a1qj-1710250481310"></a>**事务通常被理解为：将多个对象上的多个操作合并为一个执行单元的机制**

<a name="afyc-1710171718578"></a>**多对象事务的需求**

<a name="t9gh-1710251706186"></a>**是否需要多对象事务？** 

<a name="9b6e-1710251739137"></a>**是否有可能只用键值模型和单对象来实现应用程序？**

<a name="ormg-1710250533532"></a> **关系型数据库：多表关联插入操作**

<a name="opfe-1710250566216"></a> **文档数据模型：多个字段常在同一个文档(被视为单个对象），缺乏连接功能的文档DB会鼓励非规范化(操作非规范化信息需要更新多个文档)。事务可防止非规范化数据不同步。**

<a name="syt6-1710251863622"></a> **二级索引的数据库中：一二级索引的同步更新**

<a name="ymgi-1710251891615"></a>**无原子性:复杂的错误处理**

<a name="ovhl-1710251918119"></a>**无隔离性：并发问题**

<a name="g5o1-1710171723084"></a>**处理错误和中止**

<a name="ygfp-1710251941752"></a>**···   ACID哲学：违反规则宁可放弃，不留半成品。**

<a name="0hze-1710252188073"></a>**无主复制则是尽力而为：数据库将做尽可能多的事。错误时不会撤销已经完成的事。-错误恢复是应用程序的责任。**

<a name="7mbo-1710252298563"></a>**Rails的ActiveRecord、Django这样的orm框架不会重试中断的事务。丢弃用户输入。**

<a name="p2mf-1710253466041"></a>**中止的重点应该是允许安全的重试。但它并不完美：**

<a name="lmfw-1710253530673"></a>**事务成功，网络故障可能导致执行两次。除非有额外应用级除重机制。**

<a name="nxyx-1710253675080"></a>**负载过大，重试将更槽糕。限制重试次数，指数退避算法。并单独处理和过载相关的错误**

<a name="njy9-1710253740189"></a>**仅在临时性错误才值得重试（死锁，异常，网络中断和切换）。发生永久性错误的重试是无意义的**

<a name="auy9-1710253799114"></a>**数据库外的副作用：重试每次重发电子邮件。不同系统事务。两阶段提交2PC.**

<a name="mtpo-1710253936214"></a> **客户端重试失效则丢失数据。**

<a name="jngf-1710167840980"></a>**.弱隔离级别**

<a name="wdhp-1710263089880"></a>**安全并行parallel：事务不触及相同数据**

<a name="ykgs-1710263216103"></a>**竞争条件：**

<a name="er05-1710263177909"></a>**读：事务读取另一个事务同时修改的数据**

<a name="pypw-1710263203957"></a>**写：事务同时修改相同的数据**

<a name="xps5-1710263234506"></a>**事务隔离：**

<a name="ghkk-1710263260640"></a>**可序列化(一次一个执行，没有任何并发)**

<a name="a876-1710263299289"></a>**性能损失**

<a name="nqm3-1710263313752"></a>**弱隔离级别(非串行化nonserializable)**

<a name="e7nl-1710263334073"></a>**较弱的隔离级别防止一部分，而非全部的并发问题**

<a name="2xxd-1710331395046"></a>**资金损失，耗费财务调查，财务数据请使用ACID数据库(注意：流行的数据库也使用弱隔离级别，不一定能防止并发错误)**

<a name="pjqb-1710171742279"></a>**读已提交**

<a name="7h42-1710171796899"></a>**没有脏读**

<a name="lyju-1710332135761"></a>**dirty reads：事务看到另一个事务未提交的值**

<a name="x8ch-1710333899846"></a>**为什么要防止dirty reads：**

<a name="pwpa-1710333902582"></a>**更新多对象：脏读以为只看到部分数据**

<a name="jcj0-1710333902583"></a>**事务中止：回滚后，看到的是未提交的数据**

<a name="3mi1-1710332238978"></a>**解决：只能读取提交后的数据，且不会阻塞，并行时保存已提交的旧值 -mvcc**

<a name="vmfl-1710171803833"></a>**没有脏写**

<a name="hvah-1710332040048"></a>**dirty write: 事务同时更新相同对象。后面的写入覆盖尚未提交的值。**

<a name="chr0-1710333916523"></a>**避免的问题：**

<a name="14wx-1710333919188"></a>**混乱写入，导致bob后买车先更新发票commit而alic先买车后更新发票commit(buyer=bob but recipient=alice)**

<a name="g1sw-1710332222649"></a>**解决：延迟/阻塞第二次的写入，直到第一次写入事务提交或终止。**

<a name="ujzx-1710333397576"></a>**但不能防止计数器增量的竞争状态。(读写非原子性，写依赖读的副本)**

<a name="ugiq-1710333641028"></a>**计数器增量安全：防止更新丢失 -版本号**

<a name="z96g-1710171821987"></a>**实现读已提交**

<a name="tays-1710333754461"></a>**默认的隔离级别：oracle,postgreSQL,sql server ,memSql**

<a name="svaf-1710333809593"></a>**行锁row-level lock**

<a name="fsbu-1710334081090"></a>**读写锁防止脏读：读写锁互斥，只有读锁拥有者可持有写锁。**

<a name="xj1j-1710334321006"></a>**缺点：阻塞，性能损失。**

<a name="7klj-1710334353854"></a>**优化：所以一般用mvcc的模式。-或者copy on write**

<a name="bww4-1710171760070"></a>**快照隔离和可重复读**

<a name="wjut-1710343195467"></a>**不可重复读nonrepeatable read/读取偏差read skew**

<a name="jmuu-1710343248537"></a>**skew重载：在热点指的是不平衡，这里指异常时机  alice两个账号各500，alice先读acount1=500,转账员将acount1+100,acount2-100后commit，alice读acount2=400.commit.导致Alice看起来少了100。-暂时不一致。**

<a name="gwgf-1710343469620"></a>**提交后，刷新网页即可。有些情况不能容忍暂时不一致：**

<a name="m0km-1710345572560"></a>**备份：数据库备份需要几小时，期间接收写入包含新老数据。如果备份用于恢复，不一致就变成永久的了。-解决：全局锁/快照备份**

<a name="i5pt-1710345666724"></a>**分析查询和完整性检查：扫描大部分数据库，查询在不同时间点观察数据库产生不同，可能返回无意义的结果。**

<a name="p7tm-1710345899708"></a> **快照隔离snapshot isolation 对长时间运行的只读查询非常有用（备份和分析）。**

<a name="q8oz-1710345935366"></a> **即 一致快照consistent snapshot,即使被另一个事务更改，每个事务只能看到该特定时间的旧数据（特定时间点冻结的一致快照）。**

<a name="mo1i-1710346175801"></a>**PostgerSQL, mysql innoDB, Oracle, sqlServer**

<a name="2hpt-1710171981487"></a>**实现快照隔离**

<a name="49s0-1710346236063"></a>**关键原则：读不阻塞写，写不阻塞读。两者没有任何锁定争用。**

<a name="w8v8-1710346319154"></a>**多版本并发控制mvcc,multi-version concurrentcy contorl**

<a name="fh82-1710346453757"></a>**读已提交不提供快照隔离，保留对象的一两个版本就足够。通常支持快照隔离也是用mvcc来实现读已提交隔离级别：**

<a name="3xbw-1710346540026"></a>**读已提交为每个查询使用单独的快照-每个select单独生成。**

<a name="xqhm-1710346554737"></a>**快照隔离对整个事务使用相同的快照-复用第一个select生成的快照**

<a name="pmk8-1710351883488"></a>**update操作在内部翻译为Delete 和 insert**

<a name="vnfd-1710351911457"></a>**-innoDB实际上delete将旧数据版本移到undolog版本链中。垃圾收集会删除任何事务不可见的就对象版本。**

<a name="box0-1710171988275"></a>**观察一致性快照的可见性规则**

<a name="yapf-1710408915465"></a>**从来不更新值，而是每次值改变时创建一个新版本。使得数据库提供一致快照产生的开销很小。**

<a name="ecrk-1710408160769"></a>**事务id决定它可以看到哪些对象，规则如下：**

<a name="ogtp-1710408539120"></a>**事务开始时列出当时所有事务清单，即使之后提交，这些事务的写入也都会被忽略。**

<a name="unjc-1710408595672"></a>**忽略被中止事务任何写入**

<a name="ofbz-1710408626209"></a>**较晚(当前事务之后开始)的写入都被忽略，不管是否提交**

<a name="hgwi-1710408682423"></a>**所有其他写入，对应用都是可见的。**

<a name="rg1c-1710408738736"></a>**对象可见的两条规则**

<a name="weyp-1710408754844"></a>**读事务开始时，创建该对象的事务已提交。**

<a name="xqky-1710408773006"></a>**请求删除的事务在读事务开始时未提交。**

<a name="ai77-1710171999516"></a>**索引和快照隔离(索引如何在多版本数据库中工作)**

<a name="kanl-1710410047690"></a>**同一对象不同版本放在同一个页面中，PostgreSQL的优化可以避免更新索引**

<a name="yv2q-1710410120895"></a>**仅追加/写时拷贝apeend-only/copy-on-wirte的变体B树：更新不覆盖树的页面，为每个修改页创建副本。**

<a name="etza-1710410471666"></a>**每个写入事务/一批事务都会创建一个新的B树，当创建时，从该特定树根生长的树就是数据库的一个一致性快照。**

<a name="79xv-1710410561061"></a>**需要负责压缩和垃圾收集的后台进程。**

<a name="xr4f-1710172004472"></a>**可重复读与命名混淆**

<a name="nohd-1710417835613"></a>**原因：System R定义隔离级别时并未有快照隔离**

<a name="uwdp-1710417928621"></a>**oracle DB2 称为序列化**

<a name="f5te-1710417946615"></a>**postgreSql mySql称为可重复读**

<a name="e9wg-1710171770800"></a>**防止丢失更新**

<a name="ajmt-1710418075399"></a>**脏写导致丢失更新lost update**

<a name="c7rv-1710418271703"></a>**读取-修改-写入序列的狠揍clobber：第二个事务并没有包括第一个事务的修改: -写依赖读**

<a name="uvoq-1710418375497"></a>**增加计数器或更新账户余额(需读取当前值，计算新值并写回更新后的值)**

<a name="ro12-1710418458493"></a>**进行本地修改： 解析文档，更改后回写修改的文档**

<a name="9n83-1710418515773"></a>**同时编辑wiki页面：整个页面覆盖当前内容。**

<a name="lftw-1710172034957"></a>**原子写(x排它锁)**

<a name="6jim-1710418574114"></a>**数据库原子更新操作保证并发安全**

<a name="dxgy-1710419672127"></a>**mysql: 行级写锁**

<a name="bqxj-1710419591972"></a>**MongoDB：对JSON文档一部分进行本地修改的原子操作**

<a name="wxju-1710419646040"></a>**redis提供了优先队列等修改数据的原子操作。**

<a name="h0ip-1710421887552"></a>**原子操作/游标稳定性cursor stability：通常在读取对象时获取其上的排它锁，以便提交前没有事务可以读取它。另一个选择是将所有原子操作在单一线程上执行。-redis**

<a name="6hwo-1710422121598"></a>**unfortunately,ORM框架易执行读取-修改-写入序列，而不是使用数据库提供的原子操作。如果你知道自己在做什么那当然不是问题**

<a name="vysa-1710172041914"></a>**显式锁定(for update：读-改-写序列)**

<a name="oknq-1710422501689"></a>**让应用程序显示锁定更新的对象，直到一个读取-修改-写入序列完成**

<a name="89ij-1710422624973"></a>**select ..... for update;**

<a name="50q1-1710422845671"></a>**--更新先前select 返回棋子的位置。**

<a name="rmgw-1710422637550"></a> **update**

<a name="euv5-1710422671170"></a>**for update-对返回的所有行加锁，忘记加锁很容易引入竞争条件(同时修改)**

<a name="jpu5-1710172058032"></a>**自动检测丢失的更新(管理器检测处理并发问题)**

<a name="8ytj-1710423161566"></a>**允许并行执行，事务管理器检测到丢失更新，中止事务并强制重试读-改-写序列。**

<a name="w9el-1710423029153"></a>**Oracle可串行化(快照隔离)和sqlServer的快照隔离级别会自动检测到丢失更新，中止惹麻烦的事务。一些作者认为能防止丢失更新才算提供快照隔离。这个定义下，mysql不算提供快照隔离**

<a name="qg6e-1710423330067"></a>**优点：是一个很好的功能，不需要应用代码使用任何特殊数据库功能。允许你忘记加锁或原子操作，由管理器检测丢失更新。**

<a name="ftwe-1710172063360"></a>**比较并设置(CAS)**

<a name="os3h-1710424617661"></a>**不提供事务的数据库中的原子操作：比较并设置（CAS compare and set）**

<a name="hlfh-1710425612756"></a>**update table set content='new content' where id=123 and content = 'old content'  必要时重试**

<a name="rxcv-1710425806449"></a>**问题：数据库允许where子句从旧快照读取，此语句无法防止丢失更新。即另一个并发写入，where条件也为真。-非当前读或非原子写。**

<a name="zss4-1710425865867"></a>**解决：检查数据库的CAS是否安全。保证比较交换为当前读且写是否加锁/原子写**

<a name="bvrp-1710172079412"></a>**冲突解决与复制(多个数据库副本的并发)**

<a name="ewf7-1710434904534"></a>**基于锁和cas操作不适用于多个数据库副本**

<a name="8dx4-1710434970886"></a>**如检测并发写入：允许并发吸入创建多个冲突版本(也称兄弟），应用代码或特殊数据结构在发生之后解决合并这些版本。**

<a name="gl8j-1710435048968"></a>**原子操作可在复制的上下文中很好工作，尤其具有可交换性时。Riak2.0不同客户端同时更新一个值是，Riak将自动更新合并在一起，以免丢失更新。防止复制副本丢失更新。**

<a name="gdtn-1710435259414"></a>**最后写入LWW解决冲突很容易丢失更新。unfortunately,许多复制数据库默认LWW。**

<a name="rkev-1710172453385"></a>**写入偏差与幻读（两个事务更新两个不同的对象）**

<a name="itfd-1710436127298"></a>**select count(\*) where oncall=true....alice 和 bob分别查在职医生人数**

<a name="leam-1710436160580"></a>**update...set oncall=false 然后将自己的记录更新为请假，违反至少一医生在职。**

<a name="ovid-1710172462835"></a>**写偏差的特征**

<a name="iedp-1710437034438"></a>**特征：涉及多个对象，单对象的原子操作不起作用**

<a name="wszw-1710437034814"></a>**快照隔离实现中，自动检测丢失更新对此无帮助。postgred,innodb的可重复读，oracle序列化或sql server的快照隔离级别中，都不会自动检测写入偏差。写入偏差需要真正的可序列隔离-业务上的问题。**

<a name="hn04-1710437034815"></a>**数据库配置约束，指定至少一个值为true.大多数不支持这种配置，可以使用触发器或者物化视图实现。**

<a name="crrt-1710437034816"></a>**显示锁定。 select ...fro update -锁定返回的所有行，锁定两个医生**

<a name="4jr1-1710172470885"></a>**写偏差的更多例子**

<a name="0hyt-1710437389755"></a>**读数据为空，分别插入一条数据的会议室预定系统：select count(\*) from bookings where roomid=123 and time...，insert into bookings....不能防止另一个用户插入冲突会议。解决：又需要串行化执行。**

<a name="pgcb-1710437636980"></a>**多人游戏：棋盘用锁防止丢失更新，但锁定不能妨碍将不同的棋子放在相同位置。产生写入偏差 。解决：使用唯一约束。**

<a name="bwel-1710437042998"></a>**抢注用户名：和会议系统一样。不过唯一性约束可以解决该问题。**

<a name="ogt8-1710438166946"></a>**防止双重开支；用户花钱和积分服务，检查支付数不超过余额，有了写入偏差，可能会发生两个支出项目同时插入，导致余额变为负值，两个事务都不会注意到另一个。**

<a name="8gty-1710172478550"></a>**导致写入偏差的幻读**

<a name="tw0y-1710438423955"></a>**所有以上例子都遵循类似的模式**

<a name="bngi-1710438445792"></a>**Select查询符合条件的行，至少两名医生值班；不存在该会议室同一时段的预定；棋盘位置未被占据；用户未被抢注；账户还有足够余额**

<a name="l6p0-1710438590471"></a>**按照第一个查询的结果，应用代码决定是否继续**

<a name="qt10-1710438739456"></a>**应用决定继续操作，执行写入(插入更新删除），并提交事务**

<a name="cdmo-1710438899441"></a>**步骤3修改的行，是步骤1中返回的行之一，可以使用select for update来使事务安全避免写入偏差.**

<a name="caet-1710439501945"></a>**但检查是否不存在满足条件行，写入添加一个匹配相同条件的行。select for update 锁不了任何东西。**

<a name="cwgh-1710440241091"></a>       **这种效应：一个事务中的写入改变另一个事务的搜索查询结果，被称为幻读。快照隔离避免了只读查询中的幻读。以上的读写事务中，幻影会导致特别棘手的写歪斜情况。**

<a name="1cjy-1710172485201"></a>**物化冲突**

<a name="fv3x-1710440426895"></a>**物化冲突：将幻读变为数据库中一组具体行上的锁冲突。**

<a name="laff-1710440634993"></a>**通过创建时间槽和房间的表，提前出入房间和时间的所有可能组合。创建预定的事务可以select for update锁定房间和时间段对应的行，在获得锁定后，可以检查重叠的预定并插入新的预定。该表不是存储预定相关的信息，它完全就是一组锁，用于防止同时修改同一房间和时间范围内的预定。**

<a name="dngy-1710441936216"></a>**缺点：弄清除如何物化冲突可能很难，也很容易出错，而让并发控制机制泄露到应用数据模型是很丑陋的做法。**

<a name="i0he-1710441997817"></a>**物化重入应为最后的手段。可序列化Serializeble级别是更可取的。**

<a name="di29-1710167844061"></a>**.可序列化**

<a name="ztac-1710587737356"></a>**弱隔离级别读已提交和快照隔离不能解决写入偏差幻读：**

<a name="ky3h-1710588699885"></a>**隔离级别难以理解，且不同数据库中实现不一致，可重复读概念不一样**

<a name="tpbs-1710588738858"></a>**光检查应用代码很难判定在特定隔离界别是否安全**

<a name="jp98-1710588779920"></a>**无检测竞争条件的好工具，往往倒霉时才会出现问题。**

<a name="sqvc-1710588820273"></a>**20世纪70年代system R就已经是这样，研究人员的答案都很简单：可序列化（serializeble）级别（但非人见人爱），都使用三种技术之一。**

<a name="mqa4-1710589545518"></a>**字面意义上的串行顺序执行事务**

<a name="neot-1710589568078"></a>**两相锁定2PL two-phase locking,几十年来唯一的可行选择**

<a name="pizj-1710589721553"></a>**乐观并发控制，可序列话的快照隔离serializable snapshot isolation**

<a name="2oi3-1710172506817"></a>**真的串行执行(单线程执行事务)**

<a name="o5af-1710589822067"></a>**数据库设计人员07年才确定，单线程循环执行事务时可行的。（多线程过去30年中被认为是获得良好性能的关键所在）**

<a name="phuh-1710609564138"></a>**两个进展引发了这个反思：**

<a name="owi7-1710609747624"></a>**RAM足够便宜，许多场景可以将完整的活跃数据保存在内存中。-redis**

<a name="vhy4-1710609817752"></a>**数据库设计人员意识到OLTP事务很短，只进行少量的读写操作。长时间的分析查询通常是只读的，可以用一致快照（快照隔离）上运行。**

<a name="xcax-1710609934885"></a>**VoltDB/H-Store, Redis 和 Datomic中实现。避免锁的协调开销。吞吐量仅限单个cpu**

<a name="xh4n-1710172519134"></a>**在存储过程中封装事务(优化交互式单线程事务)**

<a name="xthc-1710757083497"></a>**数据库设计者认为，机票全流程是一个事务，可以被原子化执行。缺点：交互式会使流程性能直接下降。**

<a name="oo8b-1710757291600"></a>**解决：单线程串行执行事务的系统不允许交互式的多语句事务。提前将整个事务作为存储过程提交数据库：**

<a name="9fzd-1710757436562"></a>**Interactive transaction :bob医生请假 1.select count  2.if count>=2 3.update false**

<a name="gegl-1710763202697"></a>**stored procedure: execute stored take doctor of call**

<a name="t47s-1710763179337"></a>**事务所需的数据都在内存中，快速执行，无需等待网络和磁盘IO**

<a name="7ksv-1710172529258"></a>**存储过程的优点和缺点**

<a name="jfoa-1710763413471"></a>**名声不好：**

<a name="4qhf-1710763421594"></a>**陈旧丑陋无库生态，数据库存储过程各自的语言没跟上通用编程语言的发展**

<a name="96la-1710763483936"></a>**管理困难，调试困难，版本控制测试部署困难，和监控指标的系统集成困难**

<a name="idii-1710763602399"></a>**单个数据库通常由多个应用共享，写得不好的存储过程（占用大量内存和cpu）会比代码造成更大麻烦**

<a name="1w0a-1710763899035"></a> **这些问题都可以克服。现代存储过程放弃了PL/SQL,使用现有通用编程语言：VoltDB使用java或Groovy, Datomic使用Java或Clojure, Redis使用Lua.**

<a name="bp68-1710767504595"></a>**存储过程与内存存储，使得单线程执行事务可行，**

<a name="ahfz-1710767568244"></a>**无需等待I/O,**

<a name="mfvt-1710767570930"></a>**避免并发控制机制的开销，可以在单线程实现相当好吞吐量**

<a name="7m1p-1710767621202"></a>**VoltDB还用存储过程进行复制，在每个节点上执行相同的存储过程，所以要求存储过程是确定性的。比如使用当前日期，需要通过特殊的确定性API实现。**

<a name="xxtp-1710172539181"></a>**分区**

<a name="rqu5-1710767939361"></a>**顺序执行事务使并发控制简单多，但吞吐限制为单机单核。吞吐量高的应用，单线程将可能成为严重瓶颈。**

<a name="puih-1710768082742"></a>**扩展多核多节点，可以对数据进行分区，每个事务只需在单个分区中读写数据，事务吞度量就可以与cpu保持现行扩展。**

<a name="jpiw-1710768164695"></a>**对于需要访问多个分区的任务事务，需要进行协调，存储过程跨所有分区锁定执行，保证串行。**

<a name="fgu3-1710768218238"></a>**缺点：协调开销性能比单区事务慢得多。VoltDB吞吐量每秒1000个跨分区写入，比单分区低几个数量级，且通过增加机器来提高**

<a name="8lf4-1710768407791"></a>**事务是否可划分-应用的数据结构，键值数据，多个二级索的数据引需要大量跨分区协调。**

<a name="zyih-1710172540516"></a>**串行执行小结**

<a name="dibg-1710768638498"></a>**需每个事务小而快，一个缓慢的事务拖慢所有事务。**

<a name="22nq-1710768681244"></a>**可放入内存仅限活跃数据集，少量数据会移动到磁盘。但需要访问执行中的事务，系统会变慢。**

<a name="jmsk-1710768781527"></a>**写入吞吐量必须低到能在单个cpu运行，否则事务能划分至但分区，且无需分区协调**

<a name="wlnd-1710769060180"></a>**跨分区事务使用程度受限。**

<a name="uhxa-1710172558745"></a>**两阶段锁定（2PL）**

<a name="nhdj-1710769248115"></a>**30年高使用的序列化算法：两阶段锁定2PL two phase locking ,独占访问exclusive access:**

<a name="khdp-1710769659952"></a>**事务A读取对象，阻塞B写入，直至A提交；**

<a name="elpw-1710769685611"></a>**事务A写入对象，阻塞B读取,直至A提交；**

<a name="6ja2-1710769959539"></a>**快照隔离使得不会阻塞读，2PL提高序列化性质，解决丢失更新和写入偏差。**

<a name="lfuv-1710172605096"></a>**实现两阶段锁**

<a name="8oif-1710770052594"></a>**2PL即innoDB可序列化级别及DB2可重复读隔离级别。**

<a name="6wad-1710770158675"></a>**读写阻塞为每个对象添加锁。共享模式shared mode 与独占模式exclusive mode:**

<a name="1dyc-1710770195788"></a>**读取对象需以共享模式获取锁。读共享**

<a name="bshw-1710770251530"></a>**写入需独占模式取锁。写互斥。**

<a name="r0b0-1711207524774"></a>**事务获得锁必须持有锁知道事务结束(提交或中止)。即一阶段获取锁，二阶段释放所有锁。**

<a name="iuyh-1710770211133"></a>**死锁deadlock, 数据库会自动检测死锁，并中止其中一个。被中止的事务充实需应用程序实现。**

<a name="qi7j-1710172616303"></a>**两阶段锁定的性能**

<a name="vz0p-1711207837446"></a>**比弱隔离差得多**

<a name="ienx-1711207878742"></a>**锁开销、串行并发性降低**

<a name="z85f-1711207913718"></a>**交互式事务形成等待队列、高百分位响应慢**

<a name="kmkr-1711207799940"></a>**死锁频繁时重试造成浪费**

<a name="ccq8-1710172621528"></a>**谓词锁predicate lock**

<a name="kfpi-1711208306292"></a>**谓词锁：属于符合搜索条件的对象，解决幻读phantoms**

<a name="6dqd-1711208459688"></a>**事务A获取共享谓词锁shared-mode predicate lock读取匹配对象，与排它互斥**

<a name="p3er-1711208588906"></a>**事务A写入需等待其他事务谓词锁释放。**

<a name="bdwj-1711208433268"></a>**适用于尚不存在，将可能添加的对象（幻象），如果两阶段包含谓词锁，可实现串行化。**

<a name="zv5c-1710172626404"></a>**索引范围锁next-key lock**

<a name="a3ce-1711208973949"></a>**谓词锁性能不佳：活跃事务持锁多，检查匹配非常耗时**

<a name="ayfb-1711209059199"></a>**2PL采用索引范围锁-简化版谓词锁：**

<a name="qmbu-1711212311152"></a>**索引位于roomid, 指示room123用于预定**

<a name="ajbo-1711212362665"></a>**或者索引位于时间上，指示12:00~13:00用于预定。**

<a name="k1ie-1711212755816"></a>**以上任何一条件，当另一个事务想写入时，需要更新索引-叶子节点，会收到共享锁。解决幻读和写入偏差**

<a name="6lzs-1711212829915"></a>**索引范围锁不如谓词锁精确，但开销低**

<a name="bofb-1711212877091"></a>**无可挂载索引，将退化为表锁，性能不利，但这是回退到一个安全位置。**

<a name="slwa-1710172573367"></a>**序列化快照隔离SSI（高性能序列化算法）**

<a name="lnci-1711213123166"></a>**新算法：可序列化快照隔离SSI serializeble snapshot isolation 仅与快照隔离有很小性能损失. 08年 micheal cahill博士论文。**

<a name="weo0-1711213307841"></a>**用于单节点PostgreSQL9.1后序列化和分布式数据库**

<a name="ue1s-1711213377985"></a>**处于实践证明阶段**

<a name="yq9i-1710172639651"></a>**悲观pessimistic与乐观optimistic的并发控制**

<a name="54jr-1711213690005"></a>**极致悲观：串行排它锁**

<a name="bjxf-1711213769533"></a>**序列化快照隔离SSI是乐观技术：** 

<a name="mefw-1711213819265"></a>**缺点：多事务争用contention时性能不佳，大部分事务中止，吞吐量极限下有重试机制将使性能变差。**

<a name="nk1s-1711213915330"></a>**优点：有备用容量，竞争不高场景比悲观好，可交换的原子操作可减少争用。**

<a name="snvf-1711214019984"></a>**SSI在快照隔离基础上添加算法检测写入的序列化冲突，并决定中止哪些事务。**

<a name="9lgw-1710172651041"></a>**基于过时前提的决策**

<a name="td4m-1711214184809"></a>**医生值班读取-修改-写入。数据库检测过时并终止：**

<a name="t08a-1711215992016"></a>**检测对旧MVCC对象版本的读取(读之前存在未提交的写入)**

<a name="aego-1711216030637"></a>**检测影响先前读取的写入（读之后发生写入）**

<a name="5smj-1710172660675"></a>**检测旧MVCC读取**

<a name="z7u2-1711216050316"></a>**事务提交时，检测是否有被忽略的写入已被提交。**

<a name="afqq-1711216243096"></a>**SSI支持一致快照中长时间运行的读取-仅在提交时中止检测的陈旧读取。因为只读不产生幻读和写入偏差风险**

<a name="mvok-1710172671381"></a>**检测影响之前读取的写入**

<a name="mo5j-1711216452745"></a>**事务写入提交时，在索引中查找最近读取受影响的其他事务，通知读取的事务非最新。并中止未提交写入的其他事务。**

<a name="0sq6-1710172685702"></a>**可序列化的快照隔离的性能**

<a name="g2eg-1711216636788"></a>**粒度granularity，精准哪些事务需要中止，但簿记开销显著。**

<a name="ux2m-1711216812849"></a>**简略的跟踪速度快（粗粒度），但导致不必要的事务中止。**

<a name="jzqb-1711216700614"></a>**相比2PL, 不需要锁定阻塞，读性能高**

<a name="qm51-1710756953994"></a>**相比串行化，可扩展多台机器提高吞吐量，可跨分区读。**

<a name="wvsk-1711216911828"></a>**SSI要求事务尽量短，避免长事务发生冲突中止。慢事务SSI比2PL或串行执行更不敏感**

<a name="enui-1704985776096"></a>**8.分布式系统的麻烦**

<a name="e2bp-1711387736669"></a>**前几章failover故障切换, 复制延迟 与事务控制 处理各种可能发生的边缘情况，本章则是彻底的悲观总结。**

<a name="4yaw-1711386647072"></a>**故障与部分失效**

<a name="9d0g-1711387883443"></a>**部分失效partial failure  不确定性的nondeterministic: IDC配电单元故障**

<a name="w7ln-1711386736921"></a>**云计算与超级计算机**

<a name="ynhs-1711386665148"></a>**不可靠的网络(Timeout)**

<a name="fav6-1711388032544"></a>**请求丢失： 拔网线**

<a name="znsf-1711388048086"></a>**请求排队：**

<a name="gmdu-1711388084834"></a>**请求失效：**

<a name="dssu-1711388054944"></a>**.....**

<a name="y933-1711387087536"></a>**真实世界的网络故障**

<a name="aywv-1711387099045"></a>**检测故障**

<a name="z4hi-1711387103669"></a>**超时与无穷的延迟**

<a name="qs2e-1711388153448"></a>**级联失效cascading failure**

<a name="gttn-1711387323883"></a>**网络拥塞和排队**

<a name="v9f2-1711388199023"></a>**TCP执行流量控制flow control**

<a name="up7k-1711389082773"></a>**视频、语音会议使用UDP，折中丢包与流畅**

<a name="t56p-1711387113980"></a>**同步网络vs异步网络**

<a name="fmrl-1711389283437"></a>**有限延迟bounded delay：同步网络，不收排队影响**

<a name="bwvp-1711387335617"></a>**我们不能简单地使用网络延迟可预测吗**

<a name="l3p1-1711386676597"></a>**不可靠的时钟**

<a name="faqp-1711469591901"></a>**机器的时钟：硬件设备，石英振荡器，**

<a name="xtjc-1711469629964"></a>**不是完全准确的。**

<a name="knwp-1711469656643"></a>**同步时钟：网络时间协议NTP**

<a name="pfpq-1711469689783"></a>**服务器从精确时间源获取时间-GPS接收器**

<a name="qoxv-1711387218692"></a>**单调钟与时钟**

<a name="wu2k-1711387376627"></a>**时钟**

<a name="obwb-1711469781129"></a>**Linux: clock\_gettime(CLOCK\_REALTIME)**

<a name="uxdp-1711469821742"></a>**java:system.currentTimeMilis**

<a name="gwyx-1711469840905"></a>**通常与NTP同步，但举例NTP服务器太远，则可能被强制重置(及时跳回）**

<a name="hl1a-1711387385739"></a>**单调钟**

<a name="uzaz-1711470052827"></a>**保证总是前进**

<a name="tbmn-1711469988760"></a>**Linux:CLOCK\_MONOTONIC**

<a name="fb70-1711470014393"></a>**java:System.nanoTime**

<a name="sn42-1711470028035"></a>**调整频率：NTP检测到计算机石英钟更快或更慢，则调整单调钟频率（偏移skewing时钟）.**

<a name="ct3v-1711470667953"></a>**不假定不同节点时钟存在同步：分布式系统用单调钟效果好，对测量的不准确不敏感**

<a name="a7gy-1711387238026"></a>**时钟同步与准确性**

<a name="pbyu-1711470750697"></a>**漂移drifts: 计算机石英钟不准确原因,取决机器温度。**

<a name="kgdy-1711470917769"></a>**实现精确度：GPS接收机，精确时间协议PTP**

<a name="kgez-1711470944635"></a>**同步错误的原因：NTP守护进程配置错误，防火墙阻止NTP通信。**

<a name="vo0i-1711387245745"></a>**依赖同步时钟**

<a name="zm2f-1711471000801"></a>**使用需要同步时钟的软件需监测所有机器间的时钟偏移**

<a name="fnxq-1711387475761"></a>**有序事件的时间戳**

<a name="n1pp-1711471283186"></a>**写入排序问题：B客户端写入比A晚但具有更早的时间戳。** 

<a name="50kp-1711471399605"></a> **最后写入为准LWW**

<a name="axgx-1711471482711"></a> **版本向量**

<a name="ofpq-1711387431462"></a>**时钟读数存在置信区间**

<a name="aihs-1711471513794"></a> **置信区间的不确定性：NTP服务器的不去定性，加上服务器网络往返时间**

<a name="aave-1711471693187"></a>**当clock\_gettime()返回值不会告诉你预期错误，不知道置信区间是5毫秒还是5年**

<a name="znqm-1711471741654"></a>**例外：Spanner Google TureTime API明确报告本地时钟置信区间（最早，最晚）。**

<a name="bfz6-1711387449885"></a>**全局快照的同步时钟**

<a name="dpco-1711471815493"></a>**分布式的事务快照隔离，分布式事务ID时序成为站不住脚瓶颈**

<a name="2ihe-1711471939317"></a>**Spanner通过置信区间来比较A,B发生的时序。**

<a name="9qfk-1711471991096"></a>**分布式事务语义使用时钟同步是一个活跃的研究领域，没有在谷歌之外的主流数据库中实现。**

<a name="3mnj-1711387250438"></a>**暂停进程**

<a name="ui0e-1711472636558"></a>**如何确保分布式主节点仍未领导者**

<a name="yh9a-1711472775035"></a>**方式一：从其他节点获得租约lease, 类似一个带超时的锁，周期性过期前续约。-和redison续约类似**

<a name="kqwv-1711472837428"></a>**过期时，由另一个节点接管。**

while(true){

` `request=getIncomingRequest();

` `// 确保租约还剩下⾄少10秒

` `if (lease.expiryTimeMillis-System.currentTimeMillis()< 10000){

` `lease = lease.renew();

` `}

` `if(lease.isValid()){

` `process(request);

` `}}

<a name="nmd5-1711472763779"></a>}

<a name="gi5a-1711473874947"></a>**缺点：依赖同步时钟**

<a name="93uw-1711473992955"></a>**意外的时间停顿：**

<a name="7kp7-1711474017909"></a>**stop-the-world  HotSpot GC**

<a name="6ejp-1711474059672"></a>**suspend虚拟机**

<a name="92se-1711474080346"></a>**随意暂停恢复：关闭笔记本盖子**

<a name="tfxw-1711474128862"></a>**窃取时间steal time:虚拟机切换或cpu上下文切换，在其他机器中花费的时间.**

<a name="7jwg-1711474280466"></a>**同步时的阻塞io：java惰性加载类文件；磁盘为网络文件系统或网络块设备-亚马逊EBS**

<a name="kvsa-1711474441136"></a>**磁盘交换内存抖动thrashing: 允许交换到磁盘（分页），内存访问可能导致页面错误page fault .话费大量时间将页面交换到内存，实际完成的工作很少thrashing。 服务器机器禁用页面调度，干掉进程释放内存。**

<a name="ocvk-1711474648160"></a>**SIGSTOP暂停unix进程:Ctrl-Z立即阻止进程的CPU周期**

<a name="t1w7-1711474768157"></a>**这些都可以随时抢占preempt正在运行的线程。**

<a name="cirf-1711473855327"></a>**响应时间保证**

<a name="r1ji-1711474887529"></a>**硬实时hard real-time系统: 不满足特定截止时间deadline可能会导致整个系统故障。**

<a name="pgjw-1711475001376"></a>**嵌入式系统精心设计和测试：安全气囊不会因系统GC暂停弹出。**

<a name="urp5-1711475089330"></a>**大量的额外工作，昂贵。**

<a name="i1wt-1711387521748"></a>**限制垃圾收集的影响**

<a name="oxal-1711475134772"></a>**通知GC暂停，停止接收新请求-对延迟敏感的金融系统**

<a name="ho3v-1711475217820"></a>**变种：GC只收集新生代，积累老年代，一次重启一个节点，类似滚动升级。**

<a name="ujyf-1711386681865"></a>**知识、真相与谎言**

<a name="hdwi-1711387268312"></a>**真理由多数所定义**

<a name="rxcy-1711561420884"></a>**stop the world 一分钟，被其他节点宣告死亡，重新选举。**

<a name="3zea-1711387542106"></a>**领导者与锁定**

<a name="b6am-1711561462773"></a>**数据库分区领导者只能有一个节点：避免脑裂**

<a name="3ynw-1711561525662"></a>**特定资源的锁和对象只允许一个事务/客户端持有**

<a name="hqa3-1711561556083"></a>**用户唯一标识**

<a name="rv2w-1711561875596"></a>**节点认为它是天选者the choosen one**

<a name="gu25-1711561617808"></a>**HBase例子：分布式锁的实现不正确，客户端1持有锁stop the world导致lease超时,客户端2获得锁进行处理，客户端1仍认为它具有有效的租约，即使它已经过期，从而破坏了存储的文件。**

<a name="mhlf-1711387550649"></a>**防护令牌**

<a name="gw5w-1711561950975"></a>**解决天选者问题：防护fencing**

<a name="vi5w-1711562021406"></a>**fencing token :只允许增加屏蔽令牌的顺序进行写操作。**

<a name="2yxl-1711562140276"></a>**服务器端检查token,获取锁时token增加33+1，存储服务器记录更高令牌34的写入，拒绝令牌33的请求。-一般是redisson续期，这个更像乐观锁。**

<a name="e6n2-1711562077138"></a>**ZooKeeper将事务标识zxid和节点版本conersion用作屏蔽令牌。保证了单调递增**

<a name="uujk-1711564755459"></a>**如文件存储服务器可将令牌卸载文件命中**

<a name="bsay-1711387279845"></a>**拜占庭故障**

<a name="id0b-1711628556885"></a>**拜占庭故障Byzantine fault: 在不信任的环境中达成共识的问题称为拜占庭将军问题。**

<a name="lxw6-1711628612728"></a>**拜占庭将军问题：n位将军需要同意，一些叛徒通过发送虚假或不真实信息来混淆欺骗他人。**

<a name="lpn6-1711628716132"></a>**拜占庭容错：系统在部分节点发生故障、不遵守协议，恶意攻击，扰乱网络时仍能继续正确工作：**

<a name="py6z-1711638469892"></a>**航空航天环境计算机被辐射破坏，不可预知方式响应其他节点**

<a name="csli-1711638605446"></a>**多个参与组织系统中，参与者试图欺骗他人。比特币等区块链对等网络让互不信任的各方同意交易不依赖中央当局。**

<a name="f38o-1711387557457"></a>**弱谎言形式**

<a name="eepx-1711638744038"></a>**添加防止撒谎弱形式机制；**

<a name="yseh-1711638821915"></a>**校验和防止数据包被破坏**

<a name="2a8h-1711638847924"></a>**公开访问的系统需仔细清理来自用户的任何输入**

<a name="zcdt-1711638888096"></a>**NTP多数对时间范围达成一致，配置错误的服务器将被排除**

<a name="x4lu-1711387293192"></a>**系统模型与实现**

<a name="iyps-1711639179162"></a>**定时假设三种系统模型：**

<a name="pgo0-1711640511485"></a>**同步模型synchronous model: 网络延迟，暂停和时钟漂移不会超过某个固定上限；**

<a name="h1x4-1711640383000"></a>**部分同步模型partial synchronous：大多数情况像一个同步系统一样运行，有时出现超时，进程暂停和时钟漂移界限**

<a name="vkkn-1711640459345"></a>**异步模型：一个算法不允许对实际做任何假设，事实上它甚至没有时钟。**

<a name="lg5f-1711640536166"></a>**节点系统模型：-节点失效问题**

<a name="ahco-1711640498506"></a>**崩溃停止crash-stop:只能由崩溃失效，且永远不会回来。**

<a name="35nl-1711640632666"></a>**崩溃恢复crash-recovery: 具有稳定存储（非易失性磁盘），崩溃中保留，内存中状态会丢失-innodb三阶段提交**

<a name="rpmc-1711640822813"></a>**拜占庭（任意）故障：节点可以做任何事情，包括戏弄和欺骗其他节点**

<a name="6gea-1711640879281"></a>**具有崩溃恢复的部分同步模型是最有用的模型。分布式算法如何应用这种模型**

<a name="hwoz-1711387576180"></a>**算法的正确性**

<a name="i9kv-1711640972087"></a>**描述属性：定义算法的正确性**

<a name="qsck-1711641049261"></a>**锁生成屏蔽令牌，要求具有以下属性：**

<a name="tvxj-1711641079676"></a>**唯一性：没有两个屏蔽令牌请求返回相同的值**

<a name="2d0a-1711641105012"></a>**单调序列：时序实现单调**

<a name="mlbd-1711641130527"></a>**可用性：请求防护令牌且不会崩溃的节点，最终会收到响应**

<a name="1lz8-1711387585629"></a>**安全性和活性**

<a name="hctm-1711641203049"></a>**澄清这种情况，需区分两种不同性质**

<a name="k48b-1711641295367"></a>**安全性safety: 唯一性和单调序列**

<a name="fmy7-1711641313609"></a>**活性：可用性**

<a name="ndiw-1711387592922"></a>**将系统模型映射到现实世界**

<a name="rp9s-1705080859004"></a>**9.一致性共识**

<a name="vrvh-1712996687843"></a>**共识consensus: 让所有节点对某件事达成一致**

<a name="oqcs-1712996726634"></a>**脑裂brain split: 两个节点都认为自己是master, 经常导致数据丢失；**

<a name="obqn-1711730044966"></a>**一致性保证**

<a name="ku5g-1712996774138"></a>**最终一致性：收敛convergence, 最终收敛到相同的值**

<a name="ga60-1712996859001"></a>**事务一致性：避免同时执行事务导致的竞争状态**

<a name="eovi-1712996916251"></a>**分布式一致性模型：面对延迟和故障时，如何协调副本间的状态**

<a name="thyh-1711730049653"></a>**线性一致性**

<a name="bvre-1712997165569"></a>**背后的想法：原子一致性atomic consistency, 强一致性strong consistency, 立即一致性 immediate consistency ,外部一致性 external consistency**

<a name="qbsw-1712997247742"></a>**看起来只有一个数据副本，实际有多个副本 - 强一致性就是逆分布式化，看成一个整体。**

<a name="f0su-1712997377059"></a>**线性一致是一个新鲜度保证 recency gurantee;**

<a name="mtb7-1712997407717"></a>**非线性一致的例子： world cup ,  alice refresh - DB1 return germany 1: 0 argentina won ;  bob refresh website - DB2(un asychronize) return still playing;**

<a name="qimr-1711730403998"></a>**为什么使得系统线性一致？**

<a name="ffat-1712998155207"></a>**例子：CAS使得多个客户端并发按序更新**

<a name="3elk-1712997586736"></a>**线性一致性与可序列化是两种完全不同的保证：**

<a name="qpvu-1712998010030"></a>**可序列化serializeble: 单对象或者多对象操作，确保按照某种顺序执行**

<a name="ojsh-1712998125336"></a>**线性一致性Linearizability:是读取和写入寄存器（单个对象）的新鲜度保证，不会将操作组合为事务，不会阻止写入偏差等问题**

<a name="5hda-1712998332148"></a>**单副本强可串行性strong-1SR: 一个数据库可提供可串行性和线性一致, 基于两阶段锁2PL和实际串行执行通常是线性一致的**

<a name="obfn-1712998432352"></a>**SSI一致性快照不是线性一致的：不会包括比快照更新的写入；-不会阻塞非写的读。**

<a name="bje8-1711730427157"></a>**依赖线性一致性**

<a name="xyll-1711730652620"></a>**锁定与领导选举**

<a name="2fqs-1712998599719"></a>**领导选举的一种方法：每个节点启动时尝试获取锁，成功者称为领导者。**

<a name="cbzr-1712998723133"></a>**保证锁时线性一致的： zookeeper 和 etcd 协调服务的一致性算法。curator基于zookeeper上更高级别的配方**

<a name="gpva-1711730659968"></a>**约束和唯一性保证**

<a name="9jmj-1712998930168"></a>**这种情况类似于一个锁，锁定用户名。该操作与原子性的cas类似：**

<a name="lhyk-1712999021176"></a>**用户名和邮箱；**

<a name="7sgo-1712999031257"></a>**银行账号不为负数；**

<a name="so5k-1712999045093"></a>**航班剧院预定了同一时间同一位置**

<a name="q05j-1712999070223"></a>**实际应用中，处理这些限制有时可以接受。如调换位置并补偿。**

<a name="7cbv-1711730671963"></a>**跨信道的时序依赖**

<a name="cqkp-1712999245541"></a>**将用户上传的照片降低分辨率以加快下载速度：**

<a name="3zoo-1712999362806"></a>**步骤：消息队列一般针对较短的消息而设计，一张图片可能达到几M.所以步骤为**

<a name="umkb-1712999318589"></a>**1.上传照片-  web server-2.  (store img) 存储文件服务器**  

<a name="er8u-1712999518585"></a>  **| 3. send message  || 5.fetch full size img  6.store resized img**

<a name="iiv4-1712999532781"></a>**消息队列   - 4.deliver message     image resizer**

<a name="0yys-1712999647965"></a>**问题：存储和缩放存在两个不同的信道，没有线性一致的新鲜度保证**

<a name="xtun-1712999768959"></a>**3和4可能比存储服务器内部的复制更快，当5时，可能会看到图像旧版本或者什么都没有，如果处理的是旧版本，则产生不一致。**

<a name="ytt0-1711730433598"></a>**实现线性一致性的系统**

<a name="j997-1712999879559"></a>**单主复制（可能线性一致）protential潜在线性一致：**

<a name="t174-1712999979364"></a>**快照隔离并发错误；**

<a name="hh6o-1712999996439"></a>**脑裂；异步复制延迟，故障切换**

<a name="z3nq-1713000050923"></a>**共识算法（线性一致）：共识算法可以安全实现线性一致性的存储，zookeeper 和 etcd**

<a name="q0kz-1713000066034"></a>**多主复制（非线性一致）：同时多个节点上处理写入，异步复制到其他节点，会产生冲突的写入**

<a name="ca4m-1713030167882"></a>**无主复制（也许不是线性一致的）：Dynamo风格，法定人数读写获得强一致性。通常不完全正确**

<a name="9gst-1711730681011"></a>**线性一致性和法定人数**

<a name="sqvx-1713030399799"></a>**最安全的做法是：假设采用Dynamo风格的无主复制的系统是不能提供线性一致性。**

<a name="vpxf-1711730440465"></a>**线性一致性的代价**

<a name="fqqf-1711730717308"></a>**CAP定理**

<a name="8hzl-1713030564813"></a>**不仅是单主多主复制的后果，任何线性一致性的数据库都有这个问题：**

<a name="7lux-1713030592466"></a>**.应用需要线性一致性，副本因为网络问题断开连接，请求必须等到网络问题解决或直接返回错误（不可用unavailable）**

<a name="48wk-1713031150235"></a>**.网络断开也可独立处理请求（如多主复制），可以在网络问题前保持可用，但其行为不是线性一致的。**

<a name="lsdc-1713031249676"></a>**CAP定理没有帮助：网络分区是不可避免的，所以只能是AP 或 CP。**

<a name="kxsm-1711730728177"></a>**线性一致性和网络延迟**

<a name="lbl2-1713031508671"></a> **线性一致的系统惊人的少。例如多核CPU并没有保证一定能读到第一个线程写入的值（除非使用内存屏障memory barrier或围栏fence）**

<a name="pnsn-1713031585885"></a> **牺牲线性一致性的原因是性能performance. 内存访问先走缓存，副本都是异步更新的，所以失去了线性一致性。**

<a name="8y6v-1713031685808"></a>**搞笑的线性一致性存储不可实现。**

<a name="on5f-1711730057760"></a>**顺序保证**

<a name="dhiv-1713031758875"></a>**写入顺序order of write: 单主复制的主要目的就是复制日志中确定写入顺序。**

<a name="cyfr-1713031815356"></a>**序列顺序serial order：某种序列顺序some sequential order**

<a name="z48k-1711730472679"></a>**顺序与因果**

<a name="khzl-1713031939113"></a>**顺序有助于保持因果关系causality**

<a name="nbes-1713031966982"></a>**一致前缀读：先看到答案再看到问题。违背因cause果effect. 存在因果依赖causal dependency**

<a name="xehj-1713032060272"></a>**更新不存在的记录：3位领导者间的复制，一些写入会压到其他写入。一条记录需被创建才能更新。**

<a name="v1kv-1713032135082"></a>**检测并发写入：A和B并发，则不知道顺序，A和B不知道彼此。**

<a name="ozi8-1713032226341"></a>**快照隔离：写偏差read skew，读取的数据违反因果关系（不可重复读）**

<a name="pgzq-1713032264605"></a>**事务的写偏差write skew：幻读和值班。**

<a name="3ang-1713032756197"></a>**世界杯球赛结果，跨信道的时序依赖。**

<a name="tryg-1713032788961"></a>**因果一致causally：系统服从因果关系锁规定的顺序。**

<a name="niwx-1711730751513"></a>**因果顺序不是全序的**

<a name="x8gk-1713086054855"></a>**全序total order: 自然数更大或更小，总是有序的**

<a name="wvsa-1713086222914"></a>**偏序partially order: 一个集合大于另一个集合，但是其它情况下无法比较**

<a name="u7jq-1713086312064"></a>**线性一致性：操作是全序的，系统表现好像只有一个副本，所有操作都是原子性的。意味对每个操作总能判定发生顺序**

<a name="xa0w-1713086399916"></a>**因果性：两个操作没在彼此之前发生，即并发无法比较顺序，意味着因果关系定义了一个偏序，而不是全序。一些有序一些无序**

<a name="uaxz-1713086531138"></a>**线性一致的数据存储中是不存在并发操作的。确保每个请求都是在唯一时间线上自动处理**

<a name="qs64-1713086635361"></a>**并发意味着时间线会分叉然后合并。操作的偏序：**

<a name="ctkd-1713086670170"></a>**类似git系统，一个提交commit发生在另一个提交之后。分支合并merge会在这些并发创建的提交相融合时创建。**

<a name="qdnf-1711730766239"></a>**线性一致性强于因果一致性**

<a name="dam4-1713086279684"></a>**线性一致性隐含implies着因果关系;**

<a name="uqqx-1711730776113"></a>**捕获因果关系**

<a name="agrw-1713086796608"></a>**为了维持因果性，需确认操作发生在哪个操作之前happened before:**

<a name="rys3-1713086865582"></a>**刑侦决定Y时是否知到X与Y因果关系**

<a name="znup-1713086911030"></a>**检测并发写入：推广版本向量解决因果依赖**

<a name="1ivk-1713086936754"></a>**SSI序列化隔离快照：事务提交时，检测读取是否最新，为此跟踪哪些事务被那些事务锁读取。**

<a name="jsuf-1711730485869"></a>**序列号顺序**

<a name="y9ti-1713091524670"></a>**序列号sequence number或时间戳timestamp**

<a name="qpya-1711730796494"></a>**非因果序列号生成器**

<a name="mtzj-1711730811106"></a>**兰伯特时间戳**

<a name="f8uv-1713091653199"></a>**兰伯特时间戳提供了与因果关系一致的总排序：施行一个全序**

<a name="2ayx-1713091789731"></a>**检测并发写入有着不同目的：区分两个操作是并发的，一个因果依赖另一个。**

<a name="elc6-1711730816628"></a>**光有时间戳排序还不够**

<a name="aw2l-1711730490423"></a>**全序广播**

<a name="axul-1713091937508"></a>**可靠交付reliable delivery：没有消息丢失，如果消息被传递到一个节点，它将被传递到所有节点**

<a name="cruc-1713091989510"></a>**全序交付totally ordered delivery: 消息以相同的顺序传递给每个节点。**

<a name="hp3a-1711730834892"></a>**使用全序广播**

<a name="ztws-1713108978601"></a>**zookeeper和etcd共识服务实际上实现了全序广播**

<a name="i8bk-1713109007327"></a>**状态机复制state machine repliacation: 每个副本都按相同的顺序处理相同的写入。**

<a name="8jch-1713109071990"></a>**与之类似，使用全序广播来实现可序列化的事务：真的串行执行，确定的事务以存储过程来执行，每个节点以相同的顺序处理这些消息。**

<a name="w19a-1713109204107"></a>**以及防护令牌的锁服务，全序广播使得所有消息按顺序一次编号，序列号可当做防护令牌(单调递增)，zookeeper中这个序列号称为zxid;**

<a name="i3vg-1711730844593"></a>**使用全序广播实现线性一致的存储**

<a name="xlae-1711730855140"></a>**使用线性一致性存储实现全序广播**

<a name="y1bv-1711730380233"></a>**分布式事务与共识**

<a name="yt5r-1713109388776"></a>**让几个节点达成一致get serveral nodes to agree on somthing**

<a name="d7t7-1713109479427"></a>**领导选举：避免脑裂**

<a name="frsp-1713109508353"></a>**原子提交atomic commit：多节点事务提交/中止/回滚**

<a name="abk6-1711730509647"></a>**原子提交与两阶段提交2PC**

<a name="0h2f-1713110484428"></a>**原子性可以避免中间态，多对象事务原子性确保二级索引与主数据库保持一致。**

<a name="iqfd-1711730882368"></a>**从单节点到分布式原子提交**

<a name="h1ym-1713110537245"></a>**从数据库的角度看，这是单独的事务，任何跨事务正确性的保证都是应用自己的问题。**

<a name="roa9-1711730906391"></a>**2PC两阶段提交简介**

<a name="vaax-1705118249954"></a>**coodinator协调子事务，子事务单独执行完，在准备阶段询问是否可提交**

<a name="7zwc-1705118288968"></a>**.全部为是，则分别提交。**

<a name="3b8s-1705118337513"></a>**.其中有否，则中断回滚。**

<a name="kpgk-1711730913393"></a>**系统承诺**

<a name="wkui-1713110739239"></a>**一旦协调者做出决定，这一决定是不可撤销的。**

<a name="qhdj-1711730921387"></a>**协调者失败**

<a name="jpd8-1713110804532"></a>**参与者投赞成票后，参与者协调者崩溃，数据库1不知道是否提交或中止。**

<a name="ixzv-1711730924556"></a>**三阶段提交**

<a name="edp3-1713111179295"></a>**阻塞blocking原子提交协议, 2PC可能卡主等待协调者恢复的情况。**

<a name="llyc-1711731148564"></a>**在提交阶段，如果子事务进程crash,或者协调者崩溃的时的解决方案，弱原子性，最终一致性。**

<a name="nlrk-1705118500709"></a>**许多coodinator不支持高可用或者只支持基本的复制**

<a name="xexf-1711730524691"></a>**实践中的分布式事务**

<a name="inqh-1713111548114"></a>**云服务由于其导致的运维问题而选择不实现分布式事务。**

<a name="zuho-1713111590325"></a>**两阶段难以实现安全保证，且导致的运维问题造成性能下降。**

<a name="gf92-1711731287296"></a>**数据库内部的分布式事务**

<a name="jhqw-1705080950920"></a>**VoltDB 与mysql Cluster 的NDB引擎就有这样的内部事务支持。**

<a name="gvng-1713111648038"></a>**异构分布式事务**

<a name="st60-1713111659854"></a>**保证异构数据库的事务更有挑战性**

<a name="btdt-1711730944613"></a>**恰好一次的消息处理**

<a name="rawn-1713111843767"></a>同一个事务中的原子提交消息确认和数据库写入两个操作实现。

<a name="8joh-1713111889782"></a>原子提交消息处理及其副作用，成功之前需重试几次确保有效处理一次。

<a name="7d9r-1713111936062"></a>原子提交协议atomic commit protocl

<a name="qvbk-1711730954739"></a>**XA事务eXtended Architecture**

<a name="0thc-1711731206081"></a>跨异构技术实现两阶段提交的标准，：许多传统关系数据库（包括PostgreSQL，MySQL，DB2，SQL Server和Oracle）和消息代理（包括ActiveMQ，HornetQ，MSMQ和IBM MQ）都⽀持XA。

<a name="otul-1705081462777"></a>XA事务是使⽤**Java事务API（**JTA, Java Transaction API）实现的，⽽许

<a name="wfx9-1705081463074"></a>多使⽤Java数据库连接（**JDBC**, Java Database Connectivity）的数据库驱动，以及许多使⽤Java消息服务（JMS）API的消息代理**都⽀持Java事务API**（JTA）。

<a name="0dfj-1705081511181"></a>Spring事务基于JDBC事务。

<a name="med0-1711730959684"></a>**怀疑时持有锁**

<a name="l5tj-1711731251968"></a>读已提交，数据库事务通常获取待修改的⾏上的⾏级排他锁，以防⽌脏写(值为NULL，事务A先写，事务B写后提交，A回滚，值变NULL)。

<a name="ue7i-1705118474108"></a>在协调者崩溃时，这些锁将会被coodinator永久持有，如果管理员不手动释放。

<a name="ouyq-1711730969007"></a>**从协调者故障中恢复**

<a name="ouur-1713116418144"></a>**唯一的出路是让管理员手动决定提交还是回滚事务**

<a name="gzya-1711730975747"></a>**分布式事务的限制**

<a name="jkt3-1713116480399"></a>**协调者本身就是一种数据库，存储了事务的结果。**

<a name="mcvv-1713116529836"></a>**协调者默认不是高可用的，只有基本的复制**

<a name="h6gt-1713116550997"></a>**应用服务器不再是无状态的了**

<a name="rrrl-1713116568769"></a>**不能检测不同系统间的死锁，且无法与SSI协同工作**

<a name="wbzw-1713116600081"></a>**与构建容错系统的目标背道而驰，分布式事务有扩大失效amplifying failures的趋势**

<a name="npne-1713118985168"></a>**容错共识**

<a name="beiq-1713118985169"></a>**一个或多个节点提议propose某些值，共识算法决定decides采用其中的某个值。**

<a name="pq0x-1713118985170"></a>**一致同意Uniform agreement:  没有两个节点的决定不同-核心 决定了相同的结果，一旦决定不能改变**

<a name="xnwp-1713118985171"></a>**完整性Integrity: 没有节点决定两次-核心**

<a name="2bty-1713118985172"></a>**有效性validity: 如果一个节点决定了值v, 则v由某个节点所提议-排除平凡的解决方案**

<a name="9k32-1713118985173"></a>**终止Termination由所有为崩溃的几点来最终决定值。-活性属性，必须取得进展，即使部分节点出现故障，其他节点也必须达成一致。不超过一般的节点崩溃或不可达**

<a name="scne-1713118985174"></a>**稳健达成共识：只要少于三分之一的节点存在拜占庭故障**

<a name="prxr-1713118985175"></a>**共识算法和全序广播**

<a name="zmcg-1713118985176"></a>**视图戳复制VSR viewstamped repliacation, Paxos，Raft, Zab**

<a name="1u8f-1713118985177"></a>**全序广播相当于重复进行多轮共识：**

<a name="d2l2-1713118985178"></a>**一致同意属性，所有节点决定以相同的顺序传递相同的消息**

<a name="z7u4-1713118985179"></a>**完整性属性，消息不会重复**

<a name="pphb-1713118985180"></a>**有效性属性，消息不会被破坏，也不能凭空编造**

<a name="gqmq-1713118985181"></a>**终止属性,消息不会丢失**

<a name="lxll-1713118985182"></a>**视图戳复制，raft和zab直接实现了全序广播，比重复一次一致one value a time的共识更高效， paxos 下这种优化称为multi-paxos.**

<a name="krsz-1713118985183"></a>**单领导者复制和共识**

<a name="7euj-1713117457957"></a>在第5章中，我们讨论了单领导者复制（参⻅“领导者和追随者”），它将所有的写⼊操作都交给主库，并

<a name="9ytr-1713117492801"></a>以相同的顺序将它们应⽤到从库，从⽽使副本保持在最新状态。这实际上不就是⼀个全序⼴播吗？为什

<a name="35n1-1713117492803"></a>么我们在第五章⾥⼀点都没担⼼过共识问题呢？

<a name="k34n-1713117492805"></a>答案取决于如何选择领导者。如果主库是由运维⼈员⼿动选择和配置的，那么你实际上拥有⼀种**独裁类**

<a name="tzgp-1713117492807"></a>**型**的“共识算法”：只有⼀个节点被允许接受写⼊（即决定写⼊复制⽇志的顺序），如果该节点发⽣故

<a name="kjgb-1713117492809"></a>障，则系统将⽆法写⼊，直到运维⼿动配置其他节点作为主库。这样的系统在实践中可以表现良好，但

<a name="g6oo-1713117492811"></a>它⽆法满⾜共识的**终⽌**属性，因为它需要⼈为⼲预才能取得**进展**

<a name="o7n2-1713117530542"></a>但是还有⼀个问题。我们之前曾经讨论过脑裂的问题，并且说过所有的节点都需要同意是谁领导，否则

<a name="bfcv-1713117531477"></a>两个不同的节点都会认为⾃⼰是领导者，从⽽导致数据库进⼊不⼀致的状态。因此，选出⼀位领导者需

<a name="dbrc-1713117531479"></a>要共识。但如果这⾥描述的共识算法实际上是全序⼴播算法，并且全序⼴播就像单主复制，⽽单主复制

<a name="qeja-1713117531481"></a>需要⼀个领导者，那么...

<a name="lka8-1713117531483"></a>这样看来，要选出⼀个领导者，我们⾸先需要⼀个领导者。要解决共识问题，我们⾸先需要解决共识问

<a name="xeaw-1713117531485"></a>题。我们如何跳出这个先有鸡还是先有蛋的问题？

<a name="90tt-1713118985184"></a>**时代编号和法定人数**

<a name="yumy-1713117567016"></a>迄今为⽌所讨论的所有共识协议，在内部都以某种形式使⽤⼀个领导者，但它们并不能保证领导者是ᇿ

<a name="3hxy-1713117568546"></a>⼀⽆⼆的。相反，它们可以做出更弱的保证：协议定义了⼀个**时代编号（epoch number）**（在Paxos

<a name="rl3b-1713117568548"></a>中称为**投票编号（ballot number）**，视图戳复制中的**视图编号（view number）**，以及Raft中的**任**

<a name="zcxk-1713117568550"></a>**期号码（term number）**），并确保在每个时代中，领导者都是唯⼀的。

<a name="nmn5-1713117568552"></a>每次当现任领导被认为挂掉的时候，节点间就会开始⼀场投票，以选出⼀个新领导。这次选举被赋予⼀

<a name="rw3m-1713117568554"></a>个递增的时代编号，因此时代编号是全序且单调递增的。如果两个不同的时代的领导者之间出现冲突

<a name="rvcj-1713117568556"></a>（也许是因为前任领导者实际上并未死亡），那么带有更⾼时代编号的领导说了算。

<a name="vfaq-1713117568558"></a>在任何领导者被允许决定任何事情之前，必须先检查是否存在其他带有更⾼时代编号的领导者，它们可

<a name="hzjw-1713117568561"></a>能会做出相互冲突的决定。领导者如何知道⾃⼰没有被另⼀个节点赶下台？回想⼀下在“真理在多数⼈⼿

<a name="cf3k-1713117568563"></a>中”中提到的：⼀个节点不⼀定能相信⾃⼰的判断—— 因为只有节点⾃⼰认为⾃⼰是领导者，并不⼀定

<a name="aouf-1713117568565"></a>意味着其他节点接受它作为它们的领导者。

<a name="qywj-1713118985185"></a>**共识的局限性**

<a name="jcey-1713117608200"></a>⼤多数共识算法假定参与投票的节点是固定的集合，这意味着你不能简单的在集群中添加或删除节点。

<a name="citk-1713117610002"></a>共识算法的**动态成员扩展（dynamic membership extension）**允许集群中的节点集随时间推移⽽变

<a name="cbbk-1713117610004"></a>化，但是它们⽐静态成员算法要难理解得多。

<a name="oet6-1713117610006"></a>共识系统通常依靠超时来检测失效的节点。在⽹络延迟⾼度变化的环境中，特别是在地理上散布的系统

<a name="3pqb-1713117610008"></a>中，经常发⽣⼀个节点由于暂时的⽹络问题，错误地认为领导者已经失效。虽然这种错误不会损害安全

<a name="0mpm-1713117610010"></a>属性，但频繁的领导者选举会导致糟糕的性能表现，因系统最后可能花在权⼒倾扎上的时间要⽐花在建

<a name="3vkb-1713117610012"></a>设性⼯作的多得多。

<a name="taga-1713117610014"></a>有时共识算法对⽹络问题特别敏感。例如Raft已被证明存在让⼈不悦的极端情况【106】：如果整个⽹

<a name="xgwm-1713117610016"></a>络⼯作正常，但只有⼀条特定的⽹络连接⼀直不可靠，Raft可能会进⼊领导频繁⼆⼈转的局⾯，或者当

<a name="0pdg-1713117610018"></a>前领导者不断被迫辞职以致系统实质上毫⽆进展。其他⼀致性算法也存在类似的问题，⽽设计能健壮应

<a name="wmjy-1713117610020"></a>对不可靠⽹络的算法仍然是⼀个开放的研究问题。

<a name="8qzt-1713118985186"></a>**成员与协调服务**

<a name="kco9-1713117676659"></a>ZooKeeper和etcd被设计为容纳少量完全可以放在内存中的数据（虽然它们仍然会写⼊磁盘以保证持久

<a name="bx7d-1713117678374"></a>性），所以你不会想着把所有应⽤数据放到这⾥。这些少量数据会通过容错的全序⼴播算法复制到所有

<a name="rktv-1713117678376"></a>节点上。正如前⾯所讨论的那样，数据库复制需要的就是全序⼴播：如果每条消息代表对数据库的写

<a name="zzw0-1713117678378"></a>⼊，则以相同的顺序应⽤相同的写⼊操作可以使副本之间保持⼀致。

<a name="oyah-1713117678380"></a>ZooKeeper模仿了Google的Chubby锁服务【14,98】，不仅实现了全序⼴播（因此也实现了共识），

<a name="dsal-1713117678382"></a>⽽且还构建了⼀组有趣的其他特性，这些特性在构建分布式系统时变得特别有⽤：

<a name="egix-1713117730152"></a>**线性⼀致性的原⼦操作**

<a name="tbjq-1713117730935"></a>使⽤原⼦CAS操作可以实现锁：如果多个节点同时尝试执⾏相同的操作，只有⼀个节点会成功。共识协

<a name="sw1a-1713117730937"></a>议保证了操作的原⼦性和线性⼀致性，即使节点发⽣故障或⽹络在任意时刻中断。分布式锁通常以**租约**

<a name="tnrf-1713117730939"></a>**（lease）**的形式实现，租约有⼀个到期时间，以便在客户端失效的情况下最终能被释放（参阅“进程暂

<a name="eplh-1713117730941"></a>停”）。

<a name="vfgm-1713117730943"></a>**操作的全序排序**

<a name="qgmi-1713117730945"></a>如“领导者与锁定”中所述，当某个资源受到锁或租约的保护时，你需要⼀个防护令牌来防⽌客户端在进

<a name="qp5h-1713117730947"></a>程暂停的情况下彼此冲突。防护令牌是每次锁被获取时单调增加的数字。 ZooKeeper通过全局排序操作

<a name="8ex8-1713117730949"></a>来提供这个功能，它为每个操作提供⼀个单调递增的事务ID（ zxid ）和版本号（ cversion ）

<a name="koeo-1713117730951"></a>【15】。

<a name="uwks-1713117730953"></a>**失效检测**

<a name="garl-1713117730956"></a>客户端在ZooKeeper服务器上维护⼀个⻓期会话，客户端和服务器周期性地交换⼼跳包来检查节点是否

<a name="g30e-1713117730958"></a>还活着。即使连接暂时中断，或者ZooKeeper节点失效，会话仍保持在活跃状态。但如果⼼跳停⽌的持

<a name="ti3d-1713117730960"></a>续时间超出会话超时，ZooKeeper会宣告该会话已死亡。当会话超时（ZooKeeper调⽤这些临时节点）

<a name="golx-1713117730962"></a>时，会话持有的任何锁都可以配置为⾃动释放（ZooKeeper称之为**临时节点（ephemeral**

<a name="yrcg-1713117730964"></a>**nodes）**）。

<a name="oomn-1713117730966"></a>**变更通知**

<a name="nxl7-1713117730968"></a>客户端不仅可以读取其他客户端创建的锁和值，还可以监听它们的变更。因此，客户端可以知道另⼀个

<a name="pakj-1713117730970"></a>客户端何时加⼊集群（基于新客户端写⼊ZooKeeper的值），或发⽣故障（因其会话超时，⽽其临时节

<a name="ixqt-1713117730972"></a>点消失）。通过订阅通知，客户端不⽤再通过频繁轮询的⽅式来找出变更。

<a name="pzpu-1713117730974"></a>在这些功能中，只有线性⼀致的原⼦操作才真的需要共识。但正是这些功能的组合，使得像ZooKeeper

<a name="rv3m-1713117730976"></a>这样的系统在分布式协调中⾮常有⽤。

<a name="4tlb-1713118985187"></a>**将工作分配给节点**

<a name="rvkw-1713117826927"></a>通常，由ZooKeeper管理的数据的类型变化⼗分缓慢：代表“分区 7 中的节点运⾏在 10.1.1.23 上”的

<a name="igbk-1713117797151"></a>信息可能会在⼏分钟或⼏⼩时的时间内发⽣变化。它不是⽤来存储应⽤的运⾏时状态的，每秒可能会改

<a name="bflq-1713117797153"></a>变数千甚⾄数百万次。如果应⽤状态需要从⼀个节点复制到另⼀个节点，则可以使⽤其他⼯具（如

<a name="k5yb-1713117797155"></a>Apache BookKeeper 【108】）。

<a name="tbbj-1713118985188"></a>**服务发现**

<a name="c1wh-1713117870132"></a>ZooKeeper，etcd和Consul也经常⽤于服务发现——也就是找出你需要连接到哪个IP地址才能到达特定

<a name="ps7b-1713117870759"></a>的服务。在云数据中⼼环境中，虚拟机连续来去常⻅，你通常不会事先知道服务的IP地址。相反，你可

<a name="6wf0-1713117870761"></a>以配置你的服务，使其在启动时注册服务注册表中的⽹络端点，然后可以由其他服务找到它们。

<a name="azmc-1713117870764"></a>但是，服务发现是否需要达成共识还不太清楚。 DNS是查找服务名称的IP地址的传统⽅式，它使⽤多层

<a name="c70a-1713117870766"></a>缓存来实现良好的性能和可⽤性。从DNS读取是绝对不线性⼀致性的，如果DNS查询的结果有点陈旧，

<a name="enhw-1713117870768"></a>通常不会有问题【109】。 DNS对⽹络中断的可靠性和可靠性更为重要。

<a name="v8vn-1713117870770"></a>尽管服务发现并不需要共识，但领导者选举却是如此。因此，如果你的共识系统已经知道领导是谁，那

<a name="ef5x-1713117870772"></a>么也可以使⽤这些信息来帮助其他服务发现领导是谁。为此，⼀些共识系统⽀持只读缓存副本。这些副

<a name="bovk-1713117870774"></a>本异步接收共识算法所有决策的⽇志，但不主动参与投票。因此，它们能够提供不需要线性⼀致性的读

<a name="sdj5-1713117870776"></a>取请求。

<a name="1lld-1713118985189"></a>**成员服务**

<a name="plrd-1713118986300"></a>ZooKeeper和它的⼩伙伴们可以看作是成员服务研究的悠久历史的⼀部分，这个历史可以追溯到20世纪

<a name="5q4w-1713117889767"></a>80年代，并且对建⽴⾼度可靠的系统（例如空中交通管制）⾮常重要【110】。

<a name="17wf-1713117889770"></a>成员资格服务确定哪些节点当前处于活动状态并且是群集的活动成员。正如我们在第8章中看到的那

<a name="quas-1713117889772"></a>样，由于⽆限的⽹络延迟，⽆法可靠地检测到另⼀个节点是否发⽣故障。但是，如果你通过⼀致的⽅式

<a name="vojh-1713117889774"></a>进⾏故障检测，那么节点可以就哪些节点应该被认为是存在或不存在达成⼀致。

<a name="np5u-1713117889776"></a>即使它确实存在，仍然可能发⽣⼀个节点被共识错误地宣告死亡。但是对于⼀个系统来说，在哪些节点

<a name="jks7-1713117889778"></a>构成当前的成员关系⽅⾯是⾮常有⽤的。例如，选择领导者可能意味着简单地选择当前成员中编号最⼩

<a name="tvgk-1713117889780"></a>的成员，但如果不同的节点对现有成员的成员有不同意⻅，则这种⽅法将不起作⽤。

<a name="crbx-1713118986331"></a><a name="e8vp-1713117935189"></a>像ZooKeeper这样的⼯具为应⽤提供了“外包”的共识、故障检测和成员服务。它们扮演了重要的⻆⾊，

<a name="2omq-1713117935440"></a>虽说使⽤不易，但总⽐⾃⼰去开发⼀个能经受第8章中所有问题考验的算法要好得多。如果你发现⾃⼰

<a name="vdni-1713117935442"></a>想要解决的问题可以归结为共识，并且希望它能容错，使⽤⼀个类似ZooKeeper的东⻄是明智之举。

<a name="y9xj-1713118594943"></a>save

<a name="rehq-1705081588086"></a><a name="46k8-1705118453932"></a>**第三部分：衍生数据**

<a name="rboc-1716226529015"></a>**记录和衍生数据系统**

<a name="cmdh-1716226737947"></a>**从高层次看，存储和处理数据的系统可以分为两大类**

<a name="1dmv-1716226552894"></a>**记录系统System of record**

<a name="dh96-1716226777418"></a>**真相源source of truth. 记录用户输入新数据，标准化normalized**

<a name="qjlf-1716226568395"></a>**衍生数据系统Derived data system**

<a name="igtl-1716226871151"></a>**缓存cache, 衍生数据是冗余的，重复了已有的信息。**

<a name="ypgi-1716226504586"></a><a name="0bgb-1716226496297"></a>**10.批处理**

<a name="yygb-1720542683707"></a>**服务（在线系统）：高可用性，性能指标-响应时间**

<a name="goo7-1720542700859"></a>**批处理系统（离线系统）：定时任务job，性能指标-吞吐量**

<a name="mv2a-1720542952432"></a>**流处理系统（准实时系统）：介于在线离线系统之间**

<a name="6lu4-1716228538928"></a>**使用Unix工具的批处理**

<a name="hyii-1716228597300"></a>**分析简单日志**

<a name="smoq-1720543218731"></a>**Unix命令链：网站上找到五个最受欢迎的网页（nginx/access.log）**

cat /var/ log/ nginxl access.log |#1

`    `awk '{print $7}’│#2

`    `sort

`            `|#3

`    `uniq -c

`         `|#4

`    `sort -r -n

`      `|#5

`    `head -n 5

`        `#6



1．读取日志文件

2\.将每一行按空格分割成不同的字段，每行只输出第七个字段，恰好是请求的URL。在我们的例子中是/css/typography.css 。

3\.按字母顺序排列请求的URL列表。如果某个URL被请求过n次，那么排序后，文件将包含连续重复出现n次的该URL。

4\. uniq命令通过检查两个相邻的行是否相同来过滤掉输入中的重复行。(-c则表示还要输出一个计数器:对于每个不同的URL，它会报告输入中出现该URL的次数。

5．第二种排序按每行起始处的数字(-n）排序，这是URL的请求次数。然后逆序（-r)返回结果，大的数字在前。

<a name="cxil-1720543264072"></a>6．最后，只输出前五行（-n 5)，并丢弃其余的。该系列命令的输出如下所示:

<a name="ukyi-1716228816049"></a>**命令链与自定义程序Ruby**

counts = Hash. new ( o )    #1

File.open( ' /var/log/nginx/access.log ' ) do |file |

`    `file.each do | linel

`        `url = line.split[ 6]# 2

`        `counts [ url] += 1 #3

`      `end

end

top5 = counts.map{ |url,count/ [count,url] }.sort.reverse[0...5] #4

top5.each{ |count, url/ puts "#{count} #{url} "}  #5

1\. counts是一个存储计数器的哈希表，保存了每个URL被浏览的次数，默认为0。

2\.逐行读取日志，抽取每行第七个被空格分隔的字段为URL(这里的数组索引是6，因为Ruby的数组

索引从o开始计数)

3．将日志当前行中URL对应的计数器值加一。

4\.按计数器值(降序)对哈希表内容进行排序，并取前五位。

<a name="rvvh-1720543511029"></a>5.打印出前五个条目。

<a name="cnuw-1716228829632"></a>**排序 VS 内存中的聚合**

<a name="siiu-1720543940755"></a>**工作集working set(作业需要随机访问的内存大小)，单个url 重复出现百万次，哈希表性能好**

<a name="lms0-1720544023798"></a>**工作集大于内存，排序优，与SSTables 和 LSM树一样，内存聚合归并排序，GNU 中的sort通过溢出至磁盘自动应该大于内存大额数据集，瓶颈可能是磁盘io。-MQ的死信处理也是溢出到磁盘。**

<a name="mgei-1716228613042"></a>**Unix哲学**

<a name="zkda-1720544383841"></a>一部分——这一组设计原则在Unix用户与开发者之间流行起来，该哲学在1978年表述如下【12,13】:

<a name="xxwb-1720544385739"></a>1.让每个程序都做好一件事。要做一件新的工作，写一个新程序，而不是通过添加"功能"让老程序复杂化。

<a name="gwvc-1720544385743"></a>2期待每个程序的输出成为另一个程序的输入。不要将无关信息混入输出。避免使用严格的列数据或二进制输入格式。不要坚持交互式输入。

<a name="krq3-1720544385745"></a>3.设计和构建软件，甚至是操作系统，要尽早尝试，最好在几周内完成。不要犹豫，扔掉笨拙的部分，重建它们。

<a name="qmam-1720544385747"></a>4.优先使用工具来减轻编程任务，即使必须曲线救国编写工具，且在用完后很可能要扔掉大部分。这种方法――**自动化，快速原型设计，增量式迭代，对实验友好，将大型项目分解成可管理的块**—一听起来非常像今天的**敏捷开发**和**DevOps**运动。奇怪的是，四十年来变化不大。

<a name="ofel-1720544385749"></a>sort工具是一个很好的例子。可以说它比大多数编程语言标准库中的实现〈(即使有很大好处，也不会溢出到磁盘或使用多线程）要更好。然而，单独使用sort几乎没什么用。它只能与其他Unix工具(如uniq）结合使用。

<a name="x4qr-1720544385751"></a>像bash这样的Unix shell可以让我们轻松地将这些小程序组合成令人讶异的强大数据处理任务。

<a name="07ut-1720544385753"></a>尽管这些程序中有很多是由不同人群编写的，但它们可以灵活地结合在一起。Unix如何实现这种可组合性?

<a name="sk3b-1716228852580"></a>**统一的接口**

<a name="33ju-1720874904091"></a>**Unix中统一的接口是一个文件file**

<a name="yogq-1720875513301"></a>**ASCII文本，\n 分隔，**

<a name="7fvb-1720875542091"></a>**CSV， ，号分隔**

<a name="3oxq-1716228869387"></a>**逻辑与布线相分离**

<a name="0zy9-1720876020643"></a>**松耦合loose coupling**

<a name="226j-1720876035472"></a>**晚期绑定late binding**

<a name="zedb-1720876065554"></a>**控制反转inversion of control**

<a name="ftj8-1716228879278"></a>**透明度与实验**

<a name="bkmj-1720876137206"></a>Unix使查看正在发生的事情变得非常容易：

<a name="ydul-1720876167067"></a>输入文件通常视为不可变，即可随意运行命令

<a name="hktc-1720876202052"></a>任何时候结束管道，输出到less

<a name="d0kj-1720876219720"></a>输出写入文件，作为下一个阶段输入-可重启后面阶段而无需全部重启

<a name="puey-1720876267234"></a>Unix局限：只能运行为一台机器上。  Hadoop应运而生。

<a name="djdy-1716228554334"></a>**MapReduce和分布式文件系统**

<a name="illh-1720876369554"></a>**MapReduce像是分布在数前台机器上的Unix。**

<a name="e1cy-1720876447842"></a>**Hadoop的Map-Reduce视线中，文件系统成为HDFS,基于google文件系统GFS的开源实现。**

<a name="mapk-1720876955975"></a>**Amazon S3，  Azure blob** 

<a name="kdge-1716228625984"></a>**MapReduce作业执行**

<a name="vleh-1720877349422"></a>**Mapper在每条输入记录上调用一次,从输入记录中提取键值（提取键值）**

<a name="aol7-1720877397533"></a>**Reduce拉取Mapper生成的键值对，收集属于同一个键的所有值。（收集同键的所有值）**

<a name="kv6u-1716231603620"></a>**分布式执行MapReduce**

<a name="wy7r-1720877483243"></a>**即在不同服务器上执行mapper reduce 的task。**

<a name="d0qe-1716231619319"></a>**MapReduce工作流**

<a name="rvme-1720877910897"></a>**workflow。一系列命令，输出写入临时文件，下一个命令从临时文件中读取-物化中间状态**

<a name="pyoc-1716228643855"></a>**Reduce端连接与分组**

<a name="1pza-1716231634942"></a>**用户活动事件**

<a name="4l72-1720878002631"></a>**左侧是事件日志/活动事件activity events/点击流事件clickstream evnets**

<a name="hivt-1720878131008"></a>**右侧是用户数据库**

<a name="cvii-1720878237531"></a>**用户行为日志与用户档案的连接**

<a name="eiqe-1720878248508"></a>**原始:逐个遍历活动事件关联查询。缺点：吞吐量受限数据库服务器且容易压垮**

<a name="iueg-1720878322010"></a>**改良：获取用户数据库副本（ETL进程从数据库备份中提取数据，参考数仓），放在同一个分布式文件系统中。将用户数据库存储HDFS中的一组文件中，用户活动记录存储另一组文件中，**

<a name="ruua-1720878498786"></a>**并能用MapReduce将左右相关记录集中到同一个地方进行高效处理。**

<a name="fihy-1716231663765"></a>**排序合并连接**

<a name="q51q-1720947527716"></a>**1.map提取键值(userid-url  usrid-do)和reduce(userid all url do)**

<a name="4kvv-1720947648039"></a>**2.二次排序secondary sort ：对1的合并按时间戳排序**

<a name="j8br-1720947805879"></a>**排序合并连接sort-merge join: reduce一次处理一个特定用户所有记录，只需将一条用户记录保存在内存中，无需发送网络请求**

<a name="8vrk-1716231670998"></a>**把相关数据放在一起**

<a name="t1tc-1720947947656"></a>**Mapper和排序过程确保特定用户id连接操作的必须数据都放在同一个地方**

<a name="9j4s-1716228658160"></a>**GROUP BY**

<a name="a6wg-1720952083180"></a>**除了连接之外，“把相关数据放在一起”的常见模式是记录分组。SQL中的Group By**

<a name="qa24-1716231688547"></a>**处理倾斜**

<a name="f55j-1720952155251"></a>**名流热点数据hot spot**

<a name="julg-1720952222343"></a>**参考负载倾斜和消除热点**

<a name="akfb-1720952286891"></a>**Mapper将热键的关联记录随机发送到几个Reduce之一**

<a name="2tox-1716228671225"></a>**Map端连接**

<a name="qiil-1720971178915"></a>**预处理输入数据**

<a name="wjhj-1716231713037"></a>**广播散列连接**

<a name="k3se-1720971260954"></a>**broadcast hash join**

<a name="su27-1716231723170"></a>**分区散列连接**

<a name="5h9a-1720971514797"></a>**Map桶端连接bucketd map jons**

<a name="ftdq-1716231736611"></a>**Map端合并连接**

<a name="yrmc-1716231744413"></a>**MapReduce工作流与Map端连接**

<a name="zzir-1716228678980"></a>**批处理工作流的输入**

<a name="hiqn-1720971586510"></a>**OLTP ：查找少量记录，使用索引，呈现给用户**

<a name="cqba-1720971612883"></a>**OLAP：扫描大量记录，执行分组与聚合，输出有着报告的形式，商业决策的分析。**

<a name="bwjf-1716231761454"></a>**建立搜索索引**

<a name="lypn-1720971694941"></a>**MapReduce最初作为google搜索引擎的索引**

<a name="iijq-1720971776882"></a>**全文搜索和模糊索引  Lucene**

<a name="vcun-1720971828838"></a>**分区和二级索引**

<a name="8fix-1716231782091"></a>**键值存储作为批处理输入**

<a name="audd-1716231802005"></a>**批处理输入的哲学**

<a name="6i34-1720972317458"></a>**视为不可变且避免副作用：**

<a name="zciu-1720972319614"></a>**人类容错human fault tolerance**

<a name="oolm-1720972319615"></a>**最小化不可逆性mininizing irreversibility**

<a name="lp33-1716228684462"></a>**Hadoop与分布式数据库的对比**

<a name="g0vj-1720972341966"></a>**Hadoop 像Unix的分布式版本，HDFS是它的文件系统，而MapReduce是Unix进程的怪异实现**

<a name="gjbt-1720972427948"></a>**MapReduce论文发表前，并行连接算法已在数据库实现-大规模并行处理MPP massively parallel processing** 

<a name="go7m-1720972523351"></a>**Gamma database machine, Teradata, Tandem NonStop SQL**

<a name="5mnr-1720972551600"></a>**区别：MMP专注一组及骑行并行执行分析SQL 查询**

<a name="gx7b-1720972580058"></a>**MapReduce和分布式文件系统的组合是一个可以运行任意程序的通用操作系统**

<a name="eebl-1716231817367"></a>**存储多样性**

<a name="5lga-1720972673599"></a>**数据湖data lake / 企业数据中心enterprise data hub**

<a name="jrhw-1720972777529"></a>**Hadoop 常用于实现数仓ETL Extract, Transform, Load**

<a name="ysfv-1716231826972"></a>**处理模型多样**

<a name="kwz4-1716231831752"></a>**针对频繁故障设计**

<a name="p0zx-1716228568687"></a>**MapReduce之后**

<a name="wcyn-1721117329960"></a>**建立在MapReduce上的高级编程模型**

<a name="l9ug-1721117359714"></a>**Pig，Hive, Cascading, Crunch**

<a name="bz2s-1721117576614"></a>**流处理：加速批处理的另一种方法**

<a name="fvak-1716228706372"></a>**物化中间状态**

<a name="npb7-1721117756510"></a>**中间状态intermediate state**

<a name="0rlu-1721117876651"></a>**物化materialization:中间态写入文件的过程**

<a name="fnqf-1721117967688"></a>**MapReduce完全物化中间态的方法不足：**

<a name="pood-1721117984973"></a>**只有在前驱作业生成其输入完成时才能启动**

<a name="iljf-1721118032959"></a>**mapper通常是多余的：仅仅读取由Reducer写入的同样文件**

<a name="tghz-1721118071785"></a>**临时文件（数据）被复制到多个节点**

<a name="aer2-1721118148615"></a>**解决：数据流引擎**

<a name="sdac-1716231877023"></a>**数据流引擎**

<a name="4gu5-1721118111495"></a>**分布式批处理新引擎：**

<a name="nfnv-1721118162692"></a>**spark,  Flink: 独立的网络通信层，调度器，用户向API**

<a name="0kbz-1721123564974"></a>**Tez : 薄库，依赖YARN shuffle服务实现节点间的数据复制**

<a name="jojo-1721118227522"></a>**dataflow engines模型:**

<a name="kstp-1721118246090"></a>**函数/算子operators: 一个算子的输出连接到另一个算子的输入**

<a name="zbrh-1721118327524"></a>**优点：**

<a name="8oqo-1721118330975"></a>**排序等昂贵工作只需在实际需要地方执行，不是默认在Map和Reduce阶段间**

<a name="amzf-1721118375240"></a>**没有不必要的Map任务**

<a name="bunw-1721118382779"></a>**连接和数据依赖都是显示声明的**

<a name="bzui-1721122836028"></a>**算子中间态足以保存内存或写入本地磁盘，比HDFS需要更少I/O**

<a name="ka7f-1721123164712"></a>**算子可在输入就绪后立即执行，不许等待前驱完成**

<a name="rmr3-1721123191298"></a>**MapReduce为每个任务启动新JVM, 而df enginer可重用现有JVM，减少启动开销**

<a name="mp4i-1721123431562"></a>**执行速度更快**

<a name="2cxo-1721123304059"></a>**使用：**

<a name="vyfa-1721123442398"></a>**算子是Map和Reduce的泛化/抽象，相同处理代码可在任意引擎上运行**

<a name="qxck-1721123483308"></a>**Pig Hive Casacding中实现的工作流无需修改代码，修改配置，从MapReduce切换到Tez 或spark.**

<a name="glfr-1716231882229"></a>**容错**

<a name="neqa-1721499456929"></a>**重启，算子重新计算**

<a name="npsg-1716231884238"></a>**关于物化的讨论**

<a name="dvkh-1716228727874"></a>**图与迭代处理**

<a name="y476-1721499725472"></a>**图数据模型常用于机器学习应用**

<a name="ld62-1721499760165"></a>**图形算法PageRank:根据连接到某个网页的其他网页来估计该网页的流行度**

<a name="et5r-1721499798288"></a>**闭包传递transitive clousure: 重复跟进标明地点归属关系的边，生成数据库中北美地点列表**

<a name="x4m1-1721499995671"></a>**MapReduce低效：没考虑算法迭代性**

<a name="lf5y-1716231892007"></a>**Pregel处理模型**

<a name="1faf-1721499959178"></a>**图批处理的优化：批量同步并行（BSP）计算模型。**

<a name="3mh8-1721500149918"></a>**Pregel模型：Google的Pregel论文推广了处理图的方法。Apache Giraph , Spark GraphX API 和 Flink Gelly API**

<a name="pxnd-1716231909468"></a>**容错**

<a name="v8gr-1716231912877"></a>**并行执行**

<a name="cxqk-1716228736349"></a>**高级API和语言**

<a name="qlnr-1721841646688"></a>**Hive,pig, Cascading,Crunch等高级语言和API, Tez**

<a name="dfa6-1716231923208"></a>**向声明式查询语言的转变**

<a name="zman-1721841903902"></a>**声明式declarative**

<a name="inea-1721841971310"></a>**与SQL的完全声明式查询有很大的区别：**

<a name="ahki-1721842021736"></a>**围绕回调函数的概念建立，自由调用任意代码来决定输出什么。**

<a name="bdyf-1721842047384"></a>**可基于大量已有库的生态系统创作： 解析、自然语言分析，图像分析以及运算数值算法或统计算法等。**

<a name="m2pu-1716231937991"></a>**专业化的不同领域**

<a name="wpot-1721842227412"></a>**空间算法：最近邻搜索K-nearest neghbors**

<a name="a2en-1721931596260"></a><a name="iwmv-1721931597264"></a>**11.流处理**

<a name="yeid-1722103475505"></a>**流处理Stream processing: 当事件发生时就可以立即处理**

<a name="08iq-1721844360659"></a>**传递事件流**

<a name="n0th-1722103658739"></a>**事件event：流处理的上下文件记录**

<a name="titb-1722103707652"></a>**生产者producer/发布者publisher/发送者sender**

<a name="yhbb-1722103745716"></a>**消费者consumer/订阅者subscribers/接收者recipients**

<a name="jdqp-1722103794393"></a>**主题topic/流stream：相关事件的聚合**

<a name="2buw-1722103875913"></a>**通知机制：数据库触发器trigger(算是弥补机制)、消息传递系统messaging system**

<a name="ipga-1721932434160"></a>**消息系统**

<a name="qm3o-1722104029796"></a>**两个关键问题：**

<a name="sztq-1722104046748"></a>**1.生产者快于消费者：丢掉消息/将消息放入缓冲队列/背压backpressure(流量控制flow control) 阻塞生产者，以免其发送更多消息**

<a name="5ycq-1722104289674"></a>**2.节点崩溃或脱机，是否有消息丢失： 持久性，高吞吐和低延迟则接收丢失**

<a name="cj2t-1721932544748"></a>**直接从生产者传递给消费者**

<a name="hjhp-1722104612024"></a>**直接网络通信，而不通过中间节点：**

<a name="0ggy-1722104631748"></a>**UPD组播，金融行业，低延时，不可靠，应用层协议可恢复丢失的包（生产者必须记住发送的包，按需重新发送）**

<a name="hnj8-1722104735615"></a>**无代理的消息库，ZeroMQ、nanomsg, TCP或IP多播**

<a name="pcd7-1722104800545"></a>**StatsD 和 Brubeck 使用UDP**

<a name="3se2-1722104863261"></a>**消费者在网络上公开了服务，生产者可以直接发送HTTP和RPC请求将消息推送给使用者webhooks.**

<a name="jwkh-1721932555905"></a>**消息代理**

<a name="dtlb-1722106424439"></a>**消息代理message broker(也称为消息队列message queue)**

<a name="fyus-1721932559957"></a>**消息代理与数据库对比**

<a name="aj3x-1722106519844"></a>**.数据存储：数据库保留数据直至显示删除；大多数消息代理在消息成功传递给消费者时地总删除**

<a name="pkoh-1722106591225"></a>**.删除消息快，所以队列可以很短。如过缓冲很多消息可能会溢出到磁盘，吞吐量会下降**

<a name="lfst-1722106688956"></a>**.匹配方式：数据库通常支持二级索引和各种搜索数据的方式；消息代理按照模式匹配订阅子集**

<a name="q13l-1722106755764"></a>**.最新数据：数据库通常支持事务，基于某个时间点数据快照；消息代理不支持任意查询，有新消息会通知客户端**

<a name="v0lh-1721932568637"></a>**多个消费者**

<a name="enlv-1722191268259"></a>**负载均衡load balance: 多个客户端从同一个队列中消费。JMS中称为共享订阅shared subscripiton**

<a name="bjqd-1722191397355"></a>**扇出fan-out:将每条消息传递给多个消费者**

<a name="aoas-1721932573289"></a>**确认与重新交付**

<a name="8lsc-1723155930519"></a>**消息代理使用确认acknowlegements:客户端需显示告知代理消息处理完毕的时间，代理将消息从队列中移除。**

<a name="w6ac-1723156157534"></a>**确认丢失：需一种原子提交协议才能处理，如分布式事务。**

<a name="zlnz-1723156224601"></a>**负载均衡与重传的组合不可避免导致消息顺序(JMS，AMQP标准要求保留消息的顺序。)重新排序**

<a name="fovj-1725028626326"></a>**解决：每个消费者使用单独的队列-即不适用负载均衡功能**

<a name="3kzh-1725028667923"></a>**消息完全独立，消息重排序并不是个问题，消息之间存在因果依赖关系则是个重要问题**

<a name="9bmj-1721932438668"></a>**分区日志**

<a name="xree-1725028818863"></a>**消息传递/不留痕迹：网络数据包 和 消息代理 (可抓包和日志持久)**

<a name="sbbo-1725028858585"></a>**持久化：数据库和文件系统，显式删除前将永久记录**

<a name="n6lq-1725028981222"></a>**消息代理log-base message brokers: 既有数据库的持久化，又有消息传递的低延迟通知。**

<a name="keft-1721932590686"></a>**使用日志进行消息存储**

<a name="tlnm-1725029031868"></a>**生产者通过将消息追加到日志末尾来发送消息，消费者通过以此读取日志来接收消息。**

<a name="1606-1725029123561"></a>**Unix tail -f 监视文件被追加写入的数据就是这样工作的。**

<a name="aq8x-1725029525384"></a>**Apache Kafka, Amazon Kinesis Streams , Twitter DistributedLog都是基于日志的消息代理**

<a name="0wz5-1725029598472"></a>**Google Cloud Pub/Sub在架构上类似，单对外暴露的是JMS风格的API，而不是日志抽象**

<a name="zqkl-1725029648581"></a>**尽管写入磁盘，但通过跨多台机器分区，每秒能实现数百万消息的吞吐量，并通过复制来实现容错性。**

<a name="pr6y-1721932607757"></a>**日志与传统消息相比**

<a name="i3q5-1725115574888"></a>**天然支持扇出式消息传递：过个消费者独立读取日志，而不相互影响**

<a name="ymqj-1725115609372"></a>**负载平衡：读取消息不会从日志中删除，代理可以将整个分区分配给消费者组中的节点，而不是单挑消息分配给客户端。**

<a name="o0ft-1721932621047"></a>**消费者偏移量**

<a name="emow-1725115793168"></a>**和单领导者数据库复制中常见的日志序列号非常相似，代理无需跟踪每条消息，只需定期记录消费者偏移即可。有助于提高基于日志的系统吞吐量**

<a name="gmal-1725115911246"></a>**问题：消费者节点失效而没有记录偏移量，重启后这些消息将被处理两次。本章后续讨论。**

<a name="ipmx-1721932629330"></a>**磁盘空间使用**

<a name="5ep6-1725115987947"></a>**只追加写入日志，回收时将旧段删除或移动到归档存储**

<a name="kjgm-1725116313754"></a>**问题，消费者跟不上生产者，指向删除段，错过一些消息。**

<a name="k3hi-1725116359622"></a>**日志实现一个有限大小的缓冲区：循环缓冲区circular buffer/环形缓冲区，填满时将丢弃旧消息**

<a name="jjma-1725116440115"></a>**设 大型硬盘容量为 6TB, 顺序写入为150MB/s， 最快需要约11小时填满磁盘，之后开始覆盖旧消息。实践中的部署很少能用满磁盘的写入带宽。所以通常可保留一个几天甚至几周的日志缓冲区**

<a name="bdoa-1725116521841"></a>**以上保留多长时间的消息，日志吞吐量或多或少保持不变，因为每个消息都写入磁盘。**

<a name="rxx7-1725116637183"></a>   **而默认将消息保存在内存中，当队列很短，系统很快；当系统开始写入磁盘，就慢得多，所以吞吐量取决于保留的历史数量。**

<a name="91b6-1721932634947"></a>**当消费者更不上生产者时**

<a name="dztq-1725116764093"></a><a name="6tnb-1721932645175"></a>**重播旧信息**

<a name="rnwj-1721932350699"></a>**流与数据库**

<a name="ehyq-1721932450135"></a>**保持系统同步**

<a name="1ako-1721932460819"></a>**变更数据捕获**

<a name="xkpl-1721932670593"></a>**变更数据捕获的实现**

<a name="uxpn-1721932683846"></a>**初始快照**

<a name="j0w6-1721932690312"></a>**日志压缩**

<a name="5pqr-1721932694290"></a>**变更流的API支持**

<a name="qkmx-1721932472062"></a>**事件溯源**

<a name="vydq-1721932714045"></a>**从时间日志中派生出当前状态**

<a name="xbwr-1721932732154"></a>**命令和事件**

<a name="k3v8-1721932742549"></a>**状态，流和不变形**

<a name="diql-1721932751200"></a>**从同一事件日志中派生多个视图**

<a name="tzcl-1721932772042"></a>**并发控制**

<a name="urmz-1721932775107"></a>**不变性的限制**

<a name="nbcs-1721932419014"></a>**流处理**

<a name="jf4x-1721932507881"></a>**流处理的应用**

<a name="80rp-1721932792357"></a>**复合时间处理**

<a name="6jjt-1721932799443"></a>**流分析**

<a name="5iog-1721932801692"></a>**维护物化视图**

<a name="0asi-1721932807278"></a>**在流上搜索**

<a name="10bm-1721932817553"></a>**消息传递和RPC**

<a name="oca5-1721932519502"></a>**时间推理**

<a name="is6l-1721932844579"></a>**事件时间和处理时间**

<a name="aue5-1721932851975"></a>**知道什么时候准备好**

<a name="vsi1-1721932859473"></a>**你用的是谁的时钟**

<a name="gryf-1721932868260"></a>**窗口的类型**

<a name="jbet-1721932523864"></a>**流式连接**

<a name="eaux-1721932880085"></a>**流流连接(窗口连接)**

<a name="hixz-1721932915139"></a>**流表连接(流扩展)**

<a name="zbsv-1721932945841"></a>**表表连接(维护物化视图)**

<a name="xqtb-1721932962310"></a>**连接的时间依赖性**

<a name="v1om-1721932530009"></a>**容错**

<a name="pqfe-1721932996846"></a>**微批量与存档点**

<a name="elio-1721933013244"></a>**原子提交再现**

<a name="bwyd-1721933023622"></a>**幂等性**

<a name="dijm-1721933026909"></a>**失败后重建状态**

<a name="lk3f-1721118456500"></a><a name="m2ie-1721118456661"></a>技术选型应该区分使用场景，不是技术不行，而是哪些技术更适合哪些场景。新技术的出现就是为了解决新的场景下出现的问题。 

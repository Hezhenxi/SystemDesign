# 系统设计与优化&amp;DDIA :see_no_evil:
## 目录


<a name="3060-1621846615933"></a><a name="3kvn-1704771587695"></a>[一.数据库设计](#jeyl-1677787446995)

<a name="p5fw-1704771587697"></a>[1. 关系型数据库](#5hya-1677787446996)

<a name="y9dd-1704771587699"></a>[.E-R图，由台湾工程师提出的设计概念](#ohc5-1621692571287)

<a name="ekou-1704771587701"></a>[.流程图-业务逻辑相关，系统用户动作。抽象出E-R图](#5ocb-1645598528868)

<a name="iwsv-1704771587703"></a>[1.1 E-R图 ](#gzqe-1677787446997)

<a name="ygoy-1704771587705"></a>[1.根据名词抽象出实体](#r1ac-1621692724628)

<a name="laql-1704771587707"></a>[2.名词找属性](#d2fl-1621692745600)

<a name="1tmw-1704771587710"></a>[3.实体间联系](#dwkp-1621692752824)

<a name="jhju-1704771587712"></a>[1.2 转化成数据库设计（公式）](#c2cy-1677787446998)

<a name="vgur-1704771587714"></a>[.1 对1 关系 往记录少的乙方加主键](#xmox-1621692858500)

<a name="o8am-1704771587716"></a>[.1对n 关系 ，往 n 实体加关联主键 ](#mdr8-1621692924289)

<a name="auhn-1704771587718"></a>[. n对 m 关系，需要一个关联表作映射关联](#hd3i-1621692960576)

<a name="cquf-1704771587720"></a>[二.系统优化](#cdso-1677787447000)

<a name="bfpm-1704771587722"></a>[应用整体的优化](#3qep-1642647362896)

<a name="6jig-1704771587724"></a>[-cpu -> 纳秒级别](#knge-1642647371136)

<a name="voem-1704771587726"></a>[1.多线程和并发编程](#ovup-1704437622969)

<a name="0l9z-1704771587728"></a>[2.JNI ](#ufpl-1704437634986)

<a name="w9qo-1704771587730"></a>[3.JIT/AOT编译](#ixb5-1704437634987)

<a name="bn3p-1704771587732"></a>[4.算法优化](#kr1f-1704437634988)

<a name="ethv-1704771587734"></a>[-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)](#1xur-1642647384168)

<a name="x2dm-1704771587736"></a>[1.JVM内存管理](#7hi9-1704437851514)

<a name="utk7-1704771587738"></a>[2.缓存](#te7c-1704437851799)

<a name="bg3w-1704771587740"></a>[3.消息中间件](#bqty-1704437851800)

<a name="dfo5-1704771587742"></a>[-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)](#ziti-1642647439005)

<a name="vtia-1704771587744"></a>[1.减少磁盘io](#zups-1704437900079)

<a name="dtgz-1704771587746"></a>[2.数据压缩   ](#u3ok-1704438035018)

<a name="tyh7-1704771587748"></a>[-网络传输/系统交互 -> 秒级 (减少io，连接池化) ](#irbp-1642647458856)

<a name="0e3k-1704771587750"></a>[1.减少网络请求   ](#6qil-1704438276193)

<a name="m7ja-1704771587752"></a>[2.使用CDN](#p5dt-1704438283633)

<a name="newn-1704771587754"></a>[3.Sockets异步通信                                      ](#zhp8-1704438283634)

<a name="drb1-1704771587756"></a>[项目架构层面的优化](#3l0l-1704424353262)

<a name="g3m4-1704771587758"></a>[-多级缓存](#8o8s-1704424396933)

<a name="gwh0-1704771587760"></a>[-应用层](#trcg-1704438366333)

<a name="exjc-1704771587762"></a>[代码优化](#68oa-1704438530062)

<a name="spf0-1704771587764"></a>[数据库优化](#clmf-1704438530257)

<a name="usqj-1704771587766"></a>[日志优化](#md03-1704438530259)

<a name="jysr-1704771587768"></a>[-监控与调优](#ocux-1704438477879)

<a name="jmqa-1704771587770"></a>[性能监控：](#vdq2-1704438556836)

<a name="6eu0-1704771587772"></a>[分析和调优](#t29d-1704438557094)

<a name="wkdr-1704771587774"></a>[-分布式系统架构](#ukjf-1704424419442)

<a name="vwa6-1704771587776"></a>[  .负载均衡](#a0bx-1704438677201)

<a name="03z2-1704771587778"></a>[分布式缓存](#xn9x-1704438687994)

<a name="kvsh-1704771587780"></a>[服务降级和容错](#zcdp-1704438687996)

<a name="y0h5-1704771587782"></a>[读写层面](#six7-1642647372926)

<a name="ctdt-1704771587784"></a>[.读优化](#g4uv-1704732583614)

<a name="lxlz-1704771587786"></a>[1.缓存](#uuzh-1704732602620)

<a name="vglj-1704771587788"></a>[2.索引](#qobc-1704732605892)

<a name="swrl-1704771587790"></a>[3.减少io/批量读](#zlg9-1704732609048)

<a name="830l-1704771587793"></a>[4.减少多余数据加载/列式存储读](#fpjd-1704732631316)

<a name="hau7-1704771587795"></a>[.写优化](#oyob-1704732598377)

<a name="9f6c-1704771587797"></a>[1.异步写](#6jmb-1704732509150)

<a name="ys7a-1704771587799"></a>[2.并发写](#tkwp-1704732723564)

<a name="gnlq-1704771587801"></a>[3.批量写](#hewz-1704732862030)

<a name="xcad-1704771587803"></a>[4.优化算法和数据结构](#ccd8-1704732727854)

<a name="hzqh-1704771587805"></a>[5.缓存写](#eqd9-1704732736281)

<a name="pwgt-1704771587807"></a>[6.非阻塞io](#hyq8-1704732768916)

<a name="sgtl-1704771587809"></a>[1.分控系统优化复盘](#tncv-1677787447001)

<a name="gd4s-1704771587811"></a>[1.1 数据库系统](#ydq7-1677787447002)

<a name="mwcl-1704771587813"></a>[1.2 sql慢](#wxdd-1677787447003)

<a name="gz8n-1704771587815"></a>[1.3 接口慢](#olpb-1677787447004)

<a name="bz44-1704771587817"></a>[高并发系统设计](#wrwk-1642647280506)

<a name="lsvi-1704771587819"></a>[1.满足大规模用户同时访问，提供良好响应时间和性能](#8ien-1704757782146)

<a name="ojv7-1704771587821"></a>[2.设计之初就要考虑伸缩性和容错性是非常重要的](#xy0g-1704757785190)

<a name="4xpw-1704771587823"></a>[1.分布式架构](#fvzi-1704756770858)

<a name="gxib-1704771587825"></a>[.微服务架构](#ywzr-1704756872033)

<a name="ncy7-1704771587827"></a>[.分布式计算](#xgna-1704756877646)

<a name="unzy-1704771587829"></a>[2.负载均衡](#wnfy-1704756775272)

<a name="ky2z-1704771587831"></a>[.负载均衡](#h6nf-1704756891918)

<a name="oxxu-1704771587833"></a>[.水平扩展](#c8zr-1704756894402)

<a name="hc4m-1704771587835"></a>[3.数据库设计](#wxjk-1704756782840)

<a name="9v9k-1704771587837"></a>[.读写分离](#lxca-1704756910837)

<a name="yzke-1704771587839"></a>[.数据库分片](#p7d2-1704756922362)

<a name="x7q2-1704771587841"></a>[.缓存](#hxjt-1704756963988)

<a name="ntij-1704771587843"></a>[4.缓存优化](#iivs-1704756788012)

<a name="rlzp-1704771587845"></a>[.分布式缓存](#cvui-1704756971791)

<a name="k8e2-1704771587847"></a>[.本地缓存](#ysly-1704756979122)

<a name="dlj2-1704771587849"></a>[.缓存预热](#rqwj-1704756986363)

<a name="q3l3-1704771587851"></a>[5.消息队列](#so9h-1704756800253)

<a name="bwri-1704771587853"></a>[.异步处理](#sxlo-1704756996000)

<a name="7x8b-1704771587855"></a>[.削峰填谷](#llm2-1704757002994)

<a name="9bqu-1704771587857"></a>[6.分布式事务](#n39o-1704756805232)

<a name="6hls-1704771587859"></a>[.两阶段提交](#5bhj-1704757017700)

<a name="qwul-1704771587861"></a>[.补偿事务](#becc-1704757028036)

<a name="9avd-1704771587863"></a>[7.高可用和容错](#wgkk-1704756813448)

<a name="xypw-1704771587865"></a>[.多地域部署](#akwz-1704757035393)

<a name="jfur-1704771587867"></a>[.设计容错](#3nxv-1704757055271)

<a name="dzaj-1704771587869"></a>[1. 熔断限流](#g3xx-1704757371028)

<a name="lu75-1704771587871"></a>[2. 多节点服务](#jafy-1704757374368)

<a name="qznm-1704771587873"></a>[8.监控和性能调优](#ilyo-1704756820772)

<a name="hmdc-1704771587875"></a>[.实时监控](#kpwq-1704757064566)

<a name="03xt-1704771587877"></a>[.性能测试](#shf4-1704757066453)

<a name="jwa4-1704771587879"></a>[9.安全性设计](#2pry-1704756830245)

<a name="n1fa-1704771587882"></a>[.防御性编程](#pkiw-1704757078583)

<a name="0oy3-1704771587884"></a>[.访问控制](#g4l1-1704757084924)

<a name="91bv-1704771587886"></a>[10.水平扩展](#1tsd-1704756838192)

<a name="rlvq-1704771587888"></a>[.自动化部署](#r1dd-1704757092061)

<a name="tyab-1704771587890"></a>[.云服务](#7mhk-1704757104117)

<a name="tnmh-1704771587892"></a>[高并发性能指标](#rpxb-1677787447005)

<a name="aqlg-1704771587894"></a>[QPS(每秒请求)](#klnv-1704761369323)

<a name="l9dq-1704771587896"></a>[TPS(每秒事务)](#zvlz-1704761369324)

<a name="m9dx-1704771587898"></a>[RT(响应时间)](#gvrn-1704761369325)

<a name="gcha-1704771587900"></a>[===数据密集型应用===](#ozkt-1704761368259)

<a name="lvyu-1704771587902"></a>[设计数据密集型应用](#unbe-1677787447006)

<a name="jrig-1704771587904"></a>[1.可靠性、可拓展性、可维护性能](#kwfx-1677787447007)

<a name="oiex-1704771587906"></a>[-功能性需求：CRUD](#lykw-1644227240038)

<a name="ytnp-1704771587908"></a>[-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性](#b2tu-1644227249556)

<a name="8vfp-1704771587910"></a>[.可靠性：](#qqm5-1644227303238)

<a name="6qza-1704771587912"></a>[.可扩展性： ](#7xms-1644228225080)

<a name="w3ok-1704771587914"></a>[.可维护性：   ](#elzq-1644228563046)

<a name="qwvx-1704771587916"></a>[2.数据模型与查询语言](#jufm-1677787447008)

<a name="mwxz-1704771587918"></a>[-关系模型](#pgu6-1699844351041)

<a name="n7mv-1704771587920"></a>[-NoSql (es,redis)](#kfpd-1644410618294)

<a name="mmjt-1704771587922"></a>[1.文档数据库：](#0p23-1644410807294)

<a name="mv9k-1704771587924"></a>[  2.图形数据库 ：](#09bl-1644410666587)

<a name="7lzm-1704771587926"></a>[-其它模型(基因序列)](#6fxw-1644410924417)

<a name="bama-1704771587928"></a>[3.存储与检索](#sm0u-1677787447009)

<a name="a1m4-1704771587930"></a>[-优化事务处理（OLTP）transaction ](#bhcv-1644935436804)

<a name="o83d-1704771587932"></a>[1.OLTP系统通常面向用户，大量的请求。](#tbhw-1699844517372)

<a name="bwuv-1704771587934"></a>[2.磁盘寻道时间往往是这里的瓶颈。](#fnev-1644935714127)

<a name="yqay-1704771587936"></a>[3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。](#cjwp-1644935609899)

<a name="lwxw-1704771587938"></a>[-优化分析（OLAP）analys](#jg7s-1699844443567)

<a name="00zt-1704771587940"></a>[1.列式储存(投影操作，压缩技术，聚合过滤)](#pjd1-1703887811615)

<a name="sq4y-1704771587942"></a>[-OLTP两大主流学派的存储引擎：](#8sgm-1644935924013)

<a name="k6yk-1704771587944"></a>[1.日志结构学派](#i55y-1644935943748)

<a name="fuxg-1704771587946"></a>[2.就地更新学派](#h3il-1644935977285)

<a name="espo-1704771587948"></a>[4.编码（序列化）与演化(XML,JSON,CSV)](#lbs1-1677787447010)

<a name="g05c-1704771587950"></a>[分布式系统](#d4ge-1677787447011)

<a name="llyc-1704771587952"></a>[4.分布式数据](#4p9n-1677787447012)

<a name="a8tv-1704771587954"></a>[1.高可用性](#o4ag-1646310813851)

<a name="jspe-1704771587956"></a>[2.断开连接的操作](#snwm-1646310894841)

<a name="dlej-1704771587958"></a>[3.减少延迟(节点近)](#evly-1646310918322)

<a name="essz-1704771587960"></a>[4.可拓展性](#itsh-1646310968967)

<a name="slal-1704771587963"></a>[-复制的三种主要方法：](#gbgq-1646311175182)

<a name="nano-1704771587965"></a>[1.单主复制](#wg6v-1646311185918)

<a name="q543-1704771587967"></a>[2.多主复制](#ftqb-1646311200843)

<a name="rpjb-1704771587969"></a>[3.无主复制](#4xbf-1646311410600)

<a name="gszi-1704771587971"></a>[-一致性模型：](#nlnz-1699845075606)

<a name="kuck-1704771587973"></a>[1.写后读](#anqq-1646312272172)

<a name="kjaq-1704771587975"></a>[2.单调读](#hedn-1646312288296)

<a name="4idn-1704771587977"></a>[3.一致前缀读](#fizh-1646312291911)



<a name="jeyl-1677787446995"></a>**一.数据库设计**

<a name="5hya-1677787446996"></a>**1. 关系型数据库**

<a name="ohc5-1621692571287"></a>**.E-R图，由台湾工程师提出的设计概念**

<a name="4z7m-1645598900270"></a>权益系统数据库设计复盘：雄爷并行看需求文档一两天设计DB。

<a name="5ocb-1645598528868"></a>**.流程图-业务逻辑相关，系统用户动作。抽象出E-R图**

<a name="gzqe-1677787446997"></a>**1.1 E-R图** 

<a name="r1ac-1621692724628"></a>**1.根据名词抽象出实体**

<a name="d2fl-1621692745600"></a>**2.名词找属性**

<a name="dwkp-1621692752824"></a>**3.实体间联系**

<a name="cyqi-1699843717785"></a>（单条记录对应关系 A表一条记录对应B表多条记录，B表一条记录对应A表多条记录即 m对）

<a name="53bo-1621692829033"></a><a name="c2cy-1677787446998"></a>**1.2 转化成数据库设计（公式）**

<a name="xmox-1621692858500"></a>**.1 对1 关系 往记录少的乙方加主键**

<a name="mdr8-1621692924289"></a>**.1对n 关系 ，往 n 实体加关联主键** 

<a name="hd3i-1621692960576"></a>**. n对 m 关系，需要一个关联表作映射关联**

<a name="p0tb-1655431896857"></a><a name="i6pd-1655431897042"></a>最好不要自己设计自己的表，关乎字段名统一（属性思想上的统一），以及字段冗余，字段依赖问题。

<a name="cdso-1677787447000"></a>**二.系统优化**

<a name="3qep-1642647362896"></a>**应用整体的优化**

<a name="knge-1642647371136"></a>**-cpu -> 纳秒级别**

<a name="ovup-1704437622969"></a>**1.多线程和并发编程**

<a name="ufpl-1704437634986"></a>**2.JNI** 

<a name="ixb5-1704437634987"></a>**3.JIT/AOT编译**

<a name="kr1f-1704437634988"></a>**4.算法优化**

1\.多线程和并发编程：多线程和并发重复利用多核CPU,利用线程池管理复用线程，避免创建和销毁线程昂贵开销。

2\.JNI: C本地代码调度CPU

3\.JIT/AOT编译：JVM 和 JIT 足够时间来优化热点代码 / 云原生native Graavm ahead of time(AOT)静态编译

<a name="pojo-1704436320217"></a>4.算法优化：优化关键算法和数据结构，确保CPU执行效率

<a name="1xur-1642647384168"></a>**-内存RAM（GB）/高速缓存(KB) -> 微秒级别(分级缓存)**

<a name="7hi9-1704437851514"></a>**1.JVM内存管理**

<a name="te7c-1704437851799"></a>**2.缓存**

<a name="bqty-1704437851800"></a>**3.消息中间件**

(空间换时间)

1\.JVM内存管理：设置合理的堆大小及垃圾回收策略。

2\.缓存：redis缓存，spring缓存，ORM缓存

<a name="pxxu-1704436648342"></a>3.消息中间件：异步写，提高并发写能力。-吞吐量

<a name="ziti-1642647439005"></a>**-磁盘（TB）-> 毫秒级别(减少io次数,减少随机io-redolog)**

<a name="zups-1704437900079"></a>**1.减少磁盘io**

<a name="u3ok-1704438035018"></a>**2.数据压缩**   

1\.减少io(磁盘读写): 异步io,sql索引,局部性原理加载相邻页数据 ,DB数据磁盘预读----数据存储一般在DB系统中

<a name="ayss-1704436737847"></a>2.数据压缩：对需要存储或传输的数据进行压缩，减少磁盘占用

<a name="irbp-1642647458856"></a>**-网络传输/系统交互 -> 秒级 (减少io，连接池化)** 

<a name="6qil-1704438276193"></a>**1.减少网络请求**   

<a name="p5dt-1704438283633"></a>**2.使用CDN**

<a name="zhp8-1704438283634"></a>**3.Sockets异步通信**                                      

1\.减少网络请求：减少io(系统交互/连接池连接数)：去除for循环sql 

`    `--池化思想，创建和销毁消耗大的资源创建一个资源池，维护一定数量的资源数，统一管理资源创建和销毁

2\.使用CDN: 对于静态资源，使用内容分发网络（CDN）来加速资源的加载。

<a name="85si-1704436765735"></a>3.Sockets异步通信：对于需要等待的网络通信，可以考虑使用异步方式。

<a name="3l0l-1704424353262"></a>**项目架构层面的优化**

<a name="8o8s-1704424396933"></a>**-多级缓存**

亿级流量-多级缓存

<a name="lm7b-1704438499917"></a>浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

<a name="trcg-1704438366333"></a>**-应用层**

<a name="68oa-1704438530062"></a>**代码优化**

<a name="clmf-1704438530257"></a>**数据库优化**

<a name="md03-1704438530259"></a>**日志优化**

·代码优化:通过代码审查和性能分析工具来识别和优化慢速或低效的代码。

·数据库优化:对于数据库访问，使用索引、合理的查询语句，以及数据库连接池等来提高性能。

<a name="8o0m-1704438517387"></a>·日志优化:避免过度记录日志，尽量异步记录，或者使用日志级别进行动态调整。

<a name="ocux-1704438477879"></a>**-监控与调优**

<a name="vdq2-1704438556836"></a>**性能监控：**

<a name="t29d-1704438557094"></a>**分析和调优**

·性能监控:使用性能监控工具，例如Java Mission Control、VisualVM等，来实时监测应用程序的性能。

<a name="l3kg-1704437252457"></a>·分析和调优:根据监控结果，进行分析并进行调优，优化性能瓶颈。

<a name="ukjf-1704424419442"></a>**-分布式系统架构**

<a name="a0bx-1704438677201"></a>  **.负载均衡**

<a name="xn9x-1704438687994"></a>**分布式缓存**

<a name="zcdp-1704438687996"></a>**服务降级和容错**

浏览器(客户端缓存) -> Nginx反向代理(本地缓存) -> Redis(缓存) -> Tomcat(进程缓存) -> 应用(缓存、mybatis一二级缓存) -> DB(缓存)

`                `CDN                  SLB负载均衡        分布式缓存          异步通信、MQ异步写/并发写、容错降级

·负载均衡:对于分布式系统，使用负载均衡来分配请求，以确保各个节点的负载均匀。

·分布式缓存:使用分布式缓存来减轻数据库负担，提高数据读取速度。

<a name="xpee-1704438657125"></a>·服务降级和容错:实现服务降级和容错机制，以应对网络或服务不稳定的情况。

<a name="six7-1642647372926"></a>**读写层面**

<a name="g4uv-1704732583614"></a>**.读优化**

<a name="uuzh-1704732602620"></a>**1.缓存**

<a name="qobc-1704732605892"></a>**2.索引**

<a name="zlg9-1704732609048"></a>**3.减少io/批量读**

<a name="fpjd-1704732631316"></a>**4.减少多余数据加载/列式存储读**

<a name="oyob-1704732598377"></a>**.写优化**

<a name="6jmb-1704732509150"></a>**1.异步写**

<a name="tkwp-1704732723564"></a>**2.并发写**

<a name="hewz-1704732862030"></a>**3.批量写**

<a name="ccd8-1704732727854"></a>**4.优化算法和数据结构**

<a name="eqd9-1704732736281"></a>**5.缓存写**

<a name="hyq8-1704732768916"></a>**6.非阻塞io**

1\.批量操作:将多个写操作合并为批量操作，减少与数据库或其他外部存储的交互次数。例如，使用批量插入、批量更新或批量删除等操作，以减少单个写操作的开销。2.异步写入:使用异步写入的方式，将写操作放入队列或缓冲区中，由专门的线程异步处理。这样可以将写操作与主程序解耦，提高响应速度，并将写入操作批量化。

3\.数据库优化:对于关系型数据库，可以考虑优化数据库的配置和索引，以提高写入性

能。使用合适的数据库引擎和事务隔离级别，并优化查询和写入语句的性能。

4\.使用缓存:对于频繁的写入操作，可以使用缓存来减少对数据库的直接访问。将数据写入缓存，并通过批量或定期更新将数据同步到持久化存储。

5\.数据结构优化:选择合适的数据结构来存储数据，以提高写入性能。例如，使用哈希表、跳表等高效的数据结构来支持快速插入和更新操作。

6\.并发处理:使用多线程或分布式处理来并行处理写入操作，以提高写入性能。使用线程池或任务调度器来管理并发写入任务，并确保线程安全和数据─致性。

7\.使用非阻塞IO:对于高并发的写入操作，可以使用非阻塞IO技术，如NIO (New lO)或Netty等，以提高写入性能和吞吐量。

8\.数据分片:如果数据量较大，可以考虑将数据分片存储，将数据分散到多个存储节点上。这样可以将写入操作分散到多个节点上并行处理，以提高写入性能和扩展性。9.写缓冲:使用写缓冲区来缓存写入的数据，减少对物理存储设备的实时写入。通过批

<a name="z4ya-1704738513279"></a>量或异步的方式将缓冲区的数据定期写入存储设备，以提高写入性能。

<a name="tncv-1677787447001"></a>**1.分控系统优化复盘**

<a name="ydq7-1677787447002"></a>**1.1 数据库系统**

<a name="xsbg-1642647218571"></a>数据库的性能过低

<a name="eg0t-1642647223498"></a>提升硬件配置

<a name="wxdd-1677787447003"></a>**1.2 sql慢**

<a name="javd-1642647045138"></a>数据量大一千6百多万条数据

<a name="no1c-1642647140123"></a>删除冗余数据，每天采集13次，需求7天外数据只保留最新一批数据，修正删除的sql, 剩余数据，200w~600w左右。

<a name="ykot-1642649009232"></a>添加索引

<a name="olpb-1677787447004"></a>**1.3 接口慢**

<a name="blpq-1642649142995"></a>for循环遍历sql

<a name="s2zh-1642649153917"></a>去除for循环sql

<a name="yryq-1642649204976"></a> 频繁的采集种erverywhere log.info

<a name="afeg-1642649254648"></a>减少日志文件io，非必要信息改为debug。

<a name="fjt3-1643394063817"></a><a name="efqc-1643394063942"></a>优先考虑优化代价比较少的代码优化及sql优化，完成此类优化再考虑系统设计层面的优化，如：分库分表等（系统复杂度提升）。

<a name="navz-1652597408993"></a>一期历史数据重大bug修复方案设计问题（参看文档）： 注意像算法那样考虑极端情况（bug）处理，梳理方案的优缺点，对比不同方案实现优缺点接受度。

<a name="w6cm-1652597504660"></a>1.保证数据为最新的一批：

<a name="o4ka-1652597649729"></a>原方案. 每天13批次数据，不做事务回滚，取maxid ，>24小时数据删除---<24小时当天取消航班会在其中

<a name="ihuw-1652599412442"></a>配置难点：采集时段不同，每个账号采集不同天数; 采集的时间频率不同：

<a name="uarz-1652598784895"></a>熊爷方案：不改动原有逻辑，增加字段增加判段历史数据逻辑。

<a name="yxwj-1652599128439"></a>优点：基本不用改动一期代码和逻辑，改动sql增加判断历史条件。

<a name="rjdk-1652599326567"></a>缺点：新增判断的逻辑需要批次保证事务性，且配置难度很大，跨小时频率或者地区重叠，不可保证批次完整性，对比无效且配置和代码都得写死。

<a name="cehv-1652599093885"></a>我的方案：保证批次完整性，失败的批次直接整批删除，取最新一批。也是仅改动sql，获取最新一批批次代替 max(id)。

<a name="fm9n-1652599202701"></a>优点：只需要天数不重叠即可，配置相对灵活。

<a name="0ckh-1652599307805"></a>缺点：需要改sql逻辑，业务逻辑影响风险较大，需仔细验证。

<a name="nwww-1652597653246"></a> 

<a name="yjau-1644231171609"></a>分控系统重构设计

<a name="q9y5-1644231078993"></a>可靠性：写操作频繁，250k/h ~70次请求/s，将采集和后台分开两个应用。目前问题，采集两周左右系统资源耗尽会挂，可有多台服务器，实际上只用了两台。（集成应用监控，实现预警）

<a name="1ozg-1644231149674"></a>可拓展性：暂无,用户负载暂无数据

<a name="nbg9-1644231153386"></a>可维护性：代码质量，可读性。

<a name="wrwk-1642647280506"></a>**高并发系统设计**

<a name="8ien-1704757782146"></a>**1.满足大规模用户同时访问，提供良好响应时间和性能**

<a name="xy0g-1704757785190"></a>**2.设计之初就要考虑伸缩性和容错性是非常重要的**

·随着互联网的普及，用户访问量可能会在短时间内急剧增加。高并发系统设计可以确保系统在面对大规模用户同时访问时能够提供良好的响应时间和性能。

<a name="4kjn-1704757525367"></a>.高并发系统的设计是一个复杂而动态的过程，需要根据业务需求和系统特点不断优化。在设计之初就考虑到系统的可伸缩性和容错性是非常重要的。

<a name="fvzi-1704756770858"></a>**1.分布式架构**

<a name="ywzr-1704756872033"></a>**.微服务架构**

<a name="xgna-1704756877646"></a>**.分布式计算**

·微服务架构:使用微服务拆分系统，将系统拆分成多个小而独立的服务，每个服务专注于特定的业务功能。

<a name="6khx-1704757167738"></a>·分布式计算:将任务分布到多个节点上，以充分利用计算资源。

<a name="wnfy-1704756775272"></a>**2.负载均衡**

<a name="h6nf-1704756891918"></a>**.负载均衡**

<a name="c8zr-1704756894402"></a>**.水平扩展**

·负载均衡器:使用负载均衡器分配请求到多个服务器，确保各个服务器的负载均衡。

<a name="o1d2-1704757209512"></a>·水平扩展:可以通过增加服务器数量来水平扩展系统，以支持更多的并发请求。

<a name="wxjk-1704756782840"></a>**3.数据库设计**

<a name="lxca-1704756910837"></a>**.读写分离**

<a name="p7d2-1704756922362"></a>**.数据库分片**

<a name="hxjt-1704756963988"></a>**.缓存**

·读写分离:使用读写分离来分担数据库的读写负载，提高数据库性能。

·数据库分片:将数据库分片，使数据分布在多个节点上，降低单—数据库的压力

<a name="yymm-1704757244191"></a>·缓存:使用缓存来减轻数据库负担，提高数据读取速度。

<a name="iivs-1704756788012"></a>**4.缓存优化**

<a name="cvui-1704756971791"></a>**.分布式缓存**

<a name="ysly-1704756979122"></a>**.本地缓存**

<a name="rqwj-1704756986363"></a>**.缓存预热**

·分布式缓存:使用分布式缓存，如Redis或Memcached，以提高数据的读取速度。

·本地缓存:在服务端使用本地缓存，减少对数据库或远程服务的请求次数。

<a name="vkcq-1704757254304"></a>·缓存预热:在系统启动时，预先加载一部分热门数据到缓存中，提高缓存命中率。

<a name="so9h-1704756800253"></a>**5.消息队列**

<a name="sxlo-1704756996000"></a>**.异步处理**

<a name="llm2-1704757002994"></a>**.削峰填谷**

·异步处理:使用消息队列进行异步处理，将一些非实时关键路径的任务放入队列中处理，减轻服务器负担。

<a name="99fz-1704757286906"></a>·削峰填谷:缓解系统压力，通过消息队列实现请求的削峰填谷，防止瞬时大量请求导致系统崩溃。

<a name="n39o-1704756805232"></a>**6.分布式事务**

<a name="5bhj-1704757017700"></a>**.两阶段提交**

<a name="becc-1704757028036"></a>**.补偿事务**

两阶段提交（2PC):在分布式环境中，确保事务的一致性，可以使用两阶段提交协议。

<a name="qset-1704757299753"></a>·补偿事务:使用补偿事务机制，处理在分布式环境中的异常情况。

<a name="wgkk-1704756813448"></a>**7.高可用和容错**

<a name="akwz-1704757035393"></a>**.多地域部署**

<a name="3nxv-1704757055271"></a>**.设计容错**

<a name="g3xx-1704757371028"></a>**1. 熔断限流**

<a name="jafy-1704757374368"></a>**2. 多节点服务**

·多地域部署:在不同地理位置部署系统，提高系统的可用性。

<a name="h6bn-1704757326243"></a>·容错设计:使用容错设计，确保系统在部分节点或服务失效时能够继续提供服务。

<a name="ilyo-1704756820772"></a>**8.监控和性能调优**

<a name="kpwq-1704757064566"></a>**.实时监控**

<a name="shf4-1704757066453"></a>**.性能测试**

·实时监控:使用监控系统实时监测系统性能，对系统进行及时调整。

<a name="lkos-1704757433031"></a>性能测试:定期进行性能测试，模拟高并发情况，找出系统的瓶颈并进行优化。

<a name="2pry-1704756830245"></a>**9.安全性设计**

<a name="pkiw-1704757078583"></a>**.防御性编程**

<a name="g4l1-1704757084924"></a>**.访问控制**

·防御性编程:编写安全的代码，防范SQL注入、XSS攻击等。

<a name="g9ef-1704757459182"></a>·访问控制:对系统的访问进行严格控制，避免未经授权的访问。

<a name="1tsd-1704756838192"></a>**10.水平扩展**

<a name="r1dd-1704757092061"></a>**.自动化部署**

<a name="7mhk-1704757104117"></a>**.云服务**

·自动化扩展:设计自动化扩展机制，根据系统负载自动增减节点。

<a name="g3qv-1704757477668"></a>·云服务:使用云服务提供商的弹性计算能力，根据需求调整计算资源。

<a name="rpxb-1677787447005"></a>**高并发性能指标**

<a name="klnv-1704761369323"></a>**QPS(每秒请求)**

<a name="zvlz-1704761369324"></a>**TPS(每秒事务)**

<a name="gvrn-1704761369325"></a>**RT(响应时间)**

我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。

公式：( 总PV数 \* 80% ) / ( 每天秒数 \* 20% ) = 峰值时间每秒请求数(QPS)

机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器

1、每天300w PV(网页浏览量) 的在单台机器上，这台机器需要多少QPS？ 

( 3000000 \* 0.8 ) / (86400 \* 0.2 ) = 139 (QPS)

2、如果一台机器的QPS是58，需要几台机器（cpu瓶颈）来支持？ ---得分析性能瓶颈，例如是CPU还是数据库。

<a name="02ut-1704761377369"></a>139 / 58 = 3 

<a name="ozkt-1704761368259"></a>**===数据密集型应用===**

<a name="ef5t-1644230945318"></a>数据系统基础

<a name="unbe-1677787447006"></a>**设计数据密集型应用**

<a name="kwfx-1677787447007"></a>**1.可靠性、可拓展性、可维护性能**

<a name="zrzj-1642646974315"></a>小结：一个应用必须满足各种需求才称得上有用

<a name="lykw-1644227240038"></a>**-功能性需求：CRUD**

<a name="b2tu-1644227249556"></a>**-非功能性需求：安全性，可靠性，合规性，可扩展性，兼容性和可维护性**

<a name="qqm5-1644227303238"></a>**.可靠性：**

<a name="vdpc-1699843965882"></a>以为着即使发生故障，系统也能正常工作。

<a name="mk9e-1644227360160"></a>故障可能发生在硬件（通常是随机和不相关的）

<a name="w7by-1644227387308"></a>软件（通常是系统性的bug,很难处理）

<a name="dozl-1644227415061"></a>人类（不可避免的时不时出错）

<a name="fvz4-1644227444254"></a>**容错技术**可以对终端用户隐藏某些类型的故障。

<a name="7xms-1644228225080"></a>**.可扩展性：** 

<a name="t59j-1699843967201"></a>意味着即使在增加负载的情况下也能保持性能的策略。

<a name="gqfn-1644228379215"></a>为了讨论可拓展性，首先要定量描述负载和性能的方法。

<a name="krij-1644228405843"></a>推特主页时间线的例子，介绍描述负载参数，并将响应时间百分点作为衡量性能的一种方式。头部阻塞、尾部延迟。(有很多人通过将工作负载迁移到低延迟、自适应的GC来控制尾部延迟-infoQ java趋势)

<a name="bynr-1644228470161"></a>在可扩展的系统中可以添加**处理容量** 以在高负载下保持可靠。

<a name="elzq-1644228563046"></a>**.可维护性：**   

<a name="vg1v-1699843968229"></a>可维护性实质上是关于工程师和运维团队生活质量的。

<a name="mq1x-1644231096441"></a>良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。

<a name="qj5f-1644228656997"></a>良好的可操作性意味这对系统的健康状态具有良好的可见性，并拥有有效的管理手段。

<a name="gwsd-1644231020558"></a><a name="jufm-1677787447008"></a>**2.数据模型与查询语言**

<a name="guby-1644404619396"></a>本章小结：数据模型时一个巨大的课题，在本章中，我们快速浏览了各种不同的模型。以便激起兴趣，更多的了解**最适合你的应用的需求模型**。（数据库选型）

<a name="o6we-1644404838474"></a>在历史上，**数据最开始被表示为一颗大树（层次型结构**），但是这不利于表示多对多的关系，所以发明了

<a name="pgu6-1699844351041"></a>**-关系模型**

<a name="jayo-1699844352979"></a>来解决这个问题。

<a name="kfpd-1644410618294"></a>**-NoSql (es,redis)**

<a name="uzbw-1699844301003"></a>**通常**不会为存储的数据强制一个模式，这可以使应用程序更容易适应不断变化的需求。

<a name="0p23-1644410807294"></a>**1.文档数据库：**

<a name="9rlb-1699844336493"></a>数据通常是自我包含的，而且文档之间的关系非常稀少

<a name="09bl-1644410666587"></a>  **2.图形数据库 ：**

<a name="imif-1699844337670"></a>与文档数据库相反的场景-任意事务都可能与任何事务相关联

<a name="6fxw-1644410924417"></a>**-其它模型(基因序列)**

<a name="he0m-1699844309707"></a>** 基因组 通常需要 **序列相似性搜索，意味着一**个很长的字符串，并在一个拥有类似但不完全相同的字符串的大型数据库中寻找匹配。这里所描述的数据库都不能处理这种用法。研究人员编写了想GenBank专门的基因组数据库软件。

<a name="opsf-1644411138194"></a>                 粒子物理学家进行大数据类型的大规模数据分析。粒子对撞机（LHC）这样的项目可以工作在数百亿兆字节的范围内。这样的规模下，需要指定解决方案来阻止硬件成本的失控。

<a name="pnul-1644935322505"></a><a name="sm0u-1677787447009"></a>**3.存储与检索**

<a name="ycte-1644935336049"></a>本章小结：数据库如何处理存储何检索。将数据存储在数据库中会发生什么，再次查询数据库会发生什么？

<a name="bivs-1644935398311"></a>在高层次上，存储引擎分两大类：

<a name="bhcv-1644935436804"></a>**-优化事务处理（OLTP）transaction** 

<a name="tbhw-1699844517372"></a>**1.OLTP系统通常面向用户，大量的请求。**

<a name="fnev-1644935714127"></a>**2.磁盘寻道时间往往是这里的瓶颈。**

<a name="cjwp-1644935609899"></a>**3.应用程序使用某种键来请求记录，存储引擎使用索引来查找所请求额键的数据。**

<a name="jg7s-1699844443567"></a>**-优化分析（OLAP）analys**

<a name="n8me-1644935726822"></a>    OLTP数据 copy and translatin 转换为适合业务分析的数据副本 to 数据仓库（OLAP）

<a name="3cwp-1644935731444"></a>OLAP**数据仓库**和类似的分析系统不太知名，因为只要由业务分析人员使用，而不是由最终用户使用

<a name="s6pt-1644935799372"></a>处理比OLTP系统少得多得查询量，但是每个查询通常要求很高，短时间内扫描百万条记录。

<a name="cyhe-1644935862917"></a>磁盘带宽（不是查找时间）往往是瓶颈，列式存储是这种工作负载的流行解决方案。

<a name="pjd1-1703887811615"></a>**1.列式储存(投影操作，压缩技术，聚合过滤)**

OLAP TB,PB级别的数据(几百列)情况下，索引的相关性就会下降很多，磁盘带宽往往是瓶颈

解决方案-列式存储

1\.将表头设置为列文件名，文件存储单列内容、

2\.如需第23行，则将需要的列文件的第23项形成表的第23行

优势：

.投影操作：仅需检索所需的列，大大减少读取的数据量。

.压缩技术：通常采取高度优化的压缩技术。-相邻的数据通常具有相似的值。减少存储空间，提高查询性能

.向量化处理：通常采用向量化处理，意味着可以一次操作整个数据向量，而不是逐个处理行。-并行处理和SIMD指令集优化非常有利

.聚合操作：在SUM、AVG等聚合操作上表现良好

.过滤操作：特定列过滤更快

.分析查询：部分查询而不是全部

<a name="kg2a-1703885936042"></a>Apache: Cassandra、 HBase

<a name="8sgm-1644935924013"></a>**-OLTP两大主流学派的存储引擎：**

<a name="i55y-1644935943748"></a>**1.日志结构学派**

<a name="4nm8-1644935988277"></a>只允许附加到文件和删除过时文件，但不会更新已经写入的文件。（高效，顺序IO?）

<a name="6ymo-1644936029696"></a>Bitcask, SSTables, LSM树，LevelDB, Cassandra, HBase, Lucene等都属于这个组。

<a name="h3il-1644935977285"></a>**2.就地更新学派**

<a name="2w0c-1644936091115"></a>将磁盘视为一组可以覆盖的固定大小页面。（随机IO?）

<a name="hpzs-1644936142472"></a>B树是这种哲学的最大例子，被用在所有主要的关系数据库中，还有许多非关系数据库。

<a name="fil5-1644936170765"></a><a name="vypn-1644936170925"></a>日志结构的存储引擎是相对较新的发展，他们的主要想法是，系统地将随机访问写入顺序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短的介绍。

<a name="a5tj-1644936526197"></a>然后我们从存储引擎的内部绕开，看看典型的数据仓库的高级架构。这一背景说明了为什么分析工作负载和OLTP差别很大：

<a name="nyml-1644936619727"></a>当您的查询需要在大量（几百列）的行中顺序扫描时，索引的相关性就会下降很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读取的数据量。我们讨论了列式存储如何帮助实现这一目标。

<a name="2akd-1644935679338"></a>作为一名应用开发人员，如果您掌握了有关存储引擎内部知识，那么就能更好地那种工具最适合您的特定应用程序。如果需要调整库的参数，这种理解可以让您设想一个更高或者更低的参数可能会产生什么效果。

<a name="ohao-1644936963029"></a>尽管本章不能让你成为一个特定存储引擎的调参专拣，但它至少有大概率使你有了足够的概念与词汇储备去读懂数据库的文档，从而选择合适的数据库。

<a name="en4q-1644936942676"></a><a name="lbs1-1677787447010"></a>**4.编码（序列化）与演化(XML,JSON,CSV)**

<a name="18rw-1644940257792"></a>在本章中，我们研究了将数据结构转换为网络中的字节或磁盘上的字节的几种方法。编码的细节影响其效率，更重要的是应用程序的体系结构和部署它们的选项。

<a name="bfvx-1644940365841"></a>特别是，许多服务需要支持滚动升级（灰度发布），其中新版本的服务逐步部署到少数节点，而不是同时部署到所有节点。滚动升级允许在不停机的情况下发布新版本的服务（从而鼓励在罕见的大型版本上频繁发布小型版本），并使部署风险降低（允许在影响大量用户之前检测并回滚有故障的版本）。这些属性对于可演化性，以及对应用程序进行更改的容易性都是非常有利的。

<a name="w4qv-1644940598057"></a>在滚动升级期间，或出于其它原因，我们必须假设不同的节点正在运行我们的应用程序代码的不同版本。因此，在系统周围流动的所有数据都是以提供向后兼容性（新代码可以读取旧数据-服务端）和向前兼容性（旧代码可以读取新数据-客户端）的方式进行编码是重要的。我们讨论了几种数据编码格式极其兼容性：

<a name="zw4l-1644940805237"></a>编程语言特定编码仅限于单一编程语言，并且往往无法提供向前和向后兼容性。

<a name="1zx9-1644940881501"></a>JSON, XML和CSV等文本格式非常普遍，其兼容性取决于如何使用它们。他们有可选模式语言，这有时是有用的，有时是一个障碍。这些数据格式对于数据类型有些模糊，所以你必须小心数字和二进制字符串。

<a name="q8m7-1644942050475"></a>像Thrift, Protocol Buffers和Avro这样的二进制模式驱动格式允许使用清晰定义的向前和向后兼容性语义进行紧凑，搞笑的编码。这些模式可以用于静态类型语言的文档和代码生成。但是，他们有一个去缺点，就是在数据可读之前需要对数据进行解码。

<a name="hqvm-1644942192088"></a>我们还讨论了几种数据流的几种模式，说明了数据编码是重要的不同场景：

<a name="c94y-1644942236778"></a>数据库，写入数据库的进程对数据进行编码，并从数据库读取进程对其进行解码

<a name="kcmv-1644942289426"></a>RPC 和 REST API, 客户端对请求进行编码，服务器对请求进行解码并对相应进行编码，客户端最终对相应进行解码。

<a name="nvcq-1644942366178"></a>异步消息传递（使用消息代理或参与者），其中节点之间通过发送消息进行通信，消息由发送者编码并由接收者解码。

<a name="oxsf-1644942481249"></a>我们可以小心地得出这样的结论：向前兼容性和滚动升级在某种成都上是可以实现的。愿您的应用程序的演变迅速，敏捷部署。

<a name="rmsh-1646310193756"></a><a name="d4ge-1677787447011"></a>**分布式系统**

<a name="4p9n-1677787447012"></a>**4.分布式数据**

<a name="gr0m-1646310278506"></a>本章考察了复制的问题，复制可以用于几个目的：

<a name="o4ag-1646310813851"></a>**1.高可用性**

<a name="r7ua-1646310833943"></a>即使在一台机器（或多台机器，或整个数据中心）停机的情况下也能保持系统正常运行

<a name="snwm-1646310894841"></a>**2.断开连接的操作**

<a name="x2dq-1646310900787"></a>允许应用程序在网络中断时继续工作

<a name="evly-1646310918322"></a>**3.减少延迟(节点近)**

<a name="iz8f-1646310928916"></a>将数据放置在距离用户较近的地方，以便用户能够更快地与其交互

<a name="itsh-1646310968967"></a>**4.可拓展性**

<a name="ncek-1646310974776"></a>能够处理比单个机器更高的读取量可以通过对副本进行读取来处理

<a name="ybmg-1646311013702"></a><a name="a6ti-1646311014184"></a>尽管是一个简单的目标-在几台机器上保留相同数据的副本，但复制确实一个非常棘手的一个问题。它需要仔细考虑并发和所有可能出错的事情，并处理这些故障的后果。

<a name="cpjg-1646311086181"></a>至少，我们需要处理不可用的节点和网络中断（甚至不考虑更隐蔽的故障，例如由软件错误导致的无提示数据损坏）。

<a name="gbgq-1646311175182"></a>**-复制的三种主要方法：**

<a name="wg6v-1646311185918"></a>**1.单主复制**

<a name="ehug-1646311426407"></a>客户端将所有写入操作发送到单个节点（领导者），该结点将数据更改事件流发送到其它副本（追随者）。

<a name="wgge-1646311567456"></a>读取可以再任何副本中执行，但从追随者读取可能是陈旧的 （最终一致性问题）

<a name="ftqb-1646311200843"></a>**2.多主复制**

<a name="ak8v-1646311613462"></a>客户端发送每个写入到几个领导节点之一，其中任何一个都可以接受写入。领导者将数据更改事件流发送给彼此以及任何跟随着节点。

<a name="4xbf-1646311410600"></a>**3.无主复制**

<a name="b6zn-1646311685371"></a>客户端发送每个写入到几个节点，并从多个节点并行多去，以检测和纠正具有陈旧数据的节点。

<a name="tyus-1646311850435"></a><a name="dzsw-1646311850942"></a>单主复制是非常流行的。多领导和无领导复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。

<a name="sgmj-1646311002454"></a>我们讨论了一些有助于决定应用程序在复制滞后时的行为的

<a name="nlnz-1699845075606"></a>**-一致性模型：**

<a name="anqq-1646312272172"></a>**1.写后读**

<a name="jvwc-1646312310729"></a>用户应该总是看到自己提交的数据。

<a name="hedn-1646312288296"></a>**2.单调读**

<a name="wxgc-1646312331720"></a>用户在一个时间点看到数据后，他们不应该在某个早期时间点看到数据

<a name="fizh-1646312291911"></a>**3.一致前缀读**

<a name="5okd-1646312382954"></a>用户应该将数据视为具有因果意义的状态：例如，按照正确的顺序查看问题及其答复

<a name="drau-1646310922027"></a><a name="eumz-1646312681469"></a>多领导者和无领导者复制方法所固有的并发问题：允许多个写入并发发生冲突。研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者他们是否同时发生。

<a name="xukg-1646312787143"></a>还谈到了通过合并并发更新来解决冲突的方法。









